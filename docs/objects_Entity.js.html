<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: objects/Entity.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: objects/Entity.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/** Class representing any entity in game world. It derives after Phaser.Sprite.*/
class Entity extends Phaser.Sprite {
  /**
  * Create a Entity. Set its anchor to center, enable arcade physics on it add entity to existing game world.
  * @param {object} game - A reference to the currently running game.
  * @param {number} x - The x coordinate (in world space) to position the Sprite at.
  * @param {number} x - The y coordinate (in world space) to position the Sprite at.
  * @param {string} imageKey - This is the key to image used by the Sprite during rendering.
  * @param {number} frame - If this Sprite is using part of a sprite sheet or texture atlas you can specify the exact frame to use by giving a numeric index.
  */
  constructor( game, x, y, imageKey, frame ) {
    super( game, x, y, imageKey, frame );

    this.anchor.setTo( 0.5, 0.5 );

    this.game.physics.enable( this, Phaser.Physics.ARCADE );
    this.body.collideWorldBounds = true;

    this.game.world.add( this );
  }
  /**
  * Rotate a Entity to look at given target.
  * @param {number} targetX - The target x coordintate.
  * @param {number} targetY - The target y coordintate.
  */
  lookAt( targetX, targetY ) {
    const targetPoint = new Phaser.Point( targetX, targetY );
    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );

    let targetAngle = Phaser.Math.radToDeg( Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) ) - 90;

    if ( targetAngle &lt; 0 ) {
      targetAngle += 360;
    }

    this.angle = targetAngle;
  }
  /**
  * Check if entity is moving in both dimensions, if so, lower vector values to move with normal speed.
  */
  normalizeVelocity() {
    if ( this.body.velocity.x !== 0 &amp;&amp; this.body.velocity.y !== 0 ) {
      this.body.velocity.x = this.body.velocity.x * Math.sqrt( 2 ) * 1 / 2;
      this.body.velocity.y = this.body.velocity.y * Math.sqrt( 2 ) * 1 / 2;
    }
  }
  resetVelocity() {
    this.body.velocity.x = 0;
    this.body.velocity.y = 0;
  }
}

export default Entity;
</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="Boot.html">Boot</a></li><li><a href="Entity.html">Entity</a></li><li><a href="module.exports.html">exports</a></li><li><a href="Preload.html">Preload</a></li><li><a href="ProjectNostradamus.html">ProjectNostradamus</a></li></ul><h3>Global</h3><ul><li><a href="global.html#calculatePathsBetweenTargets">calculatePathsBetweenTargets</a></li><li><a href="global.html#changePathToTemporary">changePathToTemporary</a></li><li><a href="global.html#collide">collide</a></li><li><a href="global.html#handleMovement">handleMovement</a></li><li><a href="global.html#handleMovementSpecialModes">handleMovementSpecialModes</a></li><li><a href="global.html#onStepTargetReach">onStepTargetReach</a></li><li><a href="global.html#update">update</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.4.3</a> on Mon Jan 09 2017 22:23:01 GMT+0100 (CET)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
