{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/easystarjs/src/easystar.js",
    "node_modules/easystarjs/src/instance.js",
    "node_modules/easystarjs/src/node.js",
    "node_modules/heap/index.js",
    "node_modules/heap/lib/heap.js",
    "src/ProjectNostradamus.js",
    "src/UI/GameOverUI.js",
    "src/constants/ItemConstants.js",
    "src/constants/PlayerConstants.js",
    "src/constants/TileMapConstants.js",
    "src/constants/UserInterfaceConstants.js",
    "src/constants/ZombieConstants.js",
    "src/index.js",
    "src/levels/Level1.js",
    "src/levels/Level2.js",
    "src/objects/BoidsManager.js",
    "src/objects/Entity.js",
    "src/objects/Journal.js",
    "src/objects/JournalsManager.js",
    "src/objects/Player.js",
    "src/objects/TileMap.js",
    "src/objects/Zombie.js",
    "src/objects/ZombieComponents/ChasingPlayerManager.js",
    "src/objects/ZombieComponents/NotificationsManager.js",
    "src/objects/ZombieComponents/PathFinder.js",
    "src/objects/ZombieComponents/SeekingPlayerManager.js",
    "src/objects/ZombieComponents/ZombiePathManager.js",
    "src/objects/ZombieComponents/ZombieRotationManager.js",
    "src/states/Boot.js",
    "src/states/Game.js",
    "src/states/Menu.js",
    "src/states/Preload.js",
    "src/utils/DeterminePathCollisionUtils.js",
    "src/utils/HandlePathCollisionUtils.js",
    "src/utils/MapUtils.js",
    "src/utils/MathUtils.js",
    "src/utils/UserInterfaceUtils.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvXA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;I,AAEM;g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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/**\n*   EasyStar.js\n*   github.com/prettymuchbryce/EasyStarJS\n*   Licensed under the MIT license.\n*\n*   Implementation By Bryce Neal (@prettymuchbryce)\n**/\n\nvar EasyStar = {}\nvar Instance = require('./instance');\nvar Node = require('./node');\nvar Heap = require('heap');\n\nconst CLOSED_LIST = 0;\nconst OPEN_LIST = 1;\n\nmodule.exports = EasyStar;\n\nEasyStar.js = function() {\n    var STRAIGHT_COST = 1.0;\n    var DIAGONAL_COST = 1.4;\n    var syncEnabled = false;\n    var pointsToAvoid = {};\n    var collisionGrid;\n    var costMap = {};\n    var pointsToCost = {};\n    var directionalConditions = {};\n    var allowCornerCutting = true;\n    var iterationsSoFar;\n    var instances = [];\n    var iterationsPerCalculation = Number.MAX_VALUE;\n    var acceptableTiles;\n    var diagonalsEnabled = false;\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array|Number} tiles An array of numbers that represent\n    * which tiles in your grid should be considered\n    * acceptable, or \"walkable\".\n    **/\n    this.setAcceptableTiles = function(tiles) {\n        if (tiles instanceof Array) {\n            // Array\n            acceptableTiles = tiles;\n        } else if (!isNaN(parseFloat(tiles)) && isFinite(tiles)) {\n            // Number\n            acceptableTiles = [tiles];\n        }\n    };\n\n    /**\n    * Enables sync mode for this EasyStar instance..\n    * if you're into that sort of thing.\n    **/\n    this.enableSync = function() {\n        syncEnabled = true;\n    };\n\n    /**\n    * Disables sync mode for this EasyStar instance.\n    **/\n    this.disableSync = function() {\n        syncEnabled = false;\n    };\n\n    /**\n     * Enable diagonal pathfinding.\n     */\n    this.enableDiagonals = function() {\n        diagonalsEnabled = true;\n    }\n\n    /**\n     * Disable diagonal pathfinding.\n     */\n    this.disableDiagonals = function() {\n        diagonalsEnabled = false;\n    }\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array} grid The collision grid that this EasyStar instance will read from.\n    * This should be a 2D Array of Numbers.\n    **/\n    this.setGrid = function(grid) {\n        collisionGrid = grid;\n\n        //Setup cost map\n        for (var y = 0; y < collisionGrid.length; y++) {\n            for (var x = 0; x < collisionGrid[0].length; x++) {\n                if (!costMap[collisionGrid[y][x]]) {\n                    costMap[collisionGrid[y][x]] = 1\n                }\n            }\n        }\n    };\n\n    /**\n    * Sets the tile cost for a particular tile type.\n    *\n    * @param {Number} The tile type to set the cost for.\n    * @param {Number} The multiplicative cost associated with the given tile.\n    **/\n    this.setTileCost = function(tileType, cost) {\n        costMap[tileType] = cost;\n    };\n\n    /**\n    * Sets the an additional cost for a particular point.\n    * Overrides the cost from setTileCost.\n    *\n    * @param {Number} x The x value of the point to cost.\n    * @param {Number} y The y value of the point to cost.\n    * @param {Number} The multiplicative cost associated with the given point.\n    **/\n    this.setAdditionalPointCost = function(x, y, cost) {\n        pointsToCost[x + '_' + y] = cost;\n    };\n\n    /**\n    * Remove the additional cost for a particular point.\n    *\n    * @param {Number} x The x value of the point to stop costing.\n    * @param {Number} y The y value of the point to stop costing.\n    **/\n    this.removeAdditionalPointCost = function(x, y) {\n        delete pointsToCost[x + '_' + y];\n    }\n\n    /**\n    * Remove all additional point costs.\n    **/\n    this.removeAllAdditionalPointCosts = function() {\n        pointsToCost = {};\n    }\n\n    /**\n    * Sets a directional condition on a tile\n    *\n    * @param {Number} x The x value of the point.\n    * @param {Number} y The y value of the point.\n    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access\n    * the tile.\n    **/\n    this.setDirectionalCondition = function(x, y, allowedDirections) {\n        directionalConditions[x + '_' + y] = allowedDirections;\n    };\n\n    /**\n    * Remove all directional conditions\n    **/\n    this.removeAllDirectionalConditions = function() {\n        directionalConditions = {};\n    };\n\n    /**\n    * Sets the number of search iterations per calculation.\n    * A lower number provides a slower result, but more practical if you\n    * have a large tile-map and don't want to block your thread while\n    * finding a path.\n    *\n    * @param {Number} iterations The number of searches to prefrom per calculate() call.\n    **/\n    this.setIterationsPerCalculation = function(iterations) {\n        iterationsPerCalculation = iterations;\n    };\n\n    /**\n    * Avoid a particular point on the grid,\n    * regardless of whether or not it is an acceptable tile.\n    *\n    * @param {Number} x The x value of the point to avoid.\n    * @param {Number} y The y value of the point to avoid.\n    **/\n    this.avoidAdditionalPoint = function(x, y) {\n        pointsToAvoid[x + \"_\" + y] = 1;\n    };\n\n    /**\n    * Stop avoiding a particular point on the grid.\n    *\n    * @param {Number} x The x value of the point to stop avoiding.\n    * @param {Number} y The y value of the point to stop avoiding.\n    **/\n    this.stopAvoidingAdditionalPoint = function(x, y) {\n        delete pointsToAvoid[x + \"_\" + y];\n    };\n\n    /**\n    * Enables corner cutting in diagonal movement.\n    **/\n    this.enableCornerCutting = function() {\n        allowCornerCutting = true;\n    };\n\n    /**\n    * Disables corner cutting in diagonal movement.\n    **/\n    this.disableCornerCutting = function() {\n        allowCornerCutting = false;\n    };\n\n    /**\n    * Stop avoiding all additional points on the grid.\n    **/\n    this.stopAvoidingAllAdditionalPoints = function() {\n        pointsToAvoid = {};\n    };\n\n    /**\n    * Find a path.\n    *\n    * @param {Number} startX The X position of the starting point.\n    * @param {Number} startY The Y position of the starting point.\n    * @param {Number} endX The X position of the ending point.\n    * @param {Number} endY The Y position of the ending point.\n    * @param {Function} callback A function that is called when your path\n    * is found, or no path is found.\n    *\n    **/\n    this.findPath = function(startX, startY, endX, endY, callback) {\n        // Wraps the callback for sync vs async logic\n        var callbackWrapper = function(result) {\n            if (syncEnabled) {\n                callback(result);\n            } else {\n                setTimeout(function() {\n                    callback(result);\n                });\n            }\n        }\n\n        // No acceptable tiles were set\n        if (acceptableTiles === undefined) {\n            throw new Error(\"You can't set a path without first calling setAcceptableTiles() on EasyStar.\");\n        }\n        // No grid was set\n        if (collisionGrid === undefined) {\n            throw new Error(\"You can't set a path without first calling setGrid() on EasyStar.\");\n        }\n\n        // Start or endpoint outside of scope.\n        if (startX < 0 || startY < 0 || endX < 0 || endY < 0 ||\n        startX > collisionGrid[0].length-1 || startY > collisionGrid.length-1 ||\n        endX > collisionGrid[0].length-1 || endY > collisionGrid.length-1) {\n            throw new Error(\"Your start or end point is outside the scope of your grid.\");\n        }\n\n        // Start and end are the same tile.\n        if (startX===endX && startY===endY) {\n            callbackWrapper([]);\n            return;\n        }\n\n        // End point is not an acceptable tile.\n        var endTile = collisionGrid[endY][endX];\n        var isAcceptable = false;\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (endTile === acceptableTiles[i]) {\n                isAcceptable = true;\n                break;\n            }\n        }\n\n        if (isAcceptable === false) {\n            callbackWrapper(null);\n            return;\n        }\n\n        // Create the instance\n        var instance = new Instance();\n        instance.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.bestGuessDistance() - nodeB.bestGuessDistance();\n        });\n        instance.isDoneCalculating = false;\n        instance.nodeHash = {};\n        instance.startX = startX;\n        instance.startY = startY;\n        instance.endX = endX;\n        instance.endY = endY;\n        instance.callback = callbackWrapper;\n\n        instance.openList.push(coordinateToNode(instance, instance.startX,\n            instance.startY, null, STRAIGHT_COST));\n\n        instances.push(instance);\n    };\n\n    /**\n    * This method steps through the A* Algorithm in an attempt to\n    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.\n    * You can change the number of calculations done in a call by using\n    * easystar.setIteratonsPerCalculation().\n    **/\n    this.calculate = function() {\n        if (instances.length === 0 || collisionGrid === undefined || acceptableTiles === undefined) {\n            return;\n        }\n        for (iterationsSoFar = 0; iterationsSoFar < iterationsPerCalculation; iterationsSoFar++) {\n            if (instances.length === 0) {\n                return;\n            }\n\n            if (syncEnabled) {\n                // If this is a sync instance, we want to make sure that it calculates synchronously.\n                iterationsSoFar = 0;\n            }\n\n            // Couldn't find a path.\n            if (instances[0].openList.size() === 0) {\n                var ic = instances[0];\n                ic.callback(null);\n                instances.shift();\n                continue;\n            }\n\n            var searchNode = instances[0].openList.pop();\n\n            // Handles the case where we have found the destination\n            if (instances[0].endX === searchNode.x && instances[0].endY === searchNode.y) {\n                instances[0].isDoneCalculating = true;\n                var path = [];\n                path.push({x: searchNode.x, y: searchNode.y});\n                var parent = searchNode.parent;\n                while (parent!=null) {\n                    path.push({x: parent.x, y:parent.y});\n                    parent = parent.parent;\n                }\n                path.reverse();\n                var ic = instances[0];\n                var ip = path;\n                ic.callback(ip);\n                return\n            }\n\n            var tilesToSearch = [];\n            searchNode.list = CLOSED_LIST;\n\n            if (searchNode.y > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: -1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y-1)});\n            }\n            if (searchNode.x < collisionGrid[0].length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x+1, searchNode.y)});\n            }\n            if (searchNode.y < collisionGrid.length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: 1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y+1)});\n            }\n            if (searchNode.x > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: -1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x-1, searchNode.y)});\n            }\n            if (diagonalsEnabled) {\n                if (searchNode.x > 0 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y+1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x > 0 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y+1)});\n                    }\n                }\n            }\n\n            var isDoneCalculating = false;\n\n            // Search all of the surrounding nodes\n            for (var i = 0; i < tilesToSearch.length; i++) {\n                checkAdjacentNode(tilesToSearch[i].instance, tilesToSearch[i].searchNode,\n                    tilesToSearch[i].x, tilesToSearch[i].y, tilesToSearch[i].cost);\n                if (tilesToSearch[i].instance.isDoneCalculating === true) {\n                    isDoneCalculating = true;\n                    break;\n                }\n            }\n\n            if (isDoneCalculating) {\n                instances.shift();\n                continue;\n            }\n\n        }\n    };\n\n    // Private methods follow\n    var checkAdjacentNode = function(instance, searchNode, x, y, cost) {\n        var adjacentCoordinateX = searchNode.x+x;\n        var adjacentCoordinateY = searchNode.y+y;\n\n        if (pointsToAvoid[adjacentCoordinateX + \"_\" + adjacentCoordinateY] === undefined &&\n            isTileWalkable(collisionGrid, acceptableTiles, adjacentCoordinateX, adjacentCoordinateY, searchNode)) {\n            var node = coordinateToNode(instance, adjacentCoordinateX,\n                adjacentCoordinateY, searchNode, cost);\n\n            if (node.list === undefined) {\n                node.list = OPEN_LIST;\n                instance.openList.push(node);\n            } else if (searchNode.costSoFar + cost < node.costSoFar) {\n                node.costSoFar = searchNode.costSoFar + cost;\n                node.parent = searchNode;\n                instance.openList.updateItem(node);\n            }\n        }\n    };\n\n    // Helpers\n    var isTileWalkable = function(collisionGrid, acceptableTiles, x, y, sourceNode) {\n        if (directionalConditions[x + \"_\" + y]) {\n            var direction = calculateDirection(sourceNode.x - x, sourceNode.y - y)\n            var directionIncluded = function () {\n                for (var i = 0; i < directionalConditions[x + \"_\" + y].length; i++) {\n                    if (directionalConditions[x + \"_\" + y][i] === direction) return true\n                }\n                return false\n            }\n            if (!directionIncluded()) return false\n        }\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (collisionGrid[y][x] === acceptableTiles[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * -1, -1 | 0, -1  | 1, -1\n     * -1,  0 | SOURCE | 1,  0\n     * -1,  1 | 0,  1  | 1,  1\n     */\n    var calculateDirection = function (diffX, diffY) {\n        if (diffX === 0, diffY === -1) return EasyStar.BOTTOM\n        else if (diffX === 1, diffY === -1) return EasyStar.BOTTOM_LEFT\n        else if (diffX === 1, diffY === 0) return EasyStar.LEFT\n        else if (diffX === 1, diffY === 1) return EasyStar.TOP_LEFT\n        else if (diffX === 0, diffY === 1) return EasyStar.TOP\n        else if (diffX === -1, diffY === 1) return EasyStar.TOP_RIGHT\n        else if (diffX === -1, diffY === 0) return EasyStar.RIGHT\n        else if (diffX === -1, diffY === -1) return EasyStar.BOTTOM_RIGHT\n        throw new Error('These differences are not valid: ' + diffX + ', ' + diffY)\n    };\n\n    var getTileCost = function(x, y) {\n        return pointsToCost[x + '_' + y] || costMap[collisionGrid[y][x]]\n    };\n\n    var coordinateToNode = function(instance, x, y, parent, cost) {\n        if (instance.nodeHash[x + \"_\" + y]!==undefined) {\n            return instance.nodeHash[x + \"_\" + y];\n        }\n        var simpleDistanceToTarget = getDistance(x, y, instance.endX, instance.endY);\n        if (parent!==null) {\n            var costSoFar = parent.costSoFar + cost;\n        } else {\n            costSoFar = 0;\n        }\n        var node = new Node(parent,x,y,costSoFar,simpleDistanceToTarget);\n        instance.nodeHash[x + \"_\" + y] = node;\n        return node;\n    };\n\n    var getDistance = function(x1,y1,x2,y2) {\n        if (diagonalsEnabled) {\n            // Octile distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            if (dx < dy) {\n                return DIAGONAL_COST * dx + dy;\n            } else {\n                return DIAGONAL_COST * dy + dx;\n            }\n        } else {\n            // Manhattan distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            return (dx + dy);\n        }\n    };\n}\n\nEasyStar.TOP = 'TOP'\nEasyStar.TOP_RIGHT = 'TOP_RIGHT'\nEasyStar.RIGHT = 'RIGHT'\nEasyStar.BOTTOM_RIGHT = 'BOTTOM_RIGHT'\nEasyStar.BOTTOM = 'BOTTOM'\nEasyStar.BOTTOM_LEFT = 'BOTTOM_LEFT'\nEasyStar.LEFT = 'LEFT'\nEasyStar.TOP_LEFT = 'TOP_LEFT'\n",
    "/**\n * Represents a single instance of EasyStar.\n * A path that is in the queue to eventually be found.\n */\nmodule.exports = function() {\n    this.isDoneCalculating = true;\n    this.pointsToAvoid = {};\n    this.startX;\n    this.callback;\n    this.startY;\n    this.endX;\n    this.endY;\n    this.nodeHash = {};\n    this.openList;\n};",
    "/**\n* A simple Node that represents a single tile on the grid.\n* @param {Object} parent The parent node.\n* @param {Number} x The x position on the grid.\n* @param {Number} y The y position on the grid.\n* @param {Number} costSoFar How far this node is in moves*cost from the start.\n* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.\n**/\nmodule.exports = function(parent, x, y, costSoFar, simpleDistanceToTarget) {\n    this.parent = parent;\n    this.x = x;\n    this.y = y;\n    this.costSoFar = costSoFar;\n    this.simpleDistanceToTarget = simpleDistanceToTarget;\n\n    /**\n    * @return {Number} Best guess distance of a cost using this node.\n    **/\n    this.bestGuessDistance = function() {\n        return this.costSoFar + this.simpleDistanceToTarget;\n    }\n};",
    "module.exports = require('./lib/heap');\n",
    "// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n",
    "import Boot from './states/Boot';\nimport Preload from './states/Preload';\nimport Menu from './states/Menu';\nimport Level1 from './levels/Level1';\nimport Level2 from './levels/Level2';\n\nclass ProjectNostradamus extends Phaser.Game {\n  constructor( width, height, renderer, parent ) {\n    super( width, height, renderer, parent );\n    this.state.add( 'Preload', Preload );\n    this.state.add( 'Boot', Boot );\n    this.state.add( 'Preload', Preload );\n    this.state.add( 'Menu', Menu );\n\n    this.state.add( 'Level1', Level1 );\n    this.state.add( 'Level2', Level2 );\n\n    this.state.start( 'Boot' );\n  }\n}\nexport default ProjectNostradamus;\n",
    "import { END_SCREEN_FADE_IN_DURATION } from '../constants/UserInterfaceConstants';\n\nimport { getScreenCenter, showBackgroundLayer } from '../utils/UserInterfaceUtils';\n\nexport default class GameOverUI {\n  constructor( game, mainMenuCallback, restartCallback ) {\n    this.game = game;\n    this.mainMenuCallback = mainMenuCallback;\n    this.restartCallback = restartCallback;\n  }\n  start() {\n    const screenCenter = getScreenCenter( this.game );\n\n    this.backgroundLayer = showBackgroundLayer( this.game );\n    this.backgroundLayer.alpha = 0;\n    this.game.add.tween( this.backgroundLayer ).to( { alpha: 0.5 }, END_SCREEN_FADE_IN_DURATION, 'Linear', true );\n\n    const textStyle = {\n      align: 'center',\n      fill: 'white',\n      font: 'bold 80px Arial',\n    };\n\n    const mainText = this.game.add.text( screenCenter.x, screenCenter.y, 'YOU DIED!', textStyle );\n    mainText.anchor.setTo( 0.5 );\n    mainText.alpha = 0;\n    const fadingInTween = this.game.add.tween( mainText ).to( { alpha: 1 }, END_SCREEN_FADE_IN_DURATION, 'Linear', true );\n    fadingInTween.onComplete.add( () => this.showEndScreenButtons() );\n  }\n  showEndScreenButtons() {\n    const mainMenuButton = this.game.add.button( this.game.camera.x + 100, this.game.camera.y + this.game.camera.height - 100, 'main-menu-btn' );\n    mainMenuButton.anchor.setTo( 0, 1 );\n    mainMenuButton.onInputUp.add( () => this.mainMenuCallback() );\n\n    const restartLevelButton = this.game.add.button( this.game.camera.x + this.game.camera.width - 100, this.game.camera.y + this.game.camera.height - 100, 'restart-btn' );\n    restartLevelButton.anchor.setTo( 1, 1 );\n    restartLevelButton.onInputUp.add( () => this.restartCallback() );\n  }\n}\n",
    "export const COMPUTER_WIDTH = 32;\nexport const COMPUTER_HEIGHT = 39;\nexport const JOURNAL_TEXT_FIELD_WIDTH = 544;\nexport const JOURNAL_TEXT_FIELD_HEIGHT = 350;\nexport const JOURNAL_TEXT_SCROLL_STEP = 32;\nexport const JOURNAL_TEXT_FONT_SIZE = 16;\nexport const JOURNAL_SCROLL_BAR_WIDTH = 8;\nexport const MAGIC_OFFSET_FIXING_VALUE = 7;\n",
    "export const PLAYER_WIDTH = 29;\nexport const PLAYER_HEIGHT = 31;\nexport const PLAYER_INITIAL_FRAME = 1;\nexport const PLAYER_SPEED = 120;\nexport const PLAYER_SNEAK_MULTIPLIER = 0.75;\nexport const PLAYER_SPRINT_MULTIPLIER = 1.5;\nexport const PLAYER_WALK_ANIMATION_FRAMERATE = 7;\nexport const PLAYER_FIGHT_ANIMATION_FRAMERATE = 10;\nexport const PLAYER_HAND_ATTACK_RANGE = 60;\nexport const PLAYER_HAND_ATTACK_ANGLE = 60;\nexport const PLAYER_HAND_ATTACK_DAMAGE = 0.2;\nexport const PLAYER_DAMAGE_COOLDOWN = 0.1;\n",
    "export const TILE_WIDTH = 64;\nexport const TILE_HEIGHT = 64;\nexport const MAP_WIDTH = 32;\nexport const MAP_HEIGHT = 32;\n",
    "export const END_SCREEN_FADE_IN_DURATION = 2500;\n",
    "export const ZOMBIE_WIDTH = 40;\nexport const ZOMBIE_HEIGHT = 31;\nexport const ZOMBIE_INITIAL_FRAME = 1;\nexport const ZOMBIE_SPEED = 50;\nexport const ZOMBIE_SPEED_CHASING_MULTIPLIER = 2;\nexport const ZOMBIE_LOOKING_OFFSET = 10;\nexport const ZOMBIE_WALK_ANIMATION_FRAMERATE = 6;\nexport const ZOMBIE_FIGHT_ANIMATION_FRAMERATE = 10;\nexport const MIN_DISTANCE_TO_TARGET = 10;\nexport const ZOMBIE_SIGHT_ANGLE = 45;\nexport const ZOMBIE_SIGHT_RANGE = 400;\nexport const ZOMBIE_HEARING_RANGE = 100;\nexport const ZOMBIE_ATTACK_RANGE = 50;\nexport const ZOMBIE_ROTATING_SPEED = 50;\nexport const ZOMBIE_DAMAGE_MULTIPLIER = 1;\nexport const ZOMBIE_DAMAGE_COOLDOWN = 0.2;\nexport const ZOMBIE_DAMAGE_VALUE = 0.1;\nexport const ZOMBIE_NOTIFY_RANGE = 500;\n",
    "import ProjectNostradamus from './ProjectNostradamus';\n\nnew ProjectNostradamus( '100%', '100%', Phaser.AUTO, 'content' );\n\n/*\n!!! This is protection against leaving page while still in game. It is commented out since it was driving me crazy that i had to confirm leavinmg every time browsersync fired. !!!\nwindow.onbeforeunload = (e) => {\n  return 'Really want to quit the game?';\n};\n\ndocument.onkeydown = ( e ) => {\n  e = e || window.event;\n  if ( e.ctrlKey ) {\n    const c = e.which || e.keyCode;\n    switch ( c ) {\n    case 83:\n    case 87:\n      e.preventDefault();\n      e.stopPropagation();\n      break;\n    }\n  }\n};\n*/\n",
    "import Game from '../states/Game.js';\n\nexport default class Level1 extends Game {\n  preload() {\n    Game.prototype.preload.call( this );\n\n    this.load.tilemap( 'map', 'assets/levels/level1/map.json', null, Phaser.Tilemap.TILED_JSON );\n    this.load.json( 'journals', 'assets/levels/level1/journals.json' );\n  }\n  create() {\n    Game.prototype.create.call( this );\n    console.log( 'level1 loaded' );\n  }\n}\n",
    "import Game from '../states/Game.js';\n\nexport default class Level2 extends Game {\n  preload() {\n    Game.prototype.preload.call( this );\n\n    this.load.tilemap( 'map', 'assets/levels/level2/map2.json', null, Phaser.Tilemap.TILED_JSON );\n    this.load.json( 'journals', 'assets/levels/level1/journals.json' );\n  }\n  create() {\n    Game.prototype.create.call( this );\n    console.log( 'level2 loaded' );\n  }\n}\n",
    "import { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { pixelsToTile, tileToPixels } from '../utils/MapUtils.js';\n\nexport default class ZombiesBoidsManager extends Phaser.Group {\n  constructor( game, mapGrid, boidsDistance = Math.max( TILE_WIDTH, TILE_HEIGHT ), distanceBetweenBoidsAndWalls = boidsDistance ) {\n    super( game );\n    this.entities = this.children;\n    this.mapGrid = mapGrid;\n    this.boidsDistance = boidsDistance;\n    this.distanceBetweenBoidsAndWalls = distanceBetweenBoidsAndWalls;\n    this.game = game;\n  }\n  update() {\n    Phaser.Group.prototype.update.call( this );\n\n    for ( const boid of this.entities ) {\n      if ( boid.isChasing() === false ) {\n        continue;\n      }\n      const velocity1 = this.flyTowardsMassCenterRule( boid );\n      const velocity2 = this.keepSmallDistanceFromObstaclesRule( boid );\n      const velocity3 = this.tryMatchingOtherEnitiesVelocityRule( boid );\n\n      boid.body.velocity.x += velocity1.x + velocity2.x + velocity3.x;\n      boid.body.velocity.y += velocity1.y + velocity2.y + velocity3.y;\n    }\n  }\n  flyTowardsMassCenterRule( boid ) {\n    const velocity = { x: 0, y: 0 };\n\n    for ( const entity of this.entities ) {\n      if ( entity === boid ) {\n        continue;\n      }\n      velocity.x += entity.body.x;\n      velocity.y += entity.body.y;\n    }\n\n    velocity.x = ( velocity.x / ( this.entities.length - 1 ) ) / 100;\n    velocity.y = ( velocity.y / ( this.entities.length - 1 ) ) / 100;\n\n    return velocity;\n  }\n  keepSmallDistanceFromObstaclesRule( boid ) {\n    const velocity = { x: 0, y: 0 };\n\n    for ( const otherBoid of this.entities ) {\n      if ( otherBoid === boid ) {\n        continue;\n      }\n      if ( this.game.physics.arcade.distanceBetween( otherBoid, boid ) <= this.boidsDistance ) {\n        velocity.x -= otherBoid.body.x - boid.body.x;\n        velocity.y -= otherBoid.body.y - boid.body.y;\n      }\n    }\n\n    const wallBodies = this.getAdjoiningWallBodies( boid );\n    for ( const wallBody of wallBodies ) {\n      if ( this.game.physics.arcade.distanceBetween( wallBody, boid ) <= this.distanceBetweenBoidsAndWalls ) {\n        velocity.x -= wallBody.x - boid.body.x;\n        velocity.y -= wallBody.y - boid.body.y;\n      }\n    }\n\n    return velocity;\n  }\n  getAdjoiningWallBodies( entity ) {\n    const entityTile = pixelsToTile( entity );\n    const adjoiningTiles = [\n      { x: entityTile.x - 1, y: entityTile.y - 1 },\n      { x: entityTile.x - 1, y: entityTile.y },\n      { x: entityTile.x - 1, y: entityTile.y + 1 },\n      { x: entityTile.x, y: entityTile.y - 1 },\n      { x: entityTile.x, y: entityTile.y + 1 },\n      { x: entityTile.x + 1, y: entityTile.y - 1 },\n      { x: entityTile.x + 1, y: entityTile.y },\n      { x: entityTile.x + 1, y: entityTile.y + 1 },\n    ];\n\n    const adjoiningWallTiles = adjoiningTiles.filter( ( tile ) => this.mapGrid[ tile.y ][ tile.x ] === 1 );\n    return adjoiningWallTiles.map( tileToPixels );\n  }\n  tryMatchingOtherEnitiesVelocityRule() {\n    return { x: 0, y: 0 };\n  }\n}\n",
    "class Entity extends Phaser.Sprite {\n  constructor( game, x, y, imageKey, frame ) {\n    super( game, x, y, imageKey, frame );\n\n    this.anchor.setTo( 0.5, 0.5 );\n\n    this.game.physics.p2.enable( this );\n    this.body.collideWorldBounds = true;\n\n    this.game.world.add( this );\n  }\n  lookAt( targetX, targetY ) {\n    const targetPoint = new Phaser.Point( targetX, targetY );\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\n\n    let targetAngle = Phaser.Math.radToDeg( Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) ) - 90;\n\n    if ( targetAngle < 0 ) {\n      targetAngle += 360;\n    }\n\n    this.body.angle = targetAngle;\n  }\n  normalizeVelocity() {\n    if ( this.body.velocity.x !== 0 && this.body.velocity.y !== 0 ) {\n      this.body.velocity.x = this.body.velocity.x * Math.sqrt( 2 ) * 1 / 2;\n      this.body.velocity.y = this.body.velocity.y * Math.sqrt( 2 ) * 1 / 2;\n    }\n  }\n  resetVelocity() {\n    this.body.velocity.x = 0;\n    this.body.velocity.y = 0;\n  }\n  isMoving() {\n    return this.body.velocity.x !== 0 || this.body.velocity.y !== 0;\n  }\n  isInDegreeRange( entity, target, sightAngle ) {\n    const angleDelta = Math.abs( Phaser.Math.radToDeg( Phaser.Math.angleBetween( entity.x, entity.y, target.x, target.y ) ) + 90 - entity.angle );\n\n    return angleDelta <= sightAngle || angleDelta >= ( 360 - sightAngle );\n  }\n  takeDamage( damage ) {\n    this.damage( damage );\n    this.health = Math.floor( this.health * 100 ) / 100;\n  }\n}\n\nexport default Entity;\n",
    "import { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { COMPUTER_WIDTH, COMPUTER_HEIGHT } from '../constants/ItemConstants';\n\nexport default class Journal extends Phaser.Sprite {\n  constructor( game, content, imageKey ) {\n\n    super( game, 0, 0, imageKey );\n\n    this.game.world.add( this );\n\n    this.hasPlayerApproached = false;\n\n    this.content = content;\n  }\n  setCorner( cornerX, cornerY ) {\n    this.cornerX = cornerX;\n    this.cornerY = cornerY;\n  }\n  setPosition( tileX, tileY ) {\n    const cornerX = this.cornerX || 'WEST';\n    const cornerY = this.cornerY || 'NORTH';\n\n    const offsetX = ( cornerX === 'WEST' ) ? ( COMPUTER_WIDTH / 2 ) : TILE_WIDTH - ( COMPUTER_WIDTH / 2 );\n    const offsetY = ( cornerY === 'NORTH' ) ? ( COMPUTER_HEIGHT / 2 ) : TILE_HEIGHT - ( COMPUTER_HEIGHT / 2 );\n\n    const x = tileX + offsetX;\n    const y = tileY + offsetY;\n\n    this.x = x;\n    this.y = y;\n  }\n  enableJournal() {\n    const cornerX = this.cornerX || 'WEST';\n    const cornerY = this.cornerY || 'NORTH';\n\n    this.game.physics.p2.enable( this );\n    this.body.static = true;\n\n    let sensorOffsetX = ( TILE_WIDTH - COMPUTER_WIDTH ) / ( ( cornerX === 'WEST' ) ? 2 : -2 );\n    let sensorOffsetY = ( TILE_HEIGHT - COMPUTER_HEIGHT ) / ( ( cornerY === 'NORTH' ) ? 2 : -2 );\n\n    if ( cornerY === 'SOUTH' ) {\n      this.body.angle = 180;\n      sensorOffsetX += ( TILE_WIDTH - COMPUTER_WIDTH ) * ( ( sensorOffsetX < 0 ) ? 1 : -1 );\n      sensorOffsetY += ( TILE_HEIGHT - COMPUTER_HEIGHT ) * ( ( sensorOffsetY < 0 ) ? 1 : -1 );\n    }\n\n    const rectangleSensor = this.body.addRectangle( TILE_WIDTH, TILE_HEIGHT, sensorOffsetX, sensorOffsetY );\n    rectangleSensor.sensor = true;\n\n    this.anchor.setTo( 0.5 );\n  }\n}\n",
    "import { JOURNAL_TEXT_FIELD_WIDTH, JOURNAL_TEXT_FIELD_HEIGHT, JOURNAL_TEXT_SCROLL_STEP, JOURNAL_TEXT_FONT_SIZE, JOURNAL_SCROLL_BAR_WIDTH, MAGIC_OFFSET_FIXING_VALUE } from '../constants/ItemConstants';\nimport { showBackgroundLayer, getScreenCenter } from '../utils/UserInterfaceUtils';\n\nexport default class JournalsManager extends Phaser.Group {\n  constructor( game, player ) {\n    super( game );\n\n    const style = { font: '24px Arial', fill: '#fff' };\n\n    this.messageText = this.game.add.text( 0, 0, '', style );\n    this.messageText.x = 24;\n    this.messageText.y = this.game.height - 24 - 32;\n    this.messageText.fixedToCamera = true;\n\n    this.player = player;\n\n    this.activateKey = this.game.input.keyboard.addKey( Phaser.Keyboard.E );\n    this.activateKey.onDown.add( this.tryToShowJournal, this );\n    this.game.input.keyboard.removeKeyCapture( Phaser.Keyboard.E );\n\n    this.activateKey = this.game.input.keyboard.addKey( Phaser.Keyboard.ESC );\n    this.activateKey.onDown.add( this.tryToHideJournal, this );\n    this.game.input.keyboard.removeKeyCapture( Phaser.Keyboard.ESC );\n\n    this.isJournalOpened = false;\n  }\n  tryToShowJournal() {\n    if ( this.isJournalOpened ) {\n      return;\n    }\n    const approachedJournals = this.children.filter( journal => journal.hasPlayerApproached );\n    if ( approachedJournals.length > 0 ) {\n      this.isJournalOpened = true;\n      this.game.paused = true;\n      this.messageText.setText( 'Press \\'ESC\\' to close personal journal.' );\n\n      const nearestJournal = this.getJournalNearestToPlayer( approachedJournals );\n      this.showJournal( nearestJournal );\n    }\n  }\n  getJournalNearestToPlayer( journals ) {\n    let nearestJournal = journals[ 0 ];\n\n    journals.forEach( ( journal ) => {\n      if ( Phaser.Math.distance( this.player.x, this.player.y, journal.x, journal.y )\n      < Phaser.Math.distance( this.player.x, this.player.y, nearestJournal.x, nearestJournal.y ) ) {\n        nearestJournal = journal;\n      }\n    } );\n\n    return nearestJournal;\n  }\n  showJournal( journalToShow ) {\n    const screenCenter = getScreenCenter( this.game );\n\n    this.backgroundLayer = showBackgroundLayer( this.game );\n\n    this.ui = this.game.add.sprite( screenCenter.x, screenCenter.y + MAGIC_OFFSET_FIXING_VALUE, 'journal-ui' );\n    this.ui.anchor.setTo( 0.5 );\n\n    const textStyle = {\n      align: 'left',\n      fill: '#10aede',\n      font: `bold ${JOURNAL_TEXT_FONT_SIZE}px Arial`,\n      padding: '0',\n      margin: '0',\n    };\n\n    this.uiText = this.game.add.text( screenCenter.x - JOURNAL_TEXT_FIELD_WIDTH / 2, screenCenter.y - JOURNAL_TEXT_FIELD_HEIGHT / 2, journalToShow.content, textStyle );\n    this.uiText.wordWrap = true;\n    this.uiText.wordWrapWidth = JOURNAL_TEXT_FIELD_WIDTH;\n\n    this.maskGraphics = this.game.add.graphics( 0, 0 );\n    this.maskGraphics.beginFill( 0xffffff );\n    this.maskGraphics.drawRect( screenCenter.x - JOURNAL_TEXT_FIELD_WIDTH / 2, this.uiText.y, JOURNAL_TEXT_FIELD_WIDTH, JOURNAL_TEXT_FIELD_HEIGHT );\n\n    this.uiText.mask = this.maskGraphics;\n\n    this.scrollBar = this.game.add.graphics( screenCenter.x + JOURNAL_TEXT_FIELD_WIDTH / 2, this.uiText.y );\n    this.scrollBar.alpha = 0.5;\n    this.scrollBarHeight = ( this.uiText.height > JOURNAL_TEXT_FIELD_HEIGHT ) ? Math.pow( JOURNAL_TEXT_FIELD_HEIGHT, 2 ) / this.uiText.height : JOURNAL_TEXT_FIELD_HEIGHT;\n    this.scrollBarOffset = 0;\n    this.scrollBarStep = ( JOURNAL_TEXT_SCROLL_STEP / this.uiText.height ) * JOURNAL_TEXT_FIELD_HEIGHT;\n\n    this.drawScrollBar();\n  }\n  tryToHideJournal() {\n    if ( this.isJournalOpened && this.game.paused ) {\n      this.isJournalOpened = false;\n      this.game.paused = false;\n      this.messageText.setText( 'Press \\'E\\' to open personal journal.' );\n      this.backgroundLayer.destroy();\n      this.ui.destroy();\n      this.uiText.destroy();\n      this.maskGraphics.destroy();\n      this.scrollBar.destroy();\n    }\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.messageText.setText( 'Press \\'E\\' to open personal journal.' );\n      bodyA.sprite.hasPlayerApproached = true;\n    }\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.messageText.setText( '' );\n      bodyA.sprite.hasPlayerApproached = false;\n    }\n  }\n  isItSensorArea( body, shape ) {\n    if ( body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n    // for now this line assume that there is only one type of computer's textures\n    // TODO enable different sprite key's handling\n    return body.sprite.key === 'computer' && shape.sensor;\n  }\n  onMouseWheel( ) {\n    if ( this.isJournalOpened === false ) {\n      return;\n    }\n    const directionY = this.game.input.mouse.wheelDelta;\n\n    if ( directionY === 1 && this.uiText.y < this.game.camera.y + this.game.camera.height / 2 - JOURNAL_TEXT_FIELD_HEIGHT / 2 ) {\n      this.uiText.y += JOURNAL_TEXT_SCROLL_STEP;\n      this.drawScrollBar( -this.scrollBarStep );\n    } else if ( directionY === -1 && this.uiText.y > this.game.camera.y + this.game.camera.height / 2 + JOURNAL_TEXT_FIELD_HEIGHT / 2 - this.uiText.height ) {\n      this.uiText.y -= JOURNAL_TEXT_SCROLL_STEP;\n      this.drawScrollBar( this.scrollBarStep );\n    }\n  }\n  drawScrollBar( y = 0 ) {\n    this.scrollBarOffset += y;\n    this.scrollBar.clear();\n    this.scrollBar.beginFill( 0xffffff );\n    this.scrollBar.drawRect( 0, this.scrollBarOffset, JOURNAL_SCROLL_BAR_WIDTH, this.scrollBarHeight );\n    this.scrollBar.endFill();\n  }\n  clearUI() {\n    this.tryToHideJournal();\n    this.messageText.destroy();\n  }\n}\n",
    "import Entity from './Entity';\nimport { PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_SPEED, PLAYER_SNEAK_MULTIPLIER, PLAYER_SPRINT_MULTIPLIER, PLAYER_WALK_ANIMATION_FRAMERATE, PLAYER_FIGHT_ANIMATION_FRAMERATE, PLAYER_HAND_ATTACK_RANGE, PLAYER_HAND_ATTACK_ANGLE, PLAYER_HAND_ATTACK_DAMAGE, PLAYER_DAMAGE_COOLDOWN } from '../constants/PlayerConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\n\nexport default class Player extends Entity {\n  constructor( game, x, y, imageKey, frame, zombies ) {\n    super( game, x + TILE_WIDTH / 2, y + TILE_HEIGHT / 2, imageKey, frame );\n\n    this.width = PLAYER_WIDTH;\n    this.height = PLAYER_HEIGHT;\n\n    this.zombies = zombies.children;\n\n    this.godMode = false;\n\n    this.isSneaking = false;\n    this.isSprinting = false;\n\n    this.attackRange = PLAYER_HAND_ATTACK_RANGE;\n    this.dealingDamage = PLAYER_HAND_ATTACK_DAMAGE;\n\n    this.canDealDamage = true;\n\n    this.healthbar = this.game.add.graphics( 0, 0 );\n    this.healthbar.anchor.x = 1;\n    this.healthbar.anchor.y = 1;\n    this.healthbar.fixedToCamera = true;\n\n    this.zombiesInAttackRange = [];\n\n    this.attackSensor = this.body.addCircle( PLAYER_HAND_ATTACK_RANGE );\n    this.attackSensor.sensor = true;\n    this.attackSensor.sensorType = 'attack';\n\n    this.cursors = {\n      up: this.game.input.keyboard.addKey( Phaser.Keyboard.W ),\n      down: this.game.input.keyboard.addKey( Phaser.Keyboard.S ),\n      left: this.game.input.keyboard.addKey( Phaser.Keyboard.A ),\n      right: this.game.input.keyboard.addKey( Phaser.Keyboard.D ),\n      sneakToggle: this.game.input.keyboard.addKey( Phaser.Keyboard.CAPS_LOCK ),\n      sneak: this.game.input.keyboard.addKey( Phaser.Keyboard.ALT ),\n      sprint: this.game.input.keyboard.addKey( Phaser.Keyboard.SHIFT ),\n    };\n\n    this.isSneakPressed = false;\n\n    const style = { font: '16px Arial', fill: '#fff' };\n\n\n    this.sneakText = this.game.add.text( 0, 0, 'Sneaking: off', style );\n    this.sneakText.x = this.game.width - ( this.sneakText.width + 24 );\n    this.sneakText.y = this.game.height - ( this.sneakText.height + 24 + 32 );\n    this.sneakText.fixedToCamera = true;\n    this.sneakText.stroke = '#000';\n    this.sneakText.strokeThickness = 3;\n\n    this.sprintText = this.game.add.text( 0, 0, 'Sprinting: off', style );\n    this.sprintText.x = this.game.width - ( this.sprintText.width + 24 );\n    this.sprintText.y = this.game.height - ( this.sprintText.height + 24 + 32 + this.sneakText.height );\n    this.sprintText.fixedToCamera = true;\n    this.sprintText.stroke = '#000';\n    this.sprintText.strokeThickness = 3;\n\n    this.animations.add( 'walk', [ 0, 1, 2, 3, 4, 5 ] );\n    this.animations.add( 'fight', [ 6, 7, 8, 9, 0 ] );\n\n    this.body.clearShapes();\n    this.body.addCircle( Math.min( PLAYER_WIDTH, PLAYER_HEIGHT ) );\n\n    this.drawHealthBar();\n\n    this.onDeath = new Phaser.Signal();\n\n    this.body.onBeginContact.add( this.onCollisionEnter, this );\n    this.body.onEndContact.add( this.onCollisionLeave, this );\n  }\n\n  update() {\n    this.handleMovement();\n    this.handleAnimation();\n    this.lookAtMouse();\n    this.handleAttack();\n  }\n\n  handleMovement() {\n    this.resetVelocity();\n\n    if ( this.cursors.up.isDown ) {\n      this.body.velocity.y = -PLAYER_SPEED;\n    } else if ( this.cursors.down.isDown ) {\n      this.body.velocity.y = PLAYER_SPEED;\n    }\n\n    if ( this.cursors.left.isDown ) {\n      this.body.velocity.x = -PLAYER_SPEED;\n    } else if ( this.cursors.right.isDown ) {\n      this.body.velocity.x = PLAYER_SPEED;\n    }\n\n    this.handleMovementSpecialModes();\n\n    this.normalizeVelocity();\n  }\n\n  handleMovementSpecialModes() {\n    let specialEffectMultiplier = 1;\n\n    this.isSprinting = false;\n    this.isSneaking = false;\n\n    if ( this.cursors.sprint.isDown ) {\n      this.isSprinting = true;\n      this.isSneaking = false;\n      specialEffectMultiplier = PLAYER_SPRINT_MULTIPLIER;\n    }\n\n    if ( this.cursors.sneak.isDown || this.cursors.sneakToggle.isDown ) {\n      specialEffectMultiplier = PLAYER_SNEAK_MULTIPLIER;\n      this.isSneaking = true;\n    }\n\n    this.sneakText.setText( 'Sneaking: ' + ( ( this.isSneaking ) ? 'on' : 'off' ) );\n    this.sprintText.setText( 'Sprinting: ' + ( ( this.isSprinting ) ? 'on' : 'off' ) );\n\n    this.body.velocity.x *= specialEffectMultiplier;\n    this.body.velocity.y *= specialEffectMultiplier;\n  }\n\n  onCollisionEnter( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      if ( shapeB.sensorType === 'attack' && bodyA.sprite.key === 'zombie' ) {\n        this.zombiesInAttackRange.push( bodyA.sprite );\n      }\n    }\n  }\n\n  onCollisionLeave( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      if ( shapeB.sensorType === 'attack' && bodyA.sprite.key === 'zombie' ) {\n        this.zombiesInAttackRange = this.zombiesInAttackRange.filter( ( v ) => {\n          return ( v !== bodyA.sprite );\n        } );\n      }\n    }\n  }\n\n  isItSensorArea( body, shape ) {\n    if ( body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n\n    return shape.sensor;\n  }\n\n  handleAnimation() {\n    if ( this.game.input.activePointer.leftButton.isDown ) {\n      this.animations.play( 'fight', PLAYER_FIGHT_ANIMATION_FRAMERATE, false );\n    }\n    if ( ( this.body.velocity.x !== 0 || this.body.velocity.y !== 0 ) && !this.animations.getAnimation( 'fight' ).isPlaying ) {\n      this.animations.play( 'walk', PLAYER_WALK_ANIMATION_FRAMERATE, true );\n    } else {\n      this.animations.stop( 'walk', true );\n    }\n  }\n\n  endCooldown() {\n    this.canDealDamage = true;\n    // this.animations.play( 'walk', ZOMBIE_WALK_ANIMATION_FRAMERATE, true );\n  }\n\n  lookAtMouse() {\n    const mouseX = this.game.input.mousePointer.worldX;\n    const mouseY = this.game.input.mousePointer.worldY;\n\n    this.lookAt( mouseX, mouseY );\n  }\n\n  handleAttack() {\n    let didDealDamage = false;\n    if ( this.game.input.activePointer.leftButton.isDown && this.canDealDamage ) {\n      this.zombiesInAttackRange.forEach( ( v ) => {\n        if ( v.alive ) {\n          if ( this.isInDegreeRange( this, v, PLAYER_HAND_ATTACK_ANGLE ) ) {\n            v.takeDamage( this.dealingDamage );\n            didDealDamage = true;\n          }\n        }\n      } );\n\n      if ( didDealDamage ) {\n        this.canDealDamage = false;\n        this.game.time.events.add( Phaser.Timer.SECOND * PLAYER_DAMAGE_COOLDOWN, this.endCooldown, this );\n      }\n    }\n  }\n\n  takeDamage( damage ) {\n    if ( !this.godMode ) {\n      Entity.prototype.takeDamage.call( this, [ damage ] );\n    }\n    this.drawHealthBar();\n\n    if ( this.health <= 0 ) {\n      this.handleDeath();\n    }\n  }\n\n  handleDeath() {\n    this.onDeath.dispatch();\n    this.healthbar.destroy();\n    this.sneakText.destroy();\n    this.sprintText.destroy();\n  }\n\n  drawHealthBar() {\n    const width = 300;\n    const height = 32;\n\n    this.healthbar.clear();\n    if ( this.godMode ) {\n      this.healthbar.beginFill( 0xFFD700, 0.85 );\n    } else {\n      this.healthbar.beginFill( 0xFF0000, 0.85 );\n    }\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width * Math.max( this.health, 0 ), height );\n    this.healthbar.endFill();\n    if ( this.godMode ) {\n      this.healthbar.lineStyle( 2, 0xCEAD00, 1 );\n    } else {\n      this.healthbar.lineStyle( 2, 0x880000, 1 );\n    }\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width, height );\n    this.healthbar.lineStyle( 0 );\n  }\n}\n",
    "import { pixelsToTile } from '../utils/MapUtils.js';\n\nexport default class TileMap extends Phaser.Tilemap {\n  constructor( game, key, tileWidth, tileHeight ) {\n    super( game, key, tileWidth, tileHeight );\n\n    this.addTilesetImage( 'tilemap_floor' );\n    this.addTilesetImage( 'tilemap_walls' );\n\n    this.ground = this.createLayer( 'background' );\n    this.walls = this.createLayer( 'walls' );\n\n    this.paths = [];\n    this.journals = [];\n\n    this.setCollisionByExclusion( [], true, this.walls );\n\n    this.ground.resizeWorld();\n\n    this.wallsBodiesArray = game.physics.p2.convertTilemap( this, this.walls );\n\n    this.wallsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n\n    for ( const body of this.wallsBodiesArray ) {\n      body.setCollisionGroup( this.wallsCollisionGroup );\n    }\n\n    this.createPathPoints();\n  }\n  collides( collisionGroup, callback ) {\n    for ( const body of this.wallsBodiesArray ) {\n      body.collides( collisionGroup, callback );\n    }\n  }\n  createPathPoints() {\n    this.objects[ 'ZombiePaths' ].forEach( ( v ) => {\n      const props = v.properties;\n      if ( !this.paths[ props.PathId ] ) {\n        this.paths[ props.PathId ] = [];\n      }\n\n      this.paths[ props.PathId ][ props.PathIndex ] = pixelsToTile( { x: v.x, y: v.y } );\n    } );\n\n    this.normalizePaths();\n  }\n  getJournals() {\n    const allJournals = this.objects[ 'Journals' ];\n    const journals = [];\n    allJournals.forEach( ( v ) => {\n      const props = v.properties;\n      journals.push(\n        {\n          x: v.x,\n          y: v.y,\n          cornerX: props.cornerX,\n          cornerY: props.cornerY,\n          name: v.name,\n          content: props.content,\n        }\n      );\n    } );\n\n    return journals;\n  }\n  getPlayerInitialPosition() {\n    const player = this.objects[ 'PlayerPos' ][ 0 ];\n    const posObj = {\n      x: player.x,\n      y: player.y,\n    };\n    return posObj;\n  }\n  normalizePaths() {\n    this.paths.forEach( ( pathArr ) => {\n      const tempArr = [];\n      pathArr.forEach( ( v ) => {\n        tempArr.push( v );\n      } );\n\n      pathArr = tempArr;\n    } );\n  }\n  getPath( i ) {\n    return this.paths[ i ];\n  }\n}\n",
    "import Entity from './Entity';\nimport ZombiePathManager from './ZombieComponents/ZombiePathManager';\nimport ZombieRotationManager from './ZombieComponents/ZombieRotationManager';\nimport SeekingPlayerManager from './ZombieComponents/SeekingPlayerManager';\nimport ChasingPlayerManager from './ZombieComponents/ChasingPlayerManager';\nimport { tileToPixels } from '../utils/MapUtils';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { ZOMBIE_WALK_ANIMATION_FRAMERATE } from '../constants/ZombieConstants';\n\n/* eslint-disable no-inline-comments */\n\nconst STATES = {\n  NOT_READY: 0, // zombie is created but no system is initialized\n  NOT_WALKING: 1, // walking on path manager is initialized but paths are not calculated yet\n  WALKING_ON_PATH: 2, // zombie is walking on precalculated paths\n  CHASING_PLAYER: 3, // zombie is chasing player\n};\n\nexport default class Zombie extends Entity {\n  constructor( game, key, x = 0, y = 0 ) {\n    super( game, x, y, key );\n\n    this.initCollider();\n    this.initAnimations();\n\n    this.isPathSystemInitialized = false;\n    this.walkingOnPathManager = null;\n    this.rotationManager = new ZombieRotationManager( this );\n    this.chasingPlayerManager = null;\n\n    this.state = STATES.NOT_READY;\n\n    this.body.onBeginContact.add( this.onCollisionEnter, this );\n    this.body.onEndContact.add( this.onCollisionLeave, this );\n  }\n  initCollider() {\n    this.body.clearShapes();\n\n    this.body.addCircle( Math.max( TILE_WIDTH, TILE_HEIGHT ) * 0.25 );\n  }\n  initAnimations() {\n    this.animations.add( 'walk', [ 0, 1, 2, 3, 4, 5 ], 0 );\n    this.animations.add( 'attack', [ 6, 7, 8, 9 ], 6 );\n    this.animations.play( 'walk', ZOMBIE_WALK_ANIMATION_FRAMERATE, true );\n  }\n  setTilePosition( tile ) {\n    const pixelPosition = tileToPixels( tile );\n    Object.assign( this.body, pixelPosition );\n  }\n  initializePathSystem( targets, walls ) {\n    this.walkingOnPathManager = new ZombiePathManager( this, targets, walls );\n\n    this.state = STATES.NOT_WALKING;\n  }\n  startPathSystem() {\n    this.walkingOnPathManager.start( () => this.state = STATES.WALKING_ON_PATH );\n  }\n  initializeChasingSystem( player, walls ) {\n    this.seekingPlayerManager = new SeekingPlayerManager( this, player, walls );\n    this.seekingPlayerManager.chasePlayerSignal.add( this.changeStateToChasing, this );\n\n    this.chasingPlayerManager = new ChasingPlayerManager( this, player );\n    this.chasingPlayerManager.stopChasingPlayerSignal.add( this.changeStateToWalking, this );\n  }\n  update() {\n    switch ( this.state ) {\n    case STATES.WALKING_ON_PATH:\n      this.handleWalkingOnPathState();\n      break;\n    case STATES.CHASING_PLAYER:\n      this.handleChasingPlayerState();\n    }\n  }\n  onCollisionEnter( ...args ) {\n    switch ( this.state ) {\n    case STATES.WALKING_ON_PATH:\n      this.walkingOnPathManager.onCollisionEnter( ...args );\n      this.seekingPlayerManager.onCollisionEnter( ...args );\n      break;\n    case STATES.CHASING_PLAYER:\n      this.chasingPlayerManager.onCollisionEnter( ...args );\n      break;\n    }\n  }\n  onCollisionLeave( ...args ) {\n    switch ( this.state ) {\n    case STATES.WALKING_ON_PATH:\n      this.seekingPlayerManager.onCollisionLeave( ...args );\n      break;\n    case STATES.CHASING_PLAYER:\n      this.chasingPlayerManager.onCollisionLeave( ...args );\n      break;\n    }\n  }\n  handleWalkingOnPathState() {\n    this.walkingOnPathManager.update();\n\n    const currentTileTarget = this.walkingOnPathManager.getCurrentTileTarget();\n    this.rotationManager.update( currentTileTarget );\n\n    this.seekingPlayerManager.update();\n  }\n  handleChasingPlayerState() {\n    const lastKnownPlayerPosition = this.seekingPlayerManager.getLastKnownPlayerPosition();\n    this.chasingPlayerManager.update( lastKnownPlayerPosition );\n  }\n  changeStateToChasing() {\n    this.state = STATES.CHASING_PLAYER;\n  }\n  startChasingByBeingNotified() {\n    this.seekingPlayerManager.isNotified = true;\n    this.changeStateToChasing();\n  }\n  changeStateToWalking() {\n    this.seekingPlayerManager.onStopChasing();\n    this.walkingOnPathManager.getBackOnPath();\n    this.state = STATES.WALKING_ON_PATH;\n  }\n  isChasing() {\n    return this.state === STATES.CHASING_PLAYER;\n  }\n  takeDamage( damage ) {\n    Entity.prototype.takeDamage.call( this, [ damage ] );\n    if ( this.health <= 0 ) {\n      this.destroy();\n    }\n  }\n  onPlayerDeath() {\n    this.seekingPlayerManager.stopLookingForThePlayer();\n\n    if ( this.isChasing() ) {\n      this.changeStateToWalking();\n    }\n  }\n}\n",
    "import * as CONSTANTS from '../../constants/ZombieConstants';\nimport NotificationsManager from './NotificationsManager';\n\nexport default class ChasingPlayerManager {\n  constructor( zombie, player ) {\n    this.zombie = zombie;\n    this.player = player;\n\n    this.stopChasingPlayerSignal = new Phaser.Signal();\n\n    // attack system init\n    this.canDealDamage = true;\n    this.isInAttackRange = false;\n\n    const attackSensor = this.zombie.body.addCircle( CONSTANTS.ZOMBIE_ATTACK_RANGE );\n    attackSensor.sensor = true;\n    attackSensor.sensorType = 'attack';\n\n    this.notificationsManager = new NotificationsManager( this.zombie );\n\n    this.lastKnownPlayerPosition = Object.assign( {}, this.player.position );\n  }\n  update( lastKnownPlayerPosition ) {\n    this.lastKnownPlayerPosition = lastKnownPlayerPosition;\n    this.zombie.game.physics.arcade.moveToObject( this.zombie, lastKnownPlayerPosition, CONSTANTS.ZOMBIE_SPEED * CONSTANTS.ZOMBIE_SPEED_CHASING_MULTIPLIER );\n    this.zombie.lookAt( lastKnownPlayerPosition.x, lastKnownPlayerPosition.y );\n\n    this.notificationsManager.update();\n\n    if ( this.shouldZombieStopChasingPlayer( lastKnownPlayerPosition ) ) {\n      this.stopChasingPlayer();\n    }\n\n    if ( this.shouldAttack() ) {\n      this.handleAttack();\n    }\n  }\n  shouldZombieStopChasingPlayer( lastKnownPlayerPosition ) {\n    const distanceToTarget = this.zombie.game.physics.arcade.distanceBetween( this.zombie, lastKnownPlayerPosition );\n    return ( this.player.x !== lastKnownPlayerPosition.x || this.player.y !== lastKnownPlayerPosition.y )\n     && distanceToTarget <= CONSTANTS.MIN_DISTANCE_TO_TARGET;\n  }\n  stopChasingPlayer() {\n    this.stopChasingPlayerSignal.dispatch();\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA ) {\n    if ( bodyA == null || bodyA.sprite == null ) {\n      return;\n    }\n    if ( shapeA.sensorType === 'attack' && bodyA.sprite.key === 'player' ) {\n      this.isInAttackRange = true;\n    }\n    this.notificationsManager.onCollisionEnter( bodyA, bodyB, shapeA );\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA ) {\n    if ( bodyA == null || bodyA.sprite == null ) {\n      return;\n    }\n    if ( shapeA.sensorType === 'attack' && bodyA.sprite.key === 'player' ) {\n      this.isInAttackRange = false;\n    }\n\n    this.notificationsManager.onCollisionLeave( bodyA, bodyB, shapeA );\n  }\n  shouldAttack() {\n    return this.zombie.alive && this.canDealDamage && this.isInAttackRange;\n  }\n  handleAttack() {\n    this.zombie.animations.play( 'attack', CONSTANTS.ZOMBIE_FIGHT_ANIMATION_FRAMERATE, false );\n    this.player.takeDamage( CONSTANTS.ZOMBIE_DAMAGE_VALUE );\n    this.canDealDamage = false;\n    this.zombie.game.time.events.add( Phaser.Timer.SECOND * CONSTANTS.ZOMBIE_DAMAGE_COOLDOWN, this.endCooldown, this );\n    this.zombie.game.camera.shake( 0.005, 100, false );\n  }\n  endCooldown() {\n    this.canDealDamage = true;\n    this.zombie.animations.play( 'walk', CONSTANTS.ZOMBIE_WALK_ANIMATION_FRAMERATE, true );\n  }\n}\n",
    "import { ZOMBIE_NOTIFY_RANGE } from '../../constants/ZombieConstants';\n\nexport default class NotificationsManager {\n  constructor( zombie ) {\n    this.zombie = zombie;\n\n    const notifySensor = zombie.body.addCircle( ZOMBIE_NOTIFY_RANGE );\n    notifySensor.sensor = true;\n    notifySensor.sensorType = 'notify';\n\n    this.zombiesToNotify = new Set();\n  }\n  isItNotifySensor( shape, body ) {\n    if ( !body || !body.sprite ) {\n      return false;\n    }\n    return shape.sensorType === 'notify' && body.sprite.key === 'zombie';\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA ) {\n    if ( this.isItNotifySensor( shapeA, bodyA ) ) {\n      this.zombiesToNotify.add( bodyA.sprite );\n    }\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA ) {\n    if ( this.isItNotifySensor( shapeA, bodyA ) ) {\n      this.zombiesToNotify.delete( bodyA.sprite );\n    }\n  }\n  update() {\n    for ( const zombieToNotify of this.zombiesToNotify ) {\n      this.handleNotificationTry( zombieToNotify );\n    }\n  }\n  handleNotificationTry( zombieToNotify ) {\n    if ( zombieToNotify.isChasing() === false ) {\n      this.notify( zombieToNotify );\n    }\n  }\n  notify( zombieToNotify ) {\n    console.log( 'try' );\n    if ( !zombieToNotify.seekingPlayerManager.isPlayerSeparatedFromZombie( this.zombie.chasingPlayerManager.lastKnownPlayerPosition ) ) {\n      console.log( 'chase', this.zombie.chasingPlayerManager.lastKnownPlayerPosition );\n      zombieToNotify.startChasingByBeingNotified( this.zombie.chasingPlayerManager.lastKnownPlayerPosition );\n    }\n  }\n}\n",
    "import EasyStar from 'easystarjs';\n\nexport default class PathFinder {\n  constructor( ) {\n    this.easystar = new EasyStar.js();\n\n    this.easystar.setAcceptableTiles( [ 0 ] );\n  }\n  setGrid( grid ) {\n    this.easystar.setGrid( grid );\n  }\n  findPath( startX, startY, endX, endY, callback ) {\n    this.easystar.findPath( startX, startY, endX, endY, callback );\n    this.easystar.calculate();\n  }\n}\n",
    "import { ZOMBIE_SIGHT_ANGLE, ZOMBIE_SIGHT_RANGE, ZOMBIE_HEARING_RANGE } from '../../constants/ZombieConstants';\nimport { isInDegreeRange } from '../../utils/MathUtils';\n\nexport default class SeekingPlayerManager {\n  constructor( zombie, player, walls ) {\n    this.zombie = zombie;\n    this.player = player;\n    this.walls = walls;\n\n    this.state = 'searching';\n\n    this.isPlayerInViewRange = false;\n    this.isPlayerInHearingRange = false;\n\n    const body = zombie.body;\n\n    const viewSensor = body.addCircle( ZOMBIE_SIGHT_RANGE );\n    viewSensor.sensor = true;\n    viewSensor.sensorType = 'view';\n\n    const hearSensor = body.addCircle( ZOMBIE_HEARING_RANGE );\n    hearSensor.sensor = true;\n    hearSensor.sensorType = 'hear';\n\n    this.chasePlayerSignal = new Phaser.Signal();\n\n    this.shouldLookForThePlayer = true;\n\n    this.isNotified = false;\n  }\n  update() {\n\n    if ( this.shouldLookForThePlayer && this.canDetectPlayer() ) {\n      this.changeStateToChasing();\n    }\n  }\n\n  canDetectPlayer() {\n    if ( this.isPlayerDead || this.isPlayerSeparatedFromZombie( this.player.position ) ) {\n      return false;\n    }\n\n    if ( this.isNotified === true ) {\n      return true;\n    }\n\n    return this.canSeePlayer() || this.canHearPlayer();\n  }\n  isPlayerSeparatedFromZombie( playerPosition ) {\n       /** Draw line between player and zombie and check if it can see him. If yes, chase him. */\n    const playerSeekingRay = new Phaser.Line();\n    playerSeekingRay.start.set( this.zombie.x, this.zombie.y );\n    playerSeekingRay.end.set( playerPosition.x, playerPosition.y );\n\n    const tileHits = this.walls.getRayCastTiles( playerSeekingRay, 0, false, false );\n\n    for ( let i = 0; i < tileHits.length; i++ ) {\n      if ( tileHits[ i ].index >= 0 ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  canSeePlayer() {\n    return ( this.isPlayerInViewRange && isInDegreeRange( this.zombie, this.player, ZOMBIE_SIGHT_ANGLE ) );\n  }\n  canHearPlayer() {\n    return ( this.isPlayerInHearingRange && !this.player.isSneaking && this.player.isMoving() );\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA ) {\n    if ( this.isItSensorArea( bodyA, shapeA ) ) {\n      if ( shapeA.sensorType === 'view' && bodyA.sprite.key === 'player' ) {\n        this.isPlayerInViewRange = true;\n      } else if ( shapeA.sensorType === 'hear' && bodyA.sprite.key === 'player' ) {\n        this.isPlayerInHearingRange = true;\n      }\n    }\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA ) {\n    if ( this.isItSensorArea( bodyA, shapeA ) ) {\n      if ( shapeA.sensorType === 'view' && bodyA.sprite.key === 'player' ) {\n        this.isPlayerInViewRange = false;\n      } else if ( shapeA.sensorType === 'hear' && bodyA.sprite.key === 'player' ) {\n        this.isPlayerInHearingRange = false;\n      }\n    }\n  }\n  isItSensorArea( body, shape ) {\n    if ( body == null || body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n\n    return shape.sensor;\n  }\n  changeStateToChasing() {\n    this.lastKnownPlayerPosition = Object.assign( {}, this.player.position );\n    this.chasePlayerSignal.dispatch();\n  }\n  getLastKnownPlayerPosition() {\n    if ( this.canDetectPlayer() ) {\n      this.lastKnownPlayerPosition = Object.assign( {}, this.player.position );\n    }\n    return this.lastKnownPlayerPosition;\n  }\n  stopLookingForThePlayer() {\n    this.shouldLookForThePlayer = false;\n  }\n  onStopChasing() {\n    this.isNotified = false;\n  }\n}\n",
    "import PathFinder from './PathFinder';\nimport { willZombiesPathsInterfere } from '../../utils/DeterminePathCollisionUtils';\nimport { getFreeTileAroundZombieExcludingOtherZombie } from '../../utils/HandlePathCollisionUtils';\nimport { tileToPixels, pixelsToTile } from '../../utils/MapUtils';\nimport { MIN_DISTANCE_TO_TARGET } from '../../constants/ZombieConstants';\n\nexport const STATES = {\n  NOT_STARTED: 0,\n  ON_STANDARD_PATH: 1,\n  ON_TEMPORARY_PATH: 2,\n  CALCULATING_PATH: 3,\n};\n\nexport default class ZombiePathManager {\n  constructor( zombie, targets, walls ) {\n    this.zombie = zombie;\n    this.targets = targets;\n    this.walls = walls;\n\n    this.pathFinder = new PathFinder();\n    this.pathFinder.setGrid( walls );\n\n    this.pathsBetweenTargets = [];\n\n    this.currentPathIndex = 0;\n    this.currentStepIndex = 0;\n\n    this.temporaryPath = [];\n    this.temporaryStepIndex = 0;\n\n    this.state = STATES.NOT_STARTED;\n  }\n  start( callback ) {\n    // for now it assumes that zombie is placed on first path target\n    this.calculatePathsBetweenTargets( () => {\n      this.state = STATES.ON_STANDARD_PATH;\n      callback();\n    } );\n  }\n  // Recursive function that calculates standard paths and save them into pathsBetweenPathTargets container.\n  // Recurse approach is used to handle asynchronous nature of findPath method.\n  calculatePathsBetweenTargets( doneCallback, index = 0 ) {\n    if ( this.pathsBetweenTargets.length === this.targets.length ) {\n      doneCallback();\n      return;\n    }\n\n    const start = this.targets[ index ];\n    const target = ( index === this.targets.length - 1 ) ? this.targets[ 0 ] : this.targets[ index + 1 ];\n\n    this.pathFinder.findPath( start.x, start.y, target.x, target.y, ( path ) => {\n      this.pathsBetweenTargets.push( { path, start, target } );\n      this.calculatePathsBetweenTargets( doneCallback, index + 1 );\n    } );\n  }\n  update() {\n    switch ( this.state ) {\n    case STATES.ON_STANDARD_PATH:\n      this.moveOnStandardPath();\n      break;\n    case STATES.ON_TEMPORARY_PATH:\n      this.moveOnTemporaryPath();\n      break;\n    case STATES.CALCULATING_PATH:\n      this.zombie.body.velocity.x = 0;\n      this.zombie.body.velocity.y = 0;\n      break;\n    }\n  }\n  moveOnStandardPath() {\n    const stepTarget = this.getCurrentStepTarget();\n\n    if ( this.isReached( stepTarget ) ) {\n      this.onStepTargetReach();\n    }\n    this.zombie.game.physics.arcade.moveToObject( this.zombie, tileToPixels( stepTarget ) );\n  }\n  isReached( target ) {\n    const distanceToTarget = this.zombie.game.physics.arcade.distanceBetween( this.zombie, tileToPixels( target ) );\n    return distanceToTarget <= MIN_DISTANCE_TO_TARGET;\n  }\n  onStepTargetReach() {\n    this.currentStepIndex++;\n\n    if ( this.currentStepIndex === this.pathsBetweenTargets[ this.currentPathIndex ].path.length ) {\n      this.currentStepIndex = 0;\n      this.currentPathIndex++;\n\n      if ( this.currentPathIndex === this.pathsBetweenTargets.length ) {\n        this.currentPathIndex = 0;\n      }\n    }\n  }\n  getCurrentStepTarget() {\n    return this.pathsBetweenTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n  }\n  changePathToTemporary( startTile ) {\n    this.state = STATES.CALCULATING_PATH;\n\n    const currentTarget = this.pathsBetweenTargets[ this.currentPathIndex ].target;\n\n    this.pathFinder.findPath( startTile.x, startTile.y, currentTarget.x, currentTarget.y, ( path ) => {\n      if ( path.length === 0 ) {\n        this.changePathToStandard();\n        return;\n      }\n      this.temporaryPath = path;\n      this.temporaryStepIndex = 0;\n\n      this.state = STATES.ON_TEMPORARY_PATH;\n    } );\n  }\n  getTemporaryStepTarget() {\n    return this.temporaryPath[ this.temporaryStepIndex ];\n  }\n  changePathToStandard() {\n    this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenTargets.length ) ? 0 : this.currentPathIndex + 1;\n    this.currentStepIndex = 0;\n    this.state = STATES.ON_STANDARD_PATH;\n  }\n  moveOnTemporaryPath() {\n    const temporaryStepTarget = this.getTemporaryStepTarget();\n    if ( this.isReached( temporaryStepTarget ) ) {\n      this.onTemporaryStepTargetReach();\n    }\n    this.zombie.game.physics.arcade.moveToObject( this.zombie, tileToPixels( temporaryStepTarget ) );\n  }\n  onTemporaryStepTargetReach() {\n    this.temporaryStepIndex++;\n    if ( this.temporaryStepIndex === this.temporaryPath.length ) {\n      this.changePathToStandard();\n    }\n  }\n  onCollisionEnter( bodyA ) {\n    if ( bodyA == null || bodyA.sprite == null ) {\n      return;\n    }\n\n    if ( bodyA.sprite.key === 'zombie' ) {\n      this.checkForCollisionPossibility( bodyA.sprite );\n    }\n  }\n  checkForCollisionPossibility( zombieToCollideWith ) {\n    if ( willZombiesPathsInterfere( this, zombieToCollideWith.walkingOnPathManager ) ) {\n      const newTemporaryTarget = getFreeTileAroundZombieExcludingOtherZombie( this.zombie, zombieToCollideWith, this.walls );\n      this.changePathToTemporary( newTemporaryTarget );\n    }\n  }\n  getCurrentTileTarget() {\n    if ( this.state === STATES.ON_STANDARD_PATH ) {\n      return this.getCurrentStepTarget();\n    } else if ( this.state === STATES.ON_TEMPORARY_PATH ) {\n      return this.getTemporaryStepTarget();\n    }\n    return pixelsToTile( this.zombie );\n  }\n  getBackOnPath() {\n    const zombieTile = pixelsToTile( this.zombie );\n    this.changePathToTemporary( zombieTile );\n  }\n}\n",
    "import { ZOMBIE_ROTATING_SPEED } from '../../constants/ZombieConstants';\nimport { tileToPixels } from '../../utils/MapUtils';\n\nexport default class ZombieRotationManager {\n  constructor( zombie ) {\n    this.zombie = zombie;\n  }\n  update( tileTarget ) {\n    const lookTarget = this.getLookTarget( tileTarget );\n    const targetPoint = new Phaser.Point( lookTarget.x, lookTarget.y );\n    const entityCenter = new Phaser.Point( this.zombie.body.x + this.zombie.width / 2, this.zombie.body.y + this.zombie.height / 2 );\n\n    let deltaTargetRad = this.zombie.rotation - Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) - 1.5 * Math.PI;\n\n    deltaTargetRad = deltaTargetRad % ( Math.PI * 2 );\n\n    if ( deltaTargetRad != deltaTargetRad % ( Math.PI ) ) {\n      deltaTargetRad = deltaTargetRad + Math.PI * ( ( deltaTargetRad < 0 ) ? 2 : -2 );\n    }\n\n    this.zombie.body.rotateLeft( ZOMBIE_ROTATING_SPEED * deltaTargetRad );\n  }\n  getLookTarget( tile ) {\n    const velocity = this.zombie.body.velocity;\n    const tileCoords = tileToPixels( tile );\n    const veryFarAway = 1000;\n\n    if ( Math.abs( velocity.x ) > Math.abs( velocity.y ) ) {\n      if ( velocity.x > 0 ) {\n        tileCoords.x += veryFarAway;\n      } else {\n        tileCoords.x -= veryFarAway;\n      }\n    } else if ( Math.abs( velocity.x ) < Math.abs( velocity.y ) ) {\n      if ( velocity.y > 0 ) {\n        tileCoords.y += veryFarAway;\n      } else {\n        tileCoords.y -= veryFarAway;\n      }\n    }\n\n    return tileCoords;\n  }\n}\n",
    "class Boot extends Phaser.State {\n  preload() {\n  }\n  create() {\n    // this.game.stage.disableVisibilityChange = true;\n\n    // this.game.scale.maxWidth = 800;\n    // this.game.scale.maxHeight = 600;\n\n    this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n    this.game.scale.updateLayout();\n\n    this.game.physics.startSystem( Phaser.Physics.P2JS );\n    this.game.physics.p2.setImpactEvents( true );\n    this.state.start( 'Preload' );\n  }\n}\n\nexport default Boot;\n",
    "import Player from '../objects/Player';\nimport Zombie from '../objects/Zombie';\nimport TileMap from '../objects/TileMap';\nimport JournalsManager from '../objects/JournalsManager';\nimport Journal from '../objects/Journal';\nimport BoidsManager from '../objects/BoidsManager';\nimport GameOverUI from '../UI/GameOverUI';\n\nimport { PLAYER_INITIAL_FRAME } from '../constants/PlayerConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { getWallsPositions } from '../utils/MapUtils';\n\nexport default class Game extends Phaser.State {\n  create() {\n    this.map = new TileMap( this.game, 'map', TILE_WIDTH, TILE_HEIGHT );\n    this.zombies = [];\n\n    this.initPlayer();\n    this.initCollisionGroups();\n    this.initZombies();\n    this.initJournals();\n    this.setCollisionRelations();\n    this.initGameOverUI();\n\n    this.player.onDeath.add( () => this.handleGameEnd() );\n  }\n  initCollisionGroups() {\n    this.playerCollisionGroup = this.game.physics.p2.createCollisionGroup( this.player );\n    this.zombiesCollisionGroup = this.game.physics.p2.createCollisionGroup();\n    this.journalsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n  }\n  initPlayer() {\n    const playerPos = this.map.getPlayerInitialPosition();\n\n    this.player = new Player( this.game, playerPos.x, playerPos.y, 'player', PLAYER_INITIAL_FRAME, this.zombies );\n    this.game.camera.follow( this.player );\n  }\n  initZombies() {\n    const wallsPositions = getWallsPositions( this.map.walls );\n    this.zombies = new BoidsManager( this.game, wallsPositions );\n\n    for ( let i = 0; i < this.map.paths.length; i++ ) {\n      const newZombie = new Zombie( this.game, 'zombie' );\n\n      newZombie.setTilePosition( this.map.paths[ i ][ 0 ] );\n      newZombie.initializeChasingSystem( this.player, this.map.walls );\n      newZombie.body.setCollisionGroup( this.zombiesCollisionGroup );\n      newZombie.initializePathSystem( this.map.getPath( i ), wallsPositions );\n      newZombie.startPathSystem();\n\n      this.player.onDeath.add( () => newZombie.onPlayerDeath() );\n\n      this.zombies.add( newZombie );\n    }\n  }\n  initJournals() {\n    this.journals = new JournalsManager( this.game, this.player );\n\n    const journalsData = this.map.getJournals();\n    const journalsContent = this.game.cache.getJSON( 'journals' );\n\n    this.game.input.mouse.mouseWheelCallback = () => this.journals.onMouseWheel();\n\n    for ( let i = 0; i < journalsData.length; i++ ) {\n      const content = journalsContent[ journalsData[ i ].name ];\n      const newJournal = new Journal( this.game, content, 'computer' );\n      newJournal.setCorner( journalsData[ i ].cornerX, journalsData[ i ].cornerY );\n      newJournal.setPosition( journalsData[ i ].x, journalsData[ i ].y );\n      newJournal.enableJournal();\n\n      newJournal.body.setCollisionGroup( this.journalsCollisionGroup );\n\n      this.journals.add( newJournal );\n    }\n\n    this.player.body.onBeginContact.add( ( ...args ) => this.journals.onCollisionEnter( ...args ) );\n    this.player.body.onEndContact.add( ( ...args ) => this.journals.onCollisionLeave( ...args ) );\n  }\n  setCollisionRelations() {\n    this.map.collides( [ this.playerCollisionGroup, this.zombiesCollisionGroup ] );\n    this.player.body.collides( [ this.map.wallsCollisionGroup, this.zombiesCollisionGroup, this.journalsCollisionGroup ] );\n\n    this.zombies.forEach( zombie => {\n      zombie.body.collides( [ this.playerCollisionGroup, this.map.wallsCollisionGroup, this.journalsCollisionGroup, this.zombiesCollisionGroup ] );\n    } );\n\n    this.journals.forEach( journal => {\n      journal.body.collides( [ this.playerCollisionGroup, this.zombiesCollisionGroup ] );\n    } );\n  }\n  initGameOverUI() {\n    const mainMenuCallback = () => this.state.start( 'Menu' );\n    const restartCallback = () => this.state.restart();\n    this.gameOverUI = new GameOverUI( this.game, mainMenuCallback, restartCallback );\n  }\n  handleGameEnd() {\n    this.clearScreen();\n    this.gameOverUI.start();\n  }\n  clearScreen() {\n    this.journals.clearUI();\n  }\n}\n",
    "class Menu extends Phaser.State {\n  constructor() {\n    super();\n\n    this.levels = [\n      'Level1',\n      'Level2',\n    ];\n  }\n\n  create() {\n    this.state.start( this.levels[ 0 ] );\n\n    window.goToLevel = ( n ) => {\n      if ( this.levels[ n - 1 ] ) {\n        this.state.start( this.levels[ n - 1 ] );\n      } else {\n        return 'Level not found!';\n      }\n    };\n  }\n}\n\nexport default Menu;\n",
    "import { PLAYER_WIDTH, PLAYER_HEIGHT } from '../constants/PlayerConstants.js';\nimport { ZOMBIE_WIDTH, ZOMBIE_HEIGHT } from '../constants/ZombieConstants.js';\n\nclass Preload extends Phaser.State {\n  preload() {\n    this.load.image( 'tilemap_floor', 'assets/tilemaps/tilemap_floor.png' );\n    this.load.image( 'tilemap_walls', 'assets/tilemaps/tilemap_walls.png' );\n\n    this.game.load.spritesheet( 'player', './assets/images/player-sheet.png', PLAYER_WIDTH, PLAYER_HEIGHT );\n    this.game.load.spritesheet( 'zombie', './assets/images/zombie-sheet.png', ZOMBIE_WIDTH, ZOMBIE_HEIGHT );\n\n    this.game.load.image( 'computer', './assets/images/computer.png' );\n    this.game.load.image( 'layer-background', './assets/images/bg-color.png' );\n    this.game.load.image( 'journal-ui', './assets/images/journal-ui.png' );\n\n    this.game.load.image( 'main-menu-btn', './assets/images/main-menu-btn.png' );\n    this.game.load.image( 'restart-btn', './assets/images/restart-btn.png' );\n  }\n  create() {\n    this.state.start( 'Menu' );\n  }\n}\n\nexport default Preload;\n",
    "import { areTilesTheSame } from './MapUtils';\nimport { STATES } from '../objects/ZombieComponents/ZombiePathManager';\n\nexport function willZombiesPathsInterfere( zombie1, zombie2 ) {\n  if ( !isZombieInMovement( zombie1 ) || !isZombieInMovement( zombie2 ) ) {\n    return false;\n  }\n\n  const zombie1NextTile = getZombieNextStepTarget( zombie1 );\n  const zombie2NextTile = getZombieNextStepTarget( zombie2 );\n  const zombie1CurrentTile = getZombieCurrentStepTarget( zombie1 );\n  const zombie2CurrentTile = getZombieCurrentStepTarget( zombie2 );\n\n  return areTilesTheSame( zombie1NextTile, zombie2NextTile )\n   || areTilesTheSame( zombie1NextTile, zombie2CurrentTile )\n   || areTilesTheSame( zombie1CurrentTile, zombie2CurrentTile )\n   || areTilesTheSame( zombie2CurrentTile, zombie2CurrentTile );\n}\n\nfunction getZombieNextStepTarget( zombie ) {\n  let nextStepTarget;\n  switch ( zombie.state ) {\n  case STATES.ON_STANDARD_PATH:\n    nextStepTarget = getZombieNextStandardStepTarget( zombie );\n    break;\n  case STATES.ON_TEMPORARY_PATH:\n    nextStepTarget = getZombieNextTemporaryStepTarget( zombie );\n  }\n  return nextStepTarget;\n}\n\nfunction getZombieNextStandardStepTarget( zombie ) {\n  let nextStepTargetIndex = zombie.currentStepIndex + 1;\n  let nextStepTargetPathIndex = zombie.currentPathIndex;\n\n  if ( nextStepTargetIndex === zombie.pathsBetweenTargets[ zombie.currentPathIndex ].path.length ) {\n    nextStepTargetIndex = 0;\n    nextStepTargetPathIndex++;\n\n    if ( nextStepTargetPathIndex === zombie.pathsBetweenTargets.length ) {\n      nextStepTargetPathIndex = 0;\n    }\n  }\n\n  return zombie.pathsBetweenTargets[ nextStepTargetPathIndex ].path[ nextStepTargetIndex ];\n}\n\nfunction getZombieNextTemporaryStepTarget( zombie ) {\n  let nextTemporaryStepTargetIndex = zombie.temporaryStepIndex + 1;\n\n  if ( nextTemporaryStepTargetIndex === zombie.temporaryPath.length ) {\n    let nextPathIndex = zombie.currentPathIndex + 1;\n\n    if ( nextPathIndex === zombie.pathsBetweenTargets.length ) {\n      return zombie.pathsBetweenTargets[ 0 ].path[ 1 ];\n    }\n    return zombie.pathsBetweenTargets[ nextPathIndex ].path[ 1 ];\n  }\n  return zombie.temporaryPath[ nextTemporaryStepTargetIndex ];\n}\n\nfunction getZombieCurrentStepTarget( zombie ) {\n  switch ( zombie.state ) {\n  case STATES.ON_STANDARD_PATH:\n    return zombie.getCurrentStepTarget();\n  case STATES.ON_TEMPORARY_PATH:\n    return zombie.getTemporaryStepTarget();\n  }\n}\n\nfunction isZombieInMovement( zombie ) {\n  return zombie.state !== STATES.CALCULATING_PATH && zombie.state !== STATES.NOT_STARTED;\n}\n",
    "import { pixelsToTile, areTilesTheSame } from './MapUtils';\n\nexport function getFreeTileAroundZombieExcludingOtherZombie( zombie, zombieToExclude, mapGrid ) {\n  const zombieTile = pixelsToTile( zombie );\n\n  let collisionSide = getBodyCollisionSide( zombie, zombieToExclude );\n\n  const tileToExclude = getTileToExcludeBaseOnCollisionSide( zombieTile, collisionSide );\n\n  return getFreeTileAroundTileExcludingOtherTile( zombieTile, tileToExclude, mapGrid );\n}\n\nfunction getBodyCollisionSide( zombie1, zombie2 ) {\n  const zombieOffsetX = zombie1.position.x - zombie2.position.x;\n  const zombieOffsetY = zombie1.position.y - zombie2.position.y;\n\n  const directionX = ( zombieOffsetX > 0 ) ? 'LEFT' : 'RIGHT';\n  const directionY = ( zombieOffsetY > 0 ) ? 'UP' : 'DOWN';\n\n  return ( Math.abs( zombieOffsetX ) < Math.abs( zombieOffsetY ) ) ? directionX : directionY;\n}\n\nfunction getTileToExcludeBaseOnCollisionSide( tile, collisionSide ) {\n  const tileCandidates = getTileCandidates( tile );\n\n  switch ( collisionSide ) {\n  case 'UP':\n    return tileCandidates[ 0 ];\n  case 'DOWN':\n    return tileCandidates[ 1 ];\n  case 'LEFT':\n    return tileCandidates[ 2 ];\n  case 'RIGHT':\n    return tileCandidates[ 3 ];\n  }\n}\n\nfunction getFreeTileAroundTileExcludingOtherTile( tile, tileToExclude, mapGrid ) {\n  const tileCandidates = getTileCandidates( tile );\n\n  for ( const tileCandidate of tileCandidates ) {\n    if ( !areTilesTheSame( tileCandidate, tileToExclude )\n     && !isWall( tileCandidate, mapGrid ) ) {\n      return tileCandidate;\n    }\n  }\n\n  throw new Error( 'Couldn\\'t find tile' );\n}\n\nfunction isWall( tile, mapGrid ) {\n  return mapGrid[ tile.x ][ tile.y ] === 1;\n}\n\nfunction getTileCandidates( tile ) {\n  return [\n    { x: tile.x, y: tile.y - 1 },\n    { x: tile.x, y: tile.y + 1 },\n    { x: tile.x - 1, y: tile.y },\n    { x: tile.x + 1, y: tile.y },\n  ];\n\n}\n",
    "import { TILE_WIDTH, TILE_HEIGHT, MAP_WIDTH } from '../constants/TileMapConstants';\n\nexport const areTilesTheSame = ( tile1, tile2 ) => tile1.x === tile2.x && tile1.y === tile2.y;\n\nexport const pixelsToTileX = ( coord ) => Math.floor( coord / TILE_WIDTH );\nexport const pixelsToTileY = ( coord ) => Math.floor( coord / TILE_HEIGHT );\n\nexport const tileToPixels = ( tile ) => ( {\n  x: ( tile.x * TILE_WIDTH ) + TILE_WIDTH / 2,\n  y: ( tile.y * TILE_HEIGHT ) + TILE_HEIGHT / 2,\n} );\n\nexport const pixelsToTile = ( coords ) => ( {\n  x: Math.floor( coords.x / TILE_WIDTH ),\n  y: Math.floor( coords.y / TILE_HEIGHT ),\n} );\n\nexport const getWallsPositions = ( layer ) => {\n  const walls = layer.getTiles( 0, 0, 2048, 2048 );\n  const wallsArr = [];\n\n  let currentY = [];\n\n  walls.forEach( ( v, i ) => {\n    if ( v.index !== -1 ) {\n      currentY.push( 1 );\n    } else {\n      currentY.push( 0 );\n    }\n\n    if ( i % MAP_WIDTH === ( MAP_WIDTH - 1 ) ) {\n      wallsArr.push( currentY );\n      currentY = [];\n    }\n  } );\n\n  return wallsArr;\n};\n",
    "export function isInDegreeRange( entity, target, sightAngle ) {\n  const angleDelta = Math.abs( Phaser.Math.radToDeg( Phaser.Math.angleBetween( entity.x, entity.y, target.x, target.y ) ) + 90 - entity.angle );\n\n  return angleDelta <= sightAngle || angleDelta >= ( 360 - sightAngle );\n}\n",
    "export const getScreenCenter = ( game ) => ( {\n  x: game.camera.x + game.camera.width / 2,\n  y: game.camera.y + game.camera.height / 2,\n} );\n\nexport function showBackgroundLayer( game ) {\n  const screenCenter = getScreenCenter( game );\n\n  const backgroundLayer = game.add.sprite( screenCenter.x, screenCenter.y, 'layer-background' );\n  backgroundLayer.width = game.width + 100;\n  backgroundLayer.height = game.height + 100;\n  backgroundLayer.anchor.setTo( 0.5 );\n  backgroundLayer.alpha = 0.2;\n\n  return backgroundLayer;\n}\n"
  ]
}