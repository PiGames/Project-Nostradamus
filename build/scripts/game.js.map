{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/easystarjs/src/easystar.js",
    "node_modules/easystarjs/src/instance.js",
    "node_modules/easystarjs/src/node.js",
    "node_modules/heap/index.js",
    "node_modules/heap/lib/heap.js",
    "src/ProjectNostradamus.js",
    "src/constants/ItemConstants.js",
    "src/constants/PlayerConstants.js",
    "src/constants/TileMapConstants.js",
    "src/constants/UserInterfaceConstants.js",
    "src/constants/ZombieConstants.js",
    "src/index.js",
    "src/levels/Level1.js",
    "src/objects/BoidsManager.js",
    "src/objects/Entity.js",
    "src/objects/EntityWalkingOnPath.js",
    "src/objects/Journal.js",
    "src/objects/JournalsManager.js",
    "src/objects/PathFinder.js",
    "src/objects/Player.js",
    "src/objects/TileMap.js",
    "src/objects/WalkingEntitiesManager.js",
    "src/objects/Zombie.js",
    "src/objects/ZombiesManager.js",
    "src/states/Boot.js",
    "src/states/Game.js",
    "src/states/Menu.js",
    "src/states/Preload.js",
    "src/utils/EntityManagerUtils.js",
    "src/utils/MapUtils.js",
    "src/utils/UserInterfaceUtils.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvXA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;I,AAEM;gCACJ;;8B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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/**\n*   EasyStar.js\n*   github.com/prettymuchbryce/EasyStarJS\n*   Licensed under the MIT license.\n*\n*   Implementation By Bryce Neal (@prettymuchbryce)\n**/\n\nvar EasyStar = {}\nvar Instance = require('./instance');\nvar Node = require('./node');\nvar Heap = require('heap');\n\nconst CLOSED_LIST = 0;\nconst OPEN_LIST = 1;\n\nmodule.exports = EasyStar;\n\nEasyStar.js = function() {\n    var STRAIGHT_COST = 1.0;\n    var DIAGONAL_COST = 1.4;\n    var syncEnabled = false;\n    var pointsToAvoid = {};\n    var collisionGrid;\n    var costMap = {};\n    var pointsToCost = {};\n    var directionalConditions = {};\n    var allowCornerCutting = true;\n    var iterationsSoFar;\n    var instances = [];\n    var iterationsPerCalculation = Number.MAX_VALUE;\n    var acceptableTiles;\n    var diagonalsEnabled = false;\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array|Number} tiles An array of numbers that represent\n    * which tiles in your grid should be considered\n    * acceptable, or \"walkable\".\n    **/\n    this.setAcceptableTiles = function(tiles) {\n        if (tiles instanceof Array) {\n            // Array\n            acceptableTiles = tiles;\n        } else if (!isNaN(parseFloat(tiles)) && isFinite(tiles)) {\n            // Number\n            acceptableTiles = [tiles];\n        }\n    };\n\n    /**\n    * Enables sync mode for this EasyStar instance..\n    * if you're into that sort of thing.\n    **/\n    this.enableSync = function() {\n        syncEnabled = true;\n    };\n\n    /**\n    * Disables sync mode for this EasyStar instance.\n    **/\n    this.disableSync = function() {\n        syncEnabled = false;\n    };\n\n    /**\n     * Enable diagonal pathfinding.\n     */\n    this.enableDiagonals = function() {\n        diagonalsEnabled = true;\n    }\n\n    /**\n     * Disable diagonal pathfinding.\n     */\n    this.disableDiagonals = function() {\n        diagonalsEnabled = false;\n    }\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array} grid The collision grid that this EasyStar instance will read from.\n    * This should be a 2D Array of Numbers.\n    **/\n    this.setGrid = function(grid) {\n        collisionGrid = grid;\n\n        //Setup cost map\n        for (var y = 0; y < collisionGrid.length; y++) {\n            for (var x = 0; x < collisionGrid[0].length; x++) {\n                if (!costMap[collisionGrid[y][x]]) {\n                    costMap[collisionGrid[y][x]] = 1\n                }\n            }\n        }\n    };\n\n    /**\n    * Sets the tile cost for a particular tile type.\n    *\n    * @param {Number} The tile type to set the cost for.\n    * @param {Number} The multiplicative cost associated with the given tile.\n    **/\n    this.setTileCost = function(tileType, cost) {\n        costMap[tileType] = cost;\n    };\n\n    /**\n    * Sets the an additional cost for a particular point.\n    * Overrides the cost from setTileCost.\n    *\n    * @param {Number} x The x value of the point to cost.\n    * @param {Number} y The y value of the point to cost.\n    * @param {Number} The multiplicative cost associated with the given point.\n    **/\n    this.setAdditionalPointCost = function(x, y, cost) {\n        pointsToCost[x + '_' + y] = cost;\n    };\n\n    /**\n    * Remove the additional cost for a particular point.\n    *\n    * @param {Number} x The x value of the point to stop costing.\n    * @param {Number} y The y value of the point to stop costing.\n    **/\n    this.removeAdditionalPointCost = function(x, y) {\n        delete pointsToCost[x + '_' + y];\n    }\n\n    /**\n    * Remove all additional point costs.\n    **/\n    this.removeAllAdditionalPointCosts = function() {\n        pointsToCost = {};\n    }\n\n    /**\n    * Sets a directional condition on a tile\n    *\n    * @param {Number} x The x value of the point.\n    * @param {Number} y The y value of the point.\n    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access\n    * the tile.\n    **/\n    this.setDirectionalCondition = function(x, y, allowedDirections) {\n        directionalConditions[x + '_' + y] = allowedDirections;\n    };\n\n    /**\n    * Remove all directional conditions\n    **/\n    this.removeAllDirectionalConditions = function() {\n        directionalConditions = {};\n    };\n\n    /**\n    * Sets the number of search iterations per calculation.\n    * A lower number provides a slower result, but more practical if you\n    * have a large tile-map and don't want to block your thread while\n    * finding a path.\n    *\n    * @param {Number} iterations The number of searches to prefrom per calculate() call.\n    **/\n    this.setIterationsPerCalculation = function(iterations) {\n        iterationsPerCalculation = iterations;\n    };\n\n    /**\n    * Avoid a particular point on the grid,\n    * regardless of whether or not it is an acceptable tile.\n    *\n    * @param {Number} x The x value of the point to avoid.\n    * @param {Number} y The y value of the point to avoid.\n    **/\n    this.avoidAdditionalPoint = function(x, y) {\n        pointsToAvoid[x + \"_\" + y] = 1;\n    };\n\n    /**\n    * Stop avoiding a particular point on the grid.\n    *\n    * @param {Number} x The x value of the point to stop avoiding.\n    * @param {Number} y The y value of the point to stop avoiding.\n    **/\n    this.stopAvoidingAdditionalPoint = function(x, y) {\n        delete pointsToAvoid[x + \"_\" + y];\n    };\n\n    /**\n    * Enables corner cutting in diagonal movement.\n    **/\n    this.enableCornerCutting = function() {\n        allowCornerCutting = true;\n    };\n\n    /**\n    * Disables corner cutting in diagonal movement.\n    **/\n    this.disableCornerCutting = function() {\n        allowCornerCutting = false;\n    };\n\n    /**\n    * Stop avoiding all additional points on the grid.\n    **/\n    this.stopAvoidingAllAdditionalPoints = function() {\n        pointsToAvoid = {};\n    };\n\n    /**\n    * Find a path.\n    *\n    * @param {Number} startX The X position of the starting point.\n    * @param {Number} startY The Y position of the starting point.\n    * @param {Number} endX The X position of the ending point.\n    * @param {Number} endY The Y position of the ending point.\n    * @param {Function} callback A function that is called when your path\n    * is found, or no path is found.\n    *\n    **/\n    this.findPath = function(startX, startY, endX, endY, callback) {\n        // Wraps the callback for sync vs async logic\n        var callbackWrapper = function(result) {\n            if (syncEnabled) {\n                callback(result);\n            } else {\n                setTimeout(function() {\n                    callback(result);\n                });\n            }\n        }\n\n        // No acceptable tiles were set\n        if (acceptableTiles === undefined) {\n            throw new Error(\"You can't set a path without first calling setAcceptableTiles() on EasyStar.\");\n        }\n        // No grid was set\n        if (collisionGrid === undefined) {\n            throw new Error(\"You can't set a path without first calling setGrid() on EasyStar.\");\n        }\n\n        // Start or endpoint outside of scope.\n        if (startX < 0 || startY < 0 || endX < 0 || endY < 0 ||\n        startX > collisionGrid[0].length-1 || startY > collisionGrid.length-1 ||\n        endX > collisionGrid[0].length-1 || endY > collisionGrid.length-1) {\n            throw new Error(\"Your start or end point is outside the scope of your grid.\");\n        }\n\n        // Start and end are the same tile.\n        if (startX===endX && startY===endY) {\n            callbackWrapper([]);\n            return;\n        }\n\n        // End point is not an acceptable tile.\n        var endTile = collisionGrid[endY][endX];\n        var isAcceptable = false;\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (endTile === acceptableTiles[i]) {\n                isAcceptable = true;\n                break;\n            }\n        }\n\n        if (isAcceptable === false) {\n            callbackWrapper(null);\n            return;\n        }\n\n        // Create the instance\n        var instance = new Instance();\n        instance.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.bestGuessDistance() - nodeB.bestGuessDistance();\n        });\n        instance.isDoneCalculating = false;\n        instance.nodeHash = {};\n        instance.startX = startX;\n        instance.startY = startY;\n        instance.endX = endX;\n        instance.endY = endY;\n        instance.callback = callbackWrapper;\n\n        instance.openList.push(coordinateToNode(instance, instance.startX,\n            instance.startY, null, STRAIGHT_COST));\n\n        instances.push(instance);\n    };\n\n    /**\n    * This method steps through the A* Algorithm in an attempt to\n    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.\n    * You can change the number of calculations done in a call by using\n    * easystar.setIteratonsPerCalculation().\n    **/\n    this.calculate = function() {\n        if (instances.length === 0 || collisionGrid === undefined || acceptableTiles === undefined) {\n            return;\n        }\n        for (iterationsSoFar = 0; iterationsSoFar < iterationsPerCalculation; iterationsSoFar++) {\n            if (instances.length === 0) {\n                return;\n            }\n\n            if (syncEnabled) {\n                // If this is a sync instance, we want to make sure that it calculates synchronously.\n                iterationsSoFar = 0;\n            }\n\n            // Couldn't find a path.\n            if (instances[0].openList.size() === 0) {\n                var ic = instances[0];\n                ic.callback(null);\n                instances.shift();\n                continue;\n            }\n\n            var searchNode = instances[0].openList.pop();\n\n            // Handles the case where we have found the destination\n            if (instances[0].endX === searchNode.x && instances[0].endY === searchNode.y) {\n                instances[0].isDoneCalculating = true;\n                var path = [];\n                path.push({x: searchNode.x, y: searchNode.y});\n                var parent = searchNode.parent;\n                while (parent!=null) {\n                    path.push({x: parent.x, y:parent.y});\n                    parent = parent.parent;\n                }\n                path.reverse();\n                var ic = instances[0];\n                var ip = path;\n                ic.callback(ip);\n                return\n            }\n\n            var tilesToSearch = [];\n            searchNode.list = CLOSED_LIST;\n\n            if (searchNode.y > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: -1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y-1)});\n            }\n            if (searchNode.x < collisionGrid[0].length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x+1, searchNode.y)});\n            }\n            if (searchNode.y < collisionGrid.length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: 1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y+1)});\n            }\n            if (searchNode.x > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: -1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x-1, searchNode.y)});\n            }\n            if (diagonalsEnabled) {\n                if (searchNode.x > 0 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y+1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x > 0 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y+1)});\n                    }\n                }\n            }\n\n            var isDoneCalculating = false;\n\n            // Search all of the surrounding nodes\n            for (var i = 0; i < tilesToSearch.length; i++) {\n                checkAdjacentNode(tilesToSearch[i].instance, tilesToSearch[i].searchNode,\n                    tilesToSearch[i].x, tilesToSearch[i].y, tilesToSearch[i].cost);\n                if (tilesToSearch[i].instance.isDoneCalculating === true) {\n                    isDoneCalculating = true;\n                    break;\n                }\n            }\n\n            if (isDoneCalculating) {\n                instances.shift();\n                continue;\n            }\n\n        }\n    };\n\n    // Private methods follow\n    var checkAdjacentNode = function(instance, searchNode, x, y, cost) {\n        var adjacentCoordinateX = searchNode.x+x;\n        var adjacentCoordinateY = searchNode.y+y;\n\n        if (pointsToAvoid[adjacentCoordinateX + \"_\" + adjacentCoordinateY] === undefined &&\n            isTileWalkable(collisionGrid, acceptableTiles, adjacentCoordinateX, adjacentCoordinateY, searchNode)) {\n            var node = coordinateToNode(instance, adjacentCoordinateX,\n                adjacentCoordinateY, searchNode, cost);\n\n            if (node.list === undefined) {\n                node.list = OPEN_LIST;\n                instance.openList.push(node);\n            } else if (searchNode.costSoFar + cost < node.costSoFar) {\n                node.costSoFar = searchNode.costSoFar + cost;\n                node.parent = searchNode;\n                instance.openList.updateItem(node);\n            }\n        }\n    };\n\n    // Helpers\n    var isTileWalkable = function(collisionGrid, acceptableTiles, x, y, sourceNode) {\n        if (directionalConditions[x + \"_\" + y]) {\n            var direction = calculateDirection(sourceNode.x - x, sourceNode.y - y)\n            var directionIncluded = function () {\n                for (var i = 0; i < directionalConditions[x + \"_\" + y].length; i++) {\n                    if (directionalConditions[x + \"_\" + y][i] === direction) return true\n                }\n                return false\n            }\n            if (!directionIncluded()) return false\n        }\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (collisionGrid[y][x] === acceptableTiles[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * -1, -1 | 0, -1  | 1, -1\n     * -1,  0 | SOURCE | 1,  0\n     * -1,  1 | 0,  1  | 1,  1\n     */\n    var calculateDirection = function (diffX, diffY) {\n        if (diffX === 0, diffY === -1) return EasyStar.BOTTOM\n        else if (diffX === 1, diffY === -1) return EasyStar.BOTTOM_LEFT\n        else if (diffX === 1, diffY === 0) return EasyStar.LEFT\n        else if (diffX === 1, diffY === 1) return EasyStar.TOP_LEFT\n        else if (diffX === 0, diffY === 1) return EasyStar.TOP\n        else if (diffX === -1, diffY === 1) return EasyStar.TOP_RIGHT\n        else if (diffX === -1, diffY === 0) return EasyStar.RIGHT\n        else if (diffX === -1, diffY === -1) return EasyStar.BOTTOM_RIGHT\n        throw new Error('These differences are not valid: ' + diffX + ', ' + diffY)\n    };\n\n    var getTileCost = function(x, y) {\n        return pointsToCost[x + '_' + y] || costMap[collisionGrid[y][x]]\n    };\n\n    var coordinateToNode = function(instance, x, y, parent, cost) {\n        if (instance.nodeHash[x + \"_\" + y]!==undefined) {\n            return instance.nodeHash[x + \"_\" + y];\n        }\n        var simpleDistanceToTarget = getDistance(x, y, instance.endX, instance.endY);\n        if (parent!==null) {\n            var costSoFar = parent.costSoFar + cost;\n        } else {\n            costSoFar = 0;\n        }\n        var node = new Node(parent,x,y,costSoFar,simpleDistanceToTarget);\n        instance.nodeHash[x + \"_\" + y] = node;\n        return node;\n    };\n\n    var getDistance = function(x1,y1,x2,y2) {\n        if (diagonalsEnabled) {\n            // Octile distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            if (dx < dy) {\n                return DIAGONAL_COST * dx + dy;\n            } else {\n                return DIAGONAL_COST * dy + dx;\n            }\n        } else {\n            // Manhattan distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            return (dx + dy);\n        }\n    };\n}\n\nEasyStar.TOP = 'TOP'\nEasyStar.TOP_RIGHT = 'TOP_RIGHT'\nEasyStar.RIGHT = 'RIGHT'\nEasyStar.BOTTOM_RIGHT = 'BOTTOM_RIGHT'\nEasyStar.BOTTOM = 'BOTTOM'\nEasyStar.BOTTOM_LEFT = 'BOTTOM_LEFT'\nEasyStar.LEFT = 'LEFT'\nEasyStar.TOP_LEFT = 'TOP_LEFT'\n",
    "/**\n * Represents a single instance of EasyStar.\n * A path that is in the queue to eventually be found.\n */\nmodule.exports = function() {\n    this.isDoneCalculating = true;\n    this.pointsToAvoid = {};\n    this.startX;\n    this.callback;\n    this.startY;\n    this.endX;\n    this.endY;\n    this.nodeHash = {};\n    this.openList;\n};",
    "/**\n* A simple Node that represents a single tile on the grid.\n* @param {Object} parent The parent node.\n* @param {Number} x The x position on the grid.\n* @param {Number} y The y position on the grid.\n* @param {Number} costSoFar How far this node is in moves*cost from the start.\n* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.\n**/\nmodule.exports = function(parent, x, y, costSoFar, simpleDistanceToTarget) {\n    this.parent = parent;\n    this.x = x;\n    this.y = y;\n    this.costSoFar = costSoFar;\n    this.simpleDistanceToTarget = simpleDistanceToTarget;\n\n    /**\n    * @return {Number} Best guess distance of a cost using this node.\n    **/\n    this.bestGuessDistance = function() {\n        return this.costSoFar + this.simpleDistanceToTarget;\n    }\n};",
    "module.exports = require('./lib/heap');\n",
    "// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n",
    "import Boot from './states/Boot';\nimport Preload from './states/Preload';\nimport Menu from './states/Menu';\nimport Level1 from './levels/Level1';\n\nclass ProjectNostradamus extends Phaser.Game {\n  constructor( width, height, renderer, parent ) {\n    super( width, height, renderer, parent );\n    this.state.add( 'Preload', Preload );\n    this.state.add( 'Boot', Boot );\n    this.state.add( 'Preload', Preload );\n    this.state.add( 'Menu', Menu );\n\n    this.state.add( 'Level1', Level1 );\n\n    this.state.start( 'Boot' );\n  }\n}\nexport default ProjectNostradamus;\n",
    "export const COMPUTER_WIDTH = 32;\nexport const COMPUTER_HEIGHT = 39;\nexport const JOURNAL_TEXT_FIELD_WIDTH = 544;\nexport const JOURNAL_TEXT_FIELD_HEIGHT = 344;\nexport const JOURNAL_TEXT_SCROLL_STEP = 32;\nexport const JOURNAL_TEXT_FONT_SIZE = 16;\n",
    "export const PLAYER_WIDTH = 29;\nexport const PLAYER_HEIGHT = 31;\nexport const PLAYER_INITIAL_FRAME = 1;\nexport const PLAYER_SPEED = 120;\nexport const PLAYER_SNEAK_MULTIPLIER = 0.25;\nexport const PLAYER_SPRINT_MULTIPLIER = 1.5;\nexport const PLAYER_WALK_ANIMATION_FRAMERATE = 7;\nexport const PLAYER_FIGHT_ANIMATION_FRAMERATE = 10;\nexport const PLAYER_HAND_ATTACK_RANGE = 50;\nexport const PLAYER_HAND_ATTACK_ANGLE = 60;\nexport const PLAYER_HAND_ATTACK_DAMAGE = 0.2;\n",
    "export const TILE_WIDTH = 64;\nexport const TILE_HEIGHT = 64;\nexport const MAP_WIDTH = 32;\nexport const MAP_HEIGHT = 32;\n",
    "export const END_SCREEN_FADE_IN_DURATION = 2500;\n",
    "export const ZOMBIE_WIDTH = 36;\nexport const ZOMBIE_HEIGHT = 36;\nexport const ZOMBIE_INITIAL_FRAME = 1;\nexport const ZOMBIE_SPEED = 50;\nexport const ZOMBIE_SPEED_CHASING_MULTIPLIER = 2;\nexport const ZOMBIE_LOOKING_OFFSET = 10;\nexport const ZOMBIE_WALK_ANIMATION_FRAMERATE = 6;\nexport const ZOMBIE_FIGHT_ANIMATION_FRAMERATE = 10;\nexport const MIN_DISTANCE_TO_TARGET = 10;\nexport const ZOMBIE_SIGHT_ANGLE = 45;\nexport const ZOMBIE_SIGHT_RANGE = 500;\nexport const ZOMBIE_HEARING_RANGE = 100;\nexport const ZOMBIE_ROTATING_SPEED = 50;\nexport const ZOMBIE_DAMAGE_MULTIPLIER = 1;\nexport const ZOMBIE_DAMAGE_COOLDOWN = 0.2;\n",
    "import ProjectNostradamus from './ProjectNostradamus';\n\nnew ProjectNostradamus( '100%', '100%', Phaser.AUTO, 'content' );\n\n/*\n!!! This is protection against leaving page while still in game. It is commented out since it was driving me crazy that i had to confirm leavinmg every time browsersync fired. !!!\nwindow.onbeforeunload = (e) => {\n  return 'Really want to quit the game?';\n};\n\ndocument.onkeydown = ( e ) => {\n  e = e || window.event;\n  if ( e.ctrlKey ) {\n    const c = e.which || e.keyCode;\n    switch ( c ) {\n    case 83:\n    case 87:\n      e.preventDefault();\n      e.stopPropagation();\n      break;\n    }\n  }\n};\n*/\n",
    "import Game from '../states/Game.js';\n\nexport default class Level1 extends Game {\n  preload() {\n    Game.prototype.preload.call( this );\n\n    this.load.tilemap( 'map', 'assets/levels/level1/map.json', null, Phaser.Tilemap.TILED_JSON );\n  }\n  create() {\n    Game.prototype.create.call( this );\n    console.log( 'level1 loaded' );\n  }\n}\n",
    "import { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { pixelsToTile, tileToPixels } from '../utils/MapUtils.js';\n\nexport default class BoidsManager {\n  constructor( game, entities, mapGrid, boidsDistance = Math.max( TILE_WIDTH, TILE_HEIGHT ), distanceBetweenBoidsAndWalls = boidsDistance ) {\n    this.entities = entities;\n    this.mapGrid = mapGrid;\n    this.boidsDistance = boidsDistance;\n    this.distanceBetweenBoidsAndWalls = distanceBetweenBoidsAndWalls;\n    this.game = game;\n  }\n  update() {\n    for ( const boid of this.entities ) {\n      if ( boid.isChasing === false ) {\n        continue;\n      }\n      const velocity1 = this.flyTowardsMassCenterRule( boid );\n      const velocity2 = this.keepSmallDistanceFromObstaclesRule( boid );\n      const velocity3 = this.tryMatchingOtherEnitiesVelocityRule( boid );\n\n      boid.body.velocity.x += velocity1.x + velocity2.x + velocity3.x;\n      boid.body.velocity.y += velocity1.y + velocity2.y + velocity3.y;\n    }\n  }\n  flyTowardsMassCenterRule( boid ) {\n    const velocity = { x: 0, y: 0 };\n\n    for ( const entity of this.entities ) {\n      if ( entity === boid ) {\n        continue;\n      }\n      velocity.x += entity.body.x;\n      velocity.y += entity.body.y;\n    }\n\n    velocity.x = ( velocity.x / ( this.entities.length - 1 ) ) / 100;\n    velocity.y = ( velocity.y / ( this.entities.length - 1 ) ) / 100;\n\n    return velocity;\n  }\n  keepSmallDistanceFromObstaclesRule( boid ) {\n    const velocity = { x: 0, y: 0 };\n\n    for ( const otherBoid of this.entities ) {\n      if ( otherBoid === boid ) {\n        continue;\n      }\n      if ( this.game.physics.arcade.distanceBetween( otherBoid, boid ) <= this.boidsDistance ) {\n        velocity.x -= otherBoid.body.x - boid.body.x;\n        velocity.y -= otherBoid.body.y - boid.body.y;\n      }\n    }\n\n    const wallBodies = this.getAdjoiningWallBodies( boid );\n    for ( const wallBody of wallBodies ) {\n      if ( this.game.physics.arcade.distanceBetween( wallBody, boid ) <= this.distanceBetweenBoidsAndWalls ) {\n        velocity.x -= wallBody.x - boid.body.x;\n        velocity.y -= wallBody.y - boid.body.y;\n      }\n    }\n\n    return velocity;\n  }\n  getAdjoiningWallBodies( entity ) {\n    const entityTile = pixelsToTile( entity );\n    const adjoiningTiles = [\n      { x: entityTile.x - 1, y: entityTile.y - 1 },\n      { x: entityTile.x - 1, y: entityTile.y },\n      { x: entityTile.x - 1, y: entityTile.y + 1 },\n      { x: entityTile.x, y: entityTile.y - 1 },\n      { x: entityTile.x, y: entityTile.y + 1 },\n      { x: entityTile.x + 1, y: entityTile.y - 1 },\n      { x: entityTile.x + 1, y: entityTile.y },\n      { x: entityTile.x + 1, y: entityTile.y + 1 },\n    ];\n\n    const adjoiningWallTiles = adjoiningTiles.filter( ( tile ) => this.mapGrid[ tile.y ][ tile.x ] === 1 );\n    return adjoiningWallTiles.map( tileToPixels );\n  }\n  tryMatchingOtherEnitiesVelocityRule() {\n    return { x: 0, y: 0 };\n  }\n}\n",
    "class Entity extends Phaser.Sprite {\n  constructor( game, x, y, imageKey, frame ) {\n    super( game, x, y, imageKey, frame );\n\n    this.anchor.setTo( 0.5, 0.5 );\n\n    this.game.physics.p2.enable( this );\n    this.body.collideWorldBounds = true;\n\n    this.game.world.add( this );\n  }\n  lookAt( targetX, targetY ) {\n    const targetPoint = new Phaser.Point( targetX, targetY );\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\n\n    let targetAngle = Phaser.Math.radToDeg( Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) ) - 90;\n\n    if ( targetAngle < 0 ) {\n      targetAngle += 360;\n    }\n\n    this.body.angle = targetAngle;\n  }\n  normalizeVelocity() {\n    if ( this.body.velocity.x !== 0 && this.body.velocity.y !== 0 ) {\n      this.body.velocity.x = this.body.velocity.x * Math.sqrt( 2 ) * 1 / 2;\n      this.body.velocity.y = this.body.velocity.y * Math.sqrt( 2 ) * 1 / 2;\n    }\n  }\n  resetVelocity() {\n    this.body.velocity.x = 0;\n    this.body.velocity.y = 0;\n  }\n  isMoving() {\n    return this.body.velocity.x !== 0 || this.body.velocity.y !== 0;\n  }\n  isInDegreeRange( entity, target, sightAngle ) {\n    const angleDelta = Math.abs( Phaser.Math.radToDeg( Phaser.Math.angleBetween( entity.x, entity.y, target.x, target.y ) ) + 90 - entity.angle );\n\n    return angleDelta <= sightAngle || angleDelta >= ( 360 - sightAngle );\n  }\n}\n\nexport default Entity;\n",
    "import Entity from './Entity';\nimport PathFinder from '../objects/PathFinder.js';\nimport { ZOMBIE_SPEED, ZOMBIE_ROTATING_SPEED, MIN_DISTANCE_TO_TARGET } from '../constants/ZombieConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { tileToPixels, getWallsPostions } from '../utils/MapUtils.js';\n\n/** Create Entity that is supposed to walk on given path. Set position of entity on first given target*/\nexport default class EntityWalkingOnPath extends Entity {\n  constructor( game, imageKey, frame, targets, walls ) {\n    const position = tileToPixels( targets[ 0 ] );\n\n    super( game, position.x, position.y, imageKey, frame );\n\n    this.pathfinder = new PathFinder();\n    this.wallsPositions = getWallsPostions( walls );\n\n    this.pathfinder.setGrid( this.wallsPositions );\n\n    this.targets = targets;\n\n    this.pathsBetweenPathTargets = [];\n\n    this.currentPathIndex = 0;\n    this.currentStepIndex = 0;\n\n    this.isOnStandardPath = true;\n    this.temporaryPath = [];\n    this.temporaryStepIndex = 0;\n\n    /* disable update until paths are calculated */\n    this.isInitialized = false;\n    this.canMove = false;\n\n    this.calculatePathsBetweenTargets( () => {\n      this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n      this.isInitialized = true;\n      this.canMove = true;\n    } );\n  }\n  /**Recursive function that calculates standard paths and save them into pathsBetweenPathTargets container.  Recurse approach is used to handle asynchronous nature of findPath method */\n  calculatePathsBetweenTargets( doneCallback, index = 0 ) {\n    if ( this.pathsBetweenPathTargets.length === this.targets.length ) {\n      doneCallback();\n      return;\n    }\n\n    const start = this.targets[ index ];\n    const target = ( index === this.targets.length - 1 ) ? this.targets[ 0 ] : this.targets[ index + 1 ];\n\n    this.pathfinder.findPath( start.x, start.y, target.x, target.y, ( path ) => {\n      this.pathsBetweenPathTargets.push( { path, start, target } );\n      this.calculatePathsBetweenTargets( doneCallback, index + 1 );\n    } );\n  }\n  update() {\n    /** Check if current target or step target is reached. Move body in stepTarget direction. */\n    if ( this.canMove ) {\n      if ( this.isReached( this.stepTarget ) ) {\n        this.onStepTargetReach();\n      }\n      this.game.physics.arcade.moveToObject( this, tileToPixels( this.stepTarget ), ZOMBIE_SPEED );\n\n      this.updateLookDirection();\n    }\n  }\n  /** When current step target or temporary step target is reached, set step target to the next one.*/\n  /** If current target is reached or temporary target is reached set path to the next one, or get back to standard path*/\n  onStepTargetReach() {\n    if ( this.isOnStandardPath ) {\n      if ( this.currentStepIndex + 1 === this.pathsBetweenPathTargets[ this.currentPathIndex ].path.length ) {\n        this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenPathTargets.length ) ? 0 : this.currentPathIndex + 1;\n        this.currentStepIndex = 0;\n      } else {\n        this.currentStepIndex++;\n      }\n      this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n    } else {\n      if ( this.temporaryStepIndex + 1 === this.temporaryPath.length ) {\n        this.changePathToStandard();\n      } else {\n        this.temporaryStepIndex++;\n        this.stepTarget = this.temporaryPath[ this.temporaryStepIndex ];\n      }\n    }\n  }\n  updateLookDirection() {\n    const lookTarget = this.getTilesEndCoords( this.stepTarget );\n    const targetPoint = new Phaser.Point( lookTarget.x, lookTarget.y );\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\n\n    let deltaTargetRad = this.rotation - Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) - 1.5 * Math.PI;\n\n    deltaTargetRad = deltaTargetRad % ( Math.PI * 2 );\n\n    if ( deltaTargetRad != deltaTargetRad % ( Math.PI ) ) {\n      deltaTargetRad = deltaTargetRad + Math.PI * ( ( deltaTargetRad < 0 ) ? 2 : -2 );\n    }\n\n    this.body.rotateLeft( ZOMBIE_ROTATING_SPEED * deltaTargetRad );\n  }\n  getTilesEndCoords( tile ) {\n    const tileCoords = tileToPixels( tile );\n    const veryFarAway = 1000;\n    if ( Math.abs( this.body.velocity.x ) > Math.abs( this.body.velocity.y ) ) {\n      if ( this.body.velocity.x > 0 ) {\n        tileCoords.x += veryFarAway * TILE_WIDTH;\n      } else {\n        tileCoords.x -= veryFarAway * TILE_WIDTH;\n      }\n    } else if ( Math.abs( this.body.velocity.x ) < Math.abs( this.body.velocity.y ) ) {\n      if ( this.body.velocity.y > 0 ) {\n        tileCoords.y += veryFarAway * TILE_HEIGHT;\n      } else {\n        tileCoords.y -= veryFarAway * TILE_HEIGHT;\n      }\n    }\n\n    return tileCoords;\n  }\n  isReached( target ) {\n    const distanceToTarget = this.game.physics.arcade.distanceBetween( this, tileToPixels( target ) );\n    return distanceToTarget <= MIN_DISTANCE_TO_TARGET;\n  }\n  calculateTemporaryPath( start, target, callback ) {\n    this.pathfinder.findPath( start.x, start.y, target.x, target.y, callback );\n  }\n  /**\n  * Change path to temporary and automatically get back to standard path, after reaching temporary target.\n  * @param {tile} start - start tile coordinates, if this tile is different that entity's tile then it goes straight to this tile.\n  */\n  changePathToTemporary( start ) {\n    const currentTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].target;\n\n    this.canMove = false;\n    this.calculateTemporaryPath( start, currentTarget, ( path ) => {\n      if ( path.length === 0 ) {\n        this.changePathToStandard();\n        return;\n      }\n      this.temporaryPath = path;\n      this.temporaryStepIndex = 0;\n      this.stepTarget = path[ this.temporaryStepIndex ];\n      this.isOnStandardPath = false;\n      this.canMove = true;\n    } );\n  }\n  changePathToStandard() {\n    this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenPathTargets.length ) ? 0 : this.currentPathIndex + 1;\n    this.currentStepIndex = 0;\n    this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n    this.isOnStandardPath = true;\n  }\n  disableMovement() {\n    this.canMove = false;\n    this.resetVelocity();\n  }\n  enableMovement() {\n    this.canMove = true;\n  }\n}\n",
    "import { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { COMPUTER_WIDTH, COMPUTER_HEIGHT } from '../constants/ItemConstants';\n\nexport default class Journal extends Phaser.Sprite {\n  constructor( game, content, imageKey ) {\n\n    super( game, 0, 0, imageKey );\n\n    this.game.world.add( this );\n\n    this.hasPlayerApproached = false;\n\n    this.content = content;\n  }\n  setCorner( cornerX, cornerY ) {\n    this.cornerX = cornerX;\n    this.cornerY = cornerY;\n  }\n  setPosition( tileX, tileY ) {\n    const cornerX = this.cornerX || 'WEST';\n    const cornerY = this.cornerY || 'NORTH';\n\n    const offsetX = ( cornerX === 'WEST' ) ? ( COMPUTER_WIDTH / 2 ) : TILE_WIDTH - ( COMPUTER_WIDTH / 2 );\n    const offsetY = ( cornerY === 'NORTH' ) ? ( COMPUTER_HEIGHT / 2 ) : TILE_HEIGHT - ( COMPUTER_HEIGHT / 2 );\n\n    const x = tileX + offsetX;\n    const y = tileY + offsetY;\n\n    this.x = x;\n    this.y = y;\n  }\n  enableJournal() {\n    const cornerX = this.cornerX || 'WEST';\n    const cornerY = this.cornerY || 'NORTH';\n\n    this.game.physics.p2.enable( this );\n    this.body.static = true;\n\n    let sensorOffsetX = ( TILE_WIDTH - COMPUTER_WIDTH ) / ( ( cornerX === 'WEST' ) ? 2 : -2 );\n    let sensorOffsetY = ( TILE_HEIGHT - COMPUTER_HEIGHT ) / ( ( cornerY === 'NORTH' ) ? 2 : -2 );\n\n    if ( cornerY === 'SOUTH' ) {\n      this.body.angle = 180;\n      sensorOffsetX += ( TILE_WIDTH - COMPUTER_WIDTH ) * ( ( sensorOffsetX < 0 ) ? 1 : -1 );\n      sensorOffsetY += ( TILE_HEIGHT - COMPUTER_HEIGHT ) * ( ( sensorOffsetY < 0 ) ? 1 : -1 );\n    }\n\n    const rectangleSensor = this.body.addRectangle( TILE_WIDTH, TILE_HEIGHT, sensorOffsetX, sensorOffsetY );\n    rectangleSensor.sensor = true;\n  }\n}\n",
    "import { JOURNAL_TEXT_FIELD_WIDTH, JOURNAL_TEXT_FIELD_HEIGHT, JOURNAL_TEXT_SCROLL_STEP, JOURNAL_TEXT_FONT_SIZE } from '../constants/ItemConstants';\nimport { showBackgroundLayer, getScreenCenter } from '../utils/UserInterfaceUtils';\n\nexport default class JournalsManager extends Phaser.Group {\n  constructor( game, messageText ) {\n    super( game );\n\n    this.messageText = messageText;\n\n    this.activateKey = this.game.input.keyboard.addKey( Phaser.Keyboard.E );\n    this.activateKey.onDown.add( this.tryToShowJournal, this );\n    this.game.input.keyboard.removeKeyCapture( Phaser.Keyboard.E );\n\n    this.activateKey = this.game.input.keyboard.addKey( Phaser.Keyboard.ESC );\n    this.activateKey.onDown.add( this.tryToHideJournal, this );\n    this.game.input.keyboard.removeKeyCapture( Phaser.Keyboard.ESC );\n\n    this.isJournalOpened = false;\n  }\n  tryToShowJournal() {\n    if ( this.isJournalOpened ) {\n      return;\n    }\n    const approachedJournals = this.children.filter( journal => journal.hasPlayerApproached );\n    if ( approachedJournals.length > 0 ) {\n      this.isJournalOpened = true;\n      this.game.paused = true;\n      this.messageText.setText( 'Press \\'ESC\\' to close personal journal.' );\n      this.showJournal( approachedJournals[ 0 ] );\n    }\n  }\n  showJournal( journalToShow ) {\n    const screenCenter = getScreenCenter( this.game );\n\n    this.backgroundLayer = showBackgroundLayer( this.game );\n\n    this.ui = this.game.add.sprite( screenCenter.x, screenCenter.y, 'journal-ui' );\n    this.ui.anchor.setTo( 0.5 );\n\n    const textStyle = {\n      align: 'left',\n      fill: '#10aede',\n      font: `bold ${JOURNAL_TEXT_FONT_SIZE}px Arial`,\n    };\n\n    // TODO make text an internal property of journal object\n    this.uiText = this.game.add.text( screenCenter.x, screenCenter.y, journalToShow.content, textStyle );\n    this.uiText.wordWrap = true;\n    this.uiText.wordWrapWidth = JOURNAL_TEXT_FIELD_WIDTH;\n    this.uiText.setTextBounds( -JOURNAL_TEXT_FIELD_WIDTH / 2, -JOURNAL_TEXT_FIELD_HEIGHT / 2, JOURNAL_TEXT_FIELD_WIDTH, JOURNAL_TEXT_FIELD_HEIGHT );\n\n    this.maskGraphics = this.game.add.graphics( 0, 0 );\n    this.maskGraphics.beginFill( 0xffffff );\n    this.maskGraphics.drawRect( screenCenter.x - JOURNAL_TEXT_FIELD_WIDTH / 2, screenCenter.y - JOURNAL_TEXT_FIELD_HEIGHT / 2, JOURNAL_TEXT_FIELD_WIDTH, JOURNAL_TEXT_FIELD_HEIGHT );\n\n    this.uiText.mask = this.maskGraphics;\n  }\n  tryToHideJournal() {\n    if ( this.isJournalOpened && this.game.paused ) {\n      this.isJournalOpened = false;\n      this.game.paused = false;\n      this.messageText.setText( 'Press \\'E\\' to open personal journal.' );\n      this.backgroundLayer.destroy();\n      this.ui.destroy();\n      this.uiText.destroy();\n      this.maskGraphics.destroy();\n    }\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.messageText.setText( 'Press \\'E\\' to open personal journal.' );\n      bodyA.sprite.hasPlayerApproached = true;\n    }\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.messageText.setText( '' );\n      bodyA.sprite.hasPlayerApproached = false;\n    }\n  }\n  isItSensorArea( body, shape ) {\n    if ( body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n    // for now this line assume that there is only one type of computer's textures\n    // TODO enable different sprite key's handling\n    return body.sprite.key === 'computer' && shape.sensor;\n  }\n  onMouseWheel( ) {\n    if ( this.isJournalOpened === false ) {\n      return;\n    }\n\n    const directionY = this.game.input.mouse.wheelDelta;\n    if ( directionY === 1 && !( this.uiText.y >= this.game.camera.y + this.game.camera.height / 2 ) ) {\n      this.uiText.y += JOURNAL_TEXT_SCROLL_STEP;\n    } else if ( directionY === -1 && !( this.uiText.y <= this.game.camera.y + this.game.camera.height / 2 + JOURNAL_TEXT_FIELD_HEIGHT - this.uiText.height ) ) {\n      this.uiText.y -= JOURNAL_TEXT_SCROLL_STEP;\n    }\n  }\n}\n",
    "import EasyStar from 'easystarjs';\n\nexport default class PathFinder {\n  constructor( ) {\n    this.easystar = new EasyStar.js();\n\n    this.easystar.setAcceptableTiles( [ 0 ] );\n  }\n  setGrid( grid ) {\n    this.easystar.setGrid( grid );\n  }\n  findPath( startX, startY, endX, endY, callback ) {\n    this.easystar.findPath( startX, startY, endX, endY, callback );\n    this.easystar.calculate();\n  }\n}\n",
    "import Entity from './Entity';\nimport { PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_SPEED, PLAYER_SNEAK_MULTIPLIER, PLAYER_SPRINT_MULTIPLIER, PLAYER_WALK_ANIMATION_FRAMERATE, PLAYER_FIGHT_ANIMATION_FRAMERATE, PLAYER_HAND_ATTACK_RANGE, PLAYER_HAND_ATTACK_ANGLE, PLAYER_HAND_ATTACK_DAMAGE } from '../constants/PlayerConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\n\nexport default class Player extends Entity {\n  constructor( game, x, y, imageKey, frame, zombies ) {\n    super( game, x + TILE_WIDTH / 2, y + TILE_HEIGHT / 2, imageKey, frame );\n\n    this.width = PLAYER_WIDTH;\n    this.height = PLAYER_HEIGHT;\n\n    this.zombies = zombies.children;\n\n    this.isSneaking = false;\n    this.isSprinting = false;\n\n    this.attackRange = PLAYER_HAND_ATTACK_RANGE;\n    this.dealingDamage = PLAYER_HAND_ATTACK_DAMAGE;\n\n    this.healthbar = this.game.add.graphics( 0, 0 );\n    this.healthbar.anchor.x = 1;\n    this.healthbar.anchor.y = 1;\n    this.healthbar.fixedToCamera = true;\n\n    this.cursors = {\n      up: this.game.input.keyboard.addKey( Phaser.Keyboard.W ),\n      down: this.game.input.keyboard.addKey( Phaser.Keyboard.S ),\n      left: this.game.input.keyboard.addKey( Phaser.Keyboard.A ),\n      right: this.game.input.keyboard.addKey( Phaser.Keyboard.D ),\n      sneak: this.game.input.keyboard.addKey( Phaser.Keyboard.CAPS_LOCK ),\n      sprint: this.game.input.keyboard.addKey( Phaser.Keyboard.SHIFT ),\n    };\n\n    this.isSneakPressed = false;\n\n    const style = { font: '16px Arial', fill: '#fff' };\n\n    this.sneakText = this.game.add.text( 0, 0, 'Sneaking: off', style );\n    this.sneakText.x = this.game.width - ( this.sneakText.width + 24 );\n    this.sneakText.y = this.game.height - ( this.sneakText.height + 24 + 32 );\n    this.sneakText.fixedToCamera = true;\n\n    this.sprintText = this.game.add.text( 0, 0, 'Sprinting: off', style );\n    this.sprintText.x = this.game.width - ( this.sprintText.width + 24 );\n    this.sprintText.y = this.game.height - ( this.sprintText.height + 24 + 32 + this.sneakText.height );\n    this.sprintText.fixedToCamera = true;\n\n    this.animations.add( 'walk', [ 0, 1, 2, 3, 4, 5 ] );\n    this.animations.add( 'fight', [ 6, 7, 8, 9, 0 ] );\n\n    this.body.clearShapes();\n    this.body.addCircle( Math.min( PLAYER_WIDTH, PLAYER_HEIGHT ) );\n\n    this.drawHealthBar();\n\n    this.onDeath = new Phaser.Signal();\n  }\n\n  update() {\n    this.handleMovement();\n    this.handleAnimation();\n    this.lookAtMouse();\n    this.handleAttack();\n  }\n  handleMovement() {\n    this.resetVelocity();\n\n    if ( this.cursors.up.isDown ) {\n      this.body.velocity.y = -PLAYER_SPEED;\n    } else if ( this.cursors.down.isDown ) {\n      this.body.velocity.y = PLAYER_SPEED;\n    }\n\n    if ( this.cursors.left.isDown ) {\n      this.body.velocity.x = -PLAYER_SPEED;\n    } else if ( this.cursors.right.isDown ) {\n      this.body.velocity.x = PLAYER_SPEED;\n    }\n\n    this.handleMovementSpecialModes();\n\n    this.normalizeVelocity();\n  }\n  handleMovementSpecialModes() {\n    let specialEffectMultiplier = 1;\n\n    this.isSprinting = false;\n\n    if ( this.cursors.sneak.isDown ) {\n      this.isSneakPressed = true;\n    } else if ( this.isSneakPressed ) {\n      this.isSneaking = !this.isSneaking;\n      this.isSneakPressed = false;\n    }\n\n    if ( this.cursors.sprint.isDown ) {\n      this.isSprinting = true;\n      this.isSneaking = false;\n      specialEffectMultiplier = PLAYER_SPRINT_MULTIPLIER;\n    }\n\n    if ( this.isSneaking ) {\n      specialEffectMultiplier = PLAYER_SNEAK_MULTIPLIER;\n    }\n\n    this.sneakText.setText( 'Sneaking: ' + ( ( this.isSneaking ) ? 'on' : 'off' ) );\n    this.sprintText.setText( 'Sprinting: ' + ( ( this.isSprinting ) ? 'on' : 'off' ) );\n\n    this.body.velocity.x *= specialEffectMultiplier;\n    this.body.velocity.y *= specialEffectMultiplier;\n  }\n  handleAnimation() {\n    if ( this.game.input.activePointer.leftButton.isDown ) {\n      this.animations.play( 'fight', PLAYER_FIGHT_ANIMATION_FRAMERATE, false );\n    }\n    if ( ( this.body.velocity.x !== 0 || this.body.velocity.y !== 0 ) && !this.animations.getAnimation( 'fight' ).isPlaying ) {\n      this.animations.play( 'walk', PLAYER_WALK_ANIMATION_FRAMERATE, true );\n    } else {\n      this.animations.stop( 'walk', true );\n    }\n  }\n\n  lookAtMouse() {\n    const mouseX = this.game.input.mousePointer.worldX;\n    const mouseY = this.game.input.mousePointer.worldY;\n\n    this.lookAt( mouseX, mouseY );\n  }\n\n  handleAttack() {\n    if ( this.game.input.activePointer.leftButton.isDown ) {\n      this.zombies.forEach( ( v ) => {\n        if ( v.alive ) {\n          const distanceToZombie = this.game.physics.arcade.distanceBetween( this, v );\n          if ( distanceToZombie < this.attackRange && this.isInDegreeRange( this, v, PLAYER_HAND_ATTACK_ANGLE ) ) {\n            v.takeDamage( this.dealingDamage );\n          }\n        }\n      } );\n    }\n  }\n\n  takeDamage( damage ) {\n    this.damage( damage );\n    this.drawHealthBar();\n\n    if ( this.health <= 0 ) {\n      this.handleDeath();\n    }\n  }\n\n  handleDeath() {\n    this.onDeath.dispatch();\n    this.healthbar.destroy();\n    this.sneakText.destroy();\n    this.sprintText.destroy();\n  }\n  drawHealthBar() {\n    const width = 300;\n    const height = 32;\n\n    this.healthbar.clear();\n    this.healthbar.beginFill( 0xFF0000, 0.85 );\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width * Math.max( this.health, 0 ), height );\n    this.healthbar.endFill();\n    this.healthbar.lineStyle( 2, 0x880000, 1 );\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width, height );\n    this.healthbar.lineStyle( 0 );\n  }\n}\n",
    "import { pixelsToTile } from '../utils/MapUtils.js';\n\nexport default class TileMap extends Phaser.Tilemap {\n  constructor( game, key, tileWidth, tileHeight ) {\n    super( game, key, tileWidth, tileHeight );\n\n    this.addTilesetImage( 'tilemap' );\n\n    this.ground = this.createLayer( 'background' );\n    this.walls = this.createLayer( 'walls' );\n\n    this.paths = [];\n    this.journals = [];\n\n    this.setCollisionByExclusion( [], true, this.walls );\n\n    this.ground.resizeWorld();\n\n    this.wallsBodiesArray = game.physics.p2.convertTilemap( this, this.walls );\n\n    this.wallsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n\n    for ( const body of this.wallsBodiesArray ) {\n      body.setCollisionGroup( this.wallsCollisionGroup );\n    }\n\n    this.createPathPoints();\n  }\n  collides( collisionGroup, callback ) {\n    for ( const body of this.wallsBodiesArray ) {\n      body.collides( collisionGroup, callback );\n    }\n  }\n  createPathPoints() {\n    this.objects[ 'ZombiePaths' ].forEach( ( v ) => {\n      const props = v.properties;\n      if ( !this.paths[ props.PathId ] ) {\n        this.paths[ props.PathId ] = [];\n      }\n\n      this.paths[ props.PathId ][ props.PathIndex ] = pixelsToTile( { x: v.x, y: v.y } );\n    } );\n\n    this.normalizePaths();\n  }\n  getJournals() {\n    const allJournals = this.objects[ 'Journals' ];\n    const journals = [];\n    allJournals.forEach( ( v ) => {\n      const props = v.properties;\n      journals.push(\n        {\n          x: v.x,\n          y: v.y,\n          cornerX: props.cornerX,\n          cornerY: props.cornerY,\n          title: v.name,\n          content: props.content,\n        }\n      );\n    } );\n\n    return journals;\n  }\n  getPlayerInitialPosition() {\n    const player = this.objects[ 'PlayerPos' ][ 0 ];\n    const posObj = {\n      x: player.x,\n      y: player.y,\n    };\n    return posObj;\n  }\n  normalizePaths() {\n    this.paths.forEach( ( pathArr ) => {\n      const tempArr = [];\n      pathArr.forEach( ( v ) => {\n        tempArr.push( v );\n      } );\n\n      pathArr = tempArr;\n    } );\n  }\n  getPath( i ) {\n    return this.paths[ i ];\n  }\n}\n",
    "import { willEntitiesBeOnTheSameTile, getFreeTileAroundEntityExcludingOtherEntity, getDirectionBetweenEntities } from '../utils/EntityManagerUtils';\nimport { pixelsToTile, getWallsPostions } from '../utils/MapUtils.js';\nimport BoidsManager from './BoidsManager.js';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\n\nexport default class WalkingEntitiesManager extends Phaser.Group {\n  constructor( game, grid ) {\n    super( game );\n    this.mapGrid = getWallsPostions( grid );\n    this.allEntitiesInitialized = false;\n\n    this.boidsManager = new BoidsManager( this.game, this.children, this.mapGrid );\n  }\n  update() {\n    if ( this.allEntitiesInitialized || this.areAllEntitiesInitialized() ) {\n      this.manageMovingEntities();\n    }\n\n    Phaser.Group.prototype.update.call( this );\n\n    this.boidsManager.update();\n  }\n  manageMovingEntities() {\n    for ( const entityIndex1 in this.children ) {\n      for ( const entityIndex2 in this.children ) {\n        if ( entityIndex1 === entityIndex2 ) {\n          continue;\n        }\n        const currentHandledEntity = this.children[ Math.min( entityIndex1, entityIndex2 ) ];\n        const otherEntity = this.children[ Math.max( entityIndex1, entityIndex2 ) ];\n\n        if ( currentHandledEntity.canMove && otherEntity.canMove && willEntitiesBeOnTheSameTile( currentHandledEntity, otherEntity ) ) {\n          const freeTile = getFreeTileAroundEntityExcludingOtherEntity( currentHandledEntity, otherEntity, this.mapGrid );\n          const currentTarget = currentHandledEntity.pathsBetweenPathTargets[ currentHandledEntity.currentPathIndex ].target;\n\n          currentHandledEntity.changePathToTemporary( freeTile, currentTarget );\n        }\n      }\n    }\n  }\n  onCollisionWihOtherEntity( entity1, entity2 ) {\n    const freeTile1 = getFreeTileAroundEntityExcludingOtherEntity( entity1, entity2, this.mapGrid );\n    const freeTile2 = getFreeTileAroundEntityExcludingOtherEntity( entity2, entity1, this.mapGrid );\n\n    entity1.changePathToTemporary( freeTile1 );\n    entity1.changePathToTemporary( freeTile2 );\n  }\n  onCollisionWithWalls( entity, tileBody ) {\n    if ( entity.isChasing === false ) {\n      this.findAdjoiningFreeTileAndGoBackOnPath( entity, tileBody );\n    } else {\n      this.resetVelocityInCorrespondingDimension( entity, tileBody );\n    }\n  }\n  findAdjoiningFreeTileAndGoBackOnPath( entity, tileBody ) {\n    const entityTile = pixelsToTile( entity );\n    const tile = pixelsToTile( { x: tileBody.x + TILE_WIDTH / 2, y: tileBody.y + TILE_HEIGHT / 2 } );\n    let freeTile;\n\n    if ( entityTile.x > tile.x ) {\n      freeTile = { x: entityTile.x + 1, y: entityTile.y };\n    } else if ( entityTile.x < tile.x ) {\n      freeTile = { x: entityTile.x - 1, y: entityTile.y };\n    } else if ( entityTile.y < tile.y ) {\n      freeTile = { x: entityTile.x, y: entityTile.y - 1 };\n    } else if ( entityTile.y > tile.y ) {\n      freeTile = { x: entityTile.x, y: entityTile.y + 1 };\n    }\n\n    entity.changePathToTemporary( freeTile );\n  }\n  resetVelocityInCorrespondingDimension( entity, tileBody ) {\n    const direction = getDirectionBetweenEntities( entity, tileBody );\n    // direction is not always correct becuase of the cases when zombie is colliding with tile's corner\n    if ( direction === 'NORTH' || direction === 'SOUTH' ) {\n      entity.body.velocity.x = ( entity.body.velocity.x / Math.abs( entity.body.velocity.x ) ) * Math.sqrt( Math.pow( entity.body.velocity.x, 2 ) + Math.pow( entity.body.velocity.y, 2 ) );\n      entity.body.velocity.y = 0;\n    } else {\n      entity.body.velocity.y = ( entity.body.velocity.y / Math.abs( entity.body.velocity.y ) ) * Math.sqrt( Math.pow( entity.body.velocity.x, 2 ) + Math.pow( entity.body.velocity.y, 2 ) );\n      entity.body.velocity.x = 0;\n    }\n  }\n  areAllEntitiesInitialized() {\n    for ( const entity of this.children ) {\n      if ( !entity.isInitialized ) {\n        return false;\n      }\n    }\n    this.allEntitiesInitialized = true;\n    return true;\n  }\n}\n",
    "import EntityWalkingOnPath from './EntityWalkingOnPath';\nimport { ZOMBIE_SPEED, MIN_DISTANCE_TO_TARGET, ZOMBIE_SPEED_CHASING_MULTIPLIER, ZOMBIE_SIGHT_ANGLE, ZOMBIE_SIGHT_RANGE, ZOMBIE_HEARING_RANGE, ZOMBIE_DAMAGE_TAKEN, ZOMBIE_DAMAGE_COOLDOWN, ZOMBIE_DAMAGE_MULTIPLIER, ZOMBIE_WALK_ANIMATION_FRAMERATE, ZOMBIE_FIGHT_ANIMATION_FRAMERATE } from '../constants/ZombieConstants';\nimport { pixelsToTile } from '../utils/MapUtils.js';\n\nexport default class Zombie extends EntityWalkingOnPath {\n  constructor( game, imageKey, frame, targets, walls, player ) {\n    super( game, imageKey, frame, targets, walls );\n\n    this.player = player;\n    this.walls = walls;\n    this.playerSeekingRay = new Phaser.Line();\n    this.tileHits = [];\n    this.isPlayerInRange = false;\n    this.isChasing = false;\n    this.lastKnownPlayerPosition = { x: 1, y: 1 };\n    this.canDealDamage = true;\n\n    this.damageTaken = ZOMBIE_DAMAGE_TAKEN;\n\n    this.animations.add( 'walk', [ 0, 1, 2, 3, 4, 5 ], 0 );\n    this.animations.add( 'attack', [ 6, 7, 8, 9 ], 6 );\n    this.animations.play( 'walk', ZOMBIE_WALK_ANIMATION_FRAMERATE, true );\n\n    this.isPlayerDead = false;\n\n    this.viewSensor = this.body.addCircle( ZOMBIE_SIGHT_RANGE );\n    this.viewSensor.sensor = true;\n\n    this.attackSensor = this.body.addCircle( 100 );\n    this.attackSensor.sensor = true;\n    this.attackSensor.asd = true;\n  }\n  update() {\n    // this.game.debug.spriteBounds( this );\n\n    if ( this.isPlayerInRange ) {\n      if ( this.canSeePlayer() ) {\n        this.isChasing = true;\n        this.lastKnownPlayerPosition = { x: this.player.x, y: this.player.y };\n        if ( this.shouldAttack() ) {\n          this.handleAttack();\n        }\n      }\n    }\n\n    if ( !this.isChasing ) {\n      EntityWalkingOnPath.prototype.update.call( this );\n    } else {\n      this.chasePlayer();\n    }\n  }\n  canSeePlayer() {\n    if ( this.isPlayerDead ) {\n      return false;\n    }\n    /** Draw line between player and zombie and check if it can see him. If yes, chase him. */\n    this.playerSeekingRay.start.set( this.x, this.y );\n    this.playerSeekingRay.end.set( this.player.x, this.player.y );\n\n    this.tileHits = this.walls.getRayCastTiles( this.playerSeekingRay, 0, false, false );\n\n    if ( this.tileHits.length > 0 ) {\n      for ( let i = 0; i < this.tileHits.length; i++ ) {\n        if ( this.tileHits[ i ].index >= 0 ) {\n          return false;\n        }\n      }\n    }\n\n    return ( this.isInDegreeRange( this, this.player, ZOMBIE_SIGHT_ANGLE )\n    && ( this.isChasing || this.playerSeekingRay.length < ZOMBIE_SIGHT_RANGE ) )\n    || ( this.playerSeekingRay.length < ZOMBIE_HEARING_RANGE && !this.player.isSneaking && this.player.isMoving() );\n  }\n\n  onCollisionEnter( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.isPlayerInRange = true;\n    }\n  }\n\n  onCollisionLeave( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.isPlayerInRange = false;\n    }\n  }\n\n  isItSensorArea( body, shape ) {\n    if ( body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n    // for now this line assume that there is only one type of computer's textures\n    // TODO enable different sprite key's handling\n    return shape.sensor;\n  }\n\n  chasePlayer() {\n    this.game.physics.arcade.moveToObject( this, this.lastKnownPlayerPosition, ZOMBIE_SPEED * ZOMBIE_SPEED_CHASING_MULTIPLIER );\n    this.lookAt( this.lastKnownPlayerPosition.x, this.lastKnownPlayerPosition.y );\n\n    const distanceToTarget = this.game.physics.arcade.distanceBetween( this, this.lastKnownPlayerPosition );\n    if ( !this.canSeePlayer() && ( distanceToTarget <= MIN_DISTANCE_TO_TARGET ) ) {\n      this.stopChasingPlayer();\n    }\n  }\n\n  takeDamage( damage ) {\n    this.damage( damage * ZOMBIE_DAMAGE_MULTIPLIER );\n  }\n\n  endCooldown() {\n    this.canDealDamage = true;\n  }\n\n  stopChasingPlayer() {\n    this.body.velocity.x = 0;\n    this.body.velocity.y = 0;\n    this.isChasing = false;\n    this.changePathToTemporary( pixelsToTile( this ) );\n  }\n  shouldAttack() {\n    return this.alive && this.canDealDamage && this.game.physics.arcade.distanceBetween( this, this.player ) < 50;\n  }\n  handleAttack() {\n    this.animations.play( 'attack', ZOMBIE_FIGHT_ANIMATION_FRAMERATE, false );\n    this.player.takeDamage( 0.1 );\n    this.canDealDamage = false;\n    this.game.time.events.add( Phaser.Timer.SECOND * ZOMBIE_DAMAGE_COOLDOWN, this.endCooldown, this );\n    this.game.camera.shake( 0.005, 100, false );\n  }\n  onPlayerDeath() {\n    this.isPlayerDead = true;\n    if ( this.isChasing ) {\n      this.stopChasingPlayer();\n    }\n  }\n}\n",
    "import WalkingEntitiesManager from '../objects/WalkingEntitiesManager';\n\nexport default class ZombieManager extends WalkingEntitiesManager {\n  constructor( game, grid ) {\n    super( game, grid );\n  }\n\n  update() {\n    WalkingEntitiesManager.prototype.update.call( this );\n  }\n\n}\n",
    "class Boot extends Phaser.State {\n  preload() {\n  }\n  create() {\n    // this.game.stage.disableVisibilityChange = true;\n\n    // this.game.scale.maxWidth = 800;\n    // this.game.scale.maxHeight = 600;\n\n    this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n    this.game.scale.updateLayout();\n\n    this.game.physics.startSystem( Phaser.Physics.P2JS );\n    this.game.physics.p2.setImpactEvents( true );\n    this.state.start( 'Preload' );\n  }\n}\n\nexport default Boot;\n",
    "import Player from '../objects/Player';\nimport Zombie from '../objects/Zombie';\nimport TileMap from '../objects/TileMap';\nimport ZombiesManager from '../objects/ZombiesManager';\nimport JournalsManager from '../objects/JournalsManager';\nimport Journal from '../objects/Journal';\n\nimport { PLAYER_INITIAL_FRAME } from '../constants/PlayerConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { END_SCREEN_FADE_IN_DURATION } from '../constants/UserInterfaceConstants';\n\nimport { getScreenCenter, showBackgroundLayer } from '../utils/UserInterfaceUtils';\n\nexport default class Game extends Phaser.State {\n  create() {\n\n    this.map = new TileMap( this.game, 'map', TILE_WIDTH, TILE_HEIGHT );\n    this.zombies = new ZombiesManager( this.game, this.map.walls );\n    const playerPos = this.map.getPlayerInitialPosition();\n    this.player = new Player( this.game, playerPos.x, playerPos.y, 'player', PLAYER_INITIAL_FRAME, this.zombies );\n\n    const style = { font: '24px Arial', fill: '#fff' };\n\n    this.messageText = this.game.add.text( 0, 0, '', style );\n    this.messageText.x = 24;\n    this.messageText.y = this.game.height - 24 - 32;\n    this.messageText.fixedToCamera = true;\n\n    this.journals = new JournalsManager( this.game, this.messageText );\n\n    this.playerCollisionGroup = this.game.physics.p2.createCollisionGroup( this.player );\n    this.zombiesCollisionGroup = this.game.physics.p2.createCollisionGroup();\n    this.journalsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n\n    // init player\n    this.game.camera.follow( this.player );\n\n    this.map.collides( [ this.playerCollisionGroup ] );\n    this.player.body.collides( [ this.map.wallsCollisionGroup ] );\n\n    // init zombies\n    for ( let i = 0; i < this.map.paths.length; i++ ) {\n      const newZombie = this.zombies.add( new Zombie( this.game, 'zombie', PLAYER_INITIAL_FRAME, this.map.getPath( i ), this.map.walls, this.player ) );\n\n      this.player.body.onBeginContact.add( ( ...args ) => newZombie.onCollisionEnter( ...args ) );\n\n      newZombie.body.setCollisionGroup( this.zombiesCollisionGroup );\n      newZombie.body.collides( this.zombiesCollisionGroup, ( body1, body2 ) => this.zombies.onCollisionWihOtherEntity( body1.sprite, body2.sprite ) );\n      newZombie.body.collides( this.map.wallsCollisionGroup, ( body, tileBody ) => this.zombies.onCollisionWithWalls( body.sprite, tileBody ) );\n      newZombie.body.collides( [ this.playerCollisionGroup, this.journalsCollisionGroup ] );\n      this.player.onDeath.add( () => newZombie.onPlayerDeath() );\n    }\n    this.player.body.collides( [ this.zombiesCollisionGroup ] );\n    this.map.collides( [ this.zombiesCollisionGroup ] );\n\n    // init journals\n    const journalsData = this.map.getJournals();\n\n    this.game.input.mouse.mouseWheelCallback = () => this.journals.onMouseWheel();\n\n    for ( let i = 0; i < journalsData.length; i++ ) {\n      const newJournal = new Journal( this.game, journalsData[ i ].content, 'computer' );\n      newJournal.setCorner( journalsData[ i ].cornerX, journalsData[ i ].cornerY );\n      newJournal.setPosition( journalsData[ i ].x, journalsData[ i ].y );\n      newJournal.enableJournal();\n\n      newJournal.body.setCollisionGroup( this.journalsCollisionGroup );\n      newJournal.body.collides( [ this.playerCollisionGroup, this.zombiesCollisionGroup ] );\n      this.journals.add( newJournal );\n    }\n    this.player.body.collides( this.journalsCollisionGroup );\n\n    this.player.body.onBeginContact.add( ( ...args ) => this.journals.onCollisionEnter( ...args ) );\n    this.player.body.onEndContact.add( ( ...args ) => this.journals.onCollisionLeave( ...args ) );\n\n    this.player.onDeath.add( () => this.handleGameEnd() );\n  }\n  handleGameEnd() {\n    this.clearScreen();\n    this.showEndScreen();\n  }\n  clearScreen() {\n    this.messageText.destroy();\n  }\n  showEndScreen() {\n    const screenCenter = getScreenCenter( this.game );\n\n    this.backgroundLayer = showBackgroundLayer( this.game );\n    this.backgroundLayer.alpha = 0;\n    this.game.add.tween( this.backgroundLayer ).to( { alpha: 0.5 }, END_SCREEN_FADE_IN_DURATION, 'Linear', true );\n\n    const textStyle = {\n      align: 'center',\n      fill: 'white',\n      font: 'bold 80px Arial',\n    };\n\n    const mainText = this.game.add.text( screenCenter.x, screenCenter.y, 'YOU DIED!', textStyle );\n    mainText.anchor.setTo( 0.5 );\n    mainText.alpha = 0;\n    const fadingInTween = this.game.add.tween( mainText ).to( { alpha: 1 }, END_SCREEN_FADE_IN_DURATION, 'Linear', true );\n    fadingInTween.onComplete.add( () => this.showEndScreenButtons() );\n  }\n  showEndScreenButtons() {\n    const mainMenuButton = this.game.add.button( this.game.camera.x + 100, this.game.camera.y + this.game.camera.height - 100, 'main-menu-btn' );\n    mainMenuButton.anchor.setTo( 0, 1 );\n    mainMenuButton.onInputUp.add( () => this.state.start( 'Menu' ) );\n\n    const restartLevelButton = this.game.add.button( this.game.camera.x + this.game.camera.width - 100, this.game.camera.y + this.game.camera.height - 100, 'restart-btn' );\n    restartLevelButton.anchor.setTo( 1, 1 );\n    restartLevelButton.onInputUp.add( () => this.state.restart() );\n  }\n}\n",
    "class Menu extends Phaser.State {\n  create() {\n    this.state.start( 'Level1' );\n  }\n}\n\nexport default Menu;\n",
    "import { PLAYER_WIDTH, PLAYER_HEIGHT } from '../constants/PlayerConstants.js';\nimport { ZOMBIE_WIDTH, ZOMBIE_HEIGHT } from '../constants/ZombieConstants.js';\n\nclass Preload extends Phaser.State {\n  preload() {\n    this.load.image( 'tilemap', 'assets/images/tilemap.png' );\n\n    this.game.load.spritesheet( 'player', './assets/images/player-sheet.png', PLAYER_WIDTH, PLAYER_HEIGHT );\n    this.game.load.spritesheet( 'zombie', './assets/images/zombie-sheet.png', ZOMBIE_WIDTH, ZOMBIE_HEIGHT );\n\n    this.game.load.image( 'computer', './assets/images/computer.png' );\n    this.game.load.image( 'layer-background', './assets/images/bg-color.png' );\n    this.game.load.image( 'journal-ui', './assets/images/journal-ui.png' );\n\n    this.game.load.image( 'main-menu-btn', './assets/images/main-menu-btn.png' );\n    this.game.load.image( 'restart-btn', './assets/images/restart-btn.png' );\n  }\n  create() {\n    this.state.start( 'Menu' );\n  }\n}\n\nexport default Preload;\n",
    "import { pixelsToTile } from '../utils/MapUtils';\n\nexport const getEntityNextTile = ( entity ) => {\n  if ( entity.isOnStandardPath ) {\n    let pathIndex = entity.currentPathIndex;\n    let stepIndex = entity.currentStepIndex;\n\n    if ( entity.pathsBetweenPathTargets[ pathIndex ].path.length === stepIndex + 1 ) {\n      stepIndex = 0;\n\n      if ( entity.pathsBetweenPathTargets.length === pathIndex + 1 ) {\n        pathIndex = 0;\n      } else {\n        pathIndex++;\n      }\n    } else {\n      stepIndex++;\n    }\n    if ( entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ] == undefined ) {\n      throw new Error( `Wrong path data: pathIndex: ${pathIndex}, stepIndex: ${stepIndex}, entity: ${entity}` );\n    }\n    return entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ];\n  } else {\n    let stepIndex = entity.temporaryStepIndex;\n    if ( stepIndex + 1 === entity.temporaryPath.length ) {\n      stepIndex = 0;\n      let pathIndex = ( entity.currentPathIndex + 1 === entity.pathsBetweenPathTargets.length ) ? 0 : entity.currentPathIndex + 1;\n      if ( entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ] == undefined ) {\n        throw new Error( `Wrong path data: pathIndex: ${pathIndex}, stepIndex: ${stepIndex}, entity: ${entity}` );\n      }\n      return entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ];\n    } else {\n      if ( entity.temporaryPath[ stepIndex ] == undefined ) {\n        throw new Error( `Wrong temporary path data: stepIndex: ${stepIndex}` );\n      }\n      return entity.temporaryPath[ stepIndex ];\n    }\n  }\n};\n\nconst areTilesTheSame = ( tile1, tile2 ) => tile1.x === tile2.x && tile1.y === tile2.y;\n\nexport const getEntityCurrentStepTarget = ( entity ) => ( entity.isOnStandardPath ) ? entity.pathsBetweenPathTargets[ entity.currentPathIndex ].path[ entity.currentStepIndex ] : entity.temporaryPath[ entity.temporaryStepIndex ];\n\nexport const willEntitiesBeOnTheSameTile = ( entity1, entity2 ) => {\n  const entityNextTarget1 = getEntityNextTile( entity1 );\n  const entityNextTarget2 = getEntityNextTile( entity2 );\n  const entityCurrentTarget1 = getEntityCurrentStepTarget( entity1 );\n  const entityCurrentTarget2 = getEntityCurrentStepTarget( entity2 );\n\n  return areTilesTheSame( entityNextTarget1, entityNextTarget2 )\n  || areTilesTheSame( entityNextTarget1, entityCurrentTarget2 )\n   || areTilesTheSame( entityCurrentTarget1, entityCurrentTarget2 );\n};\n\nconst getDirectionBetweenTiles = ( tile1, tile2 ) => {\n  if ( tile1.y === tile2.y ) {\n    if ( tile1.x > tile2.x ) {\n      return 'WEST';\n    } else if ( tile1.x < tile2.x ) {\n      return 'EAST';\n    } else {\n      throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n    }\n  } else if ( tile1.x === tile2.x ) {\n    if ( tile1.y > tile2.y ) {\n      return 'NORTH';\n    } else if ( tile1.y < tile2.y ) {\n      return 'SOUTH';\n    } else {\n      throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n    }\n  } else {\n    if ( tile1.y < tile2.y && tile1.x < tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'SOUTH' : 'EAST';\n    } else if ( tile1.y > tile2.y && tile1.x < tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'NORTH' : 'EAST';\n    } else if ( tile1.y < tile2.y && tile1.x > tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'NORTH' : 'WEST';\n    } else if ( tile1.y > tile2.y && tile1.x > tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'SOUTH' : 'WEST';\n    }\n  }\n  throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n};\n\nexport const getDirectionBetweenEntities = ( entity1, entity2 ) => {\n  const entityTile1 = pixelsToTile( entity1 );\n  const entityTile2 = pixelsToTile( entity2 );\n\n  if ( areTilesTheSame( entityTile1, entityTile2 ) ) {\n    // this case maybe can be handled better\n    return getDirectionBetweenTiles( entity1, entity2 );\n  } else {\n    return getDirectionBetweenTiles( entityTile1, entityTile2 );\n  }\n};\n\nexport const getFreeTileAroundEntityExcludingOtherEntity = ( entity, entityToExclude, mapGrid ) => {\n  const entityTile = pixelsToTile( entity );\n  const tileToExclude = getEntityNextTile( entityToExclude );\n\n  let directionToExclude;\n\n  if ( ( entityTile.x === tileToExclude.x && entityTile.y === tileToExclude.y ) || ( entityTile.x !== tileToExclude.x && entityTile.y !== tileToExclude.y ) ) {\n    directionToExclude = getDirectionBetweenEntities( entity, entityToExclude );\n  } else {\n    directionToExclude = getDirectionBetweenTiles( entityTile, tileToExclude );\n  }\n\n  switch ( directionToExclude ) {\n  case 'NORTH':\n    return getFreeTileExcludingNorth( entityTile, mapGrid );\n  case 'SOUTH':\n    return getFreeTileExcludingSouth( entityTile, mapGrid );\n  case 'WEST':\n    return getFreeTileExcludingWest( entityTile, mapGrid );\n  case 'EAST':\n    return getFreeTileExcludingEast( entityTile, mapGrid );\n  }\n\n  throw new Error( `Couldn't find free tile entityTile: ${entityTile}, directionToExclude: ${directionToExclude}` );\n};\n\nfunction getFreeTileExcludingNorth( entityTile, mapGrid ) {\n  let freeTile = { x: -1, y: entityTile.y };\n  if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 && mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = ( Math.random() > 0.5 ) ? entityTile.x - 1 : entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x - 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile = { x: entityTile.x, y: entityTile.y + 1 };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingSouth( entityTile, mapGrid ) {\n  let freeTile = { x: -1, y: entityTile.y };\n  if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 && mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = ( Math.random() > 0.5 ) ? entityTile.x - 1 : entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x - 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile = { x: entityTile.x, y: entityTile.y - 1 };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingWest( entityTile, mapGrid ) {\n  let freeTile = { x: entityTile.x, y: -1 };\n  if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 && mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = ( Math.random() > 0.5 ) ? entityTile.y - 1 : entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile.y = entityTile.y - 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile = { x: entityTile.x + 1, y: entityTile.y };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingEast( entityTile, mapGrid ) {\n  let freeTile = { x: entityTile.x, y: -1 };\n  if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 && mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = ( Math.random() > 0.5 ) ? entityTile.y - 1 : entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile.y = entityTile.y - 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile = { x: entityTile.x - 1, y: entityTile.y };\n  }\n  return freeTile;\n}\n",
    "import { TILE_WIDTH, TILE_HEIGHT, MAP_WIDTH } from '../constants/TileMapConstants';\n\nexport const pixelsToTileX = ( coord ) => Math.floor( coord / TILE_WIDTH );\nexport const pixelsToTileY = ( coord ) => Math.floor( coord / TILE_HEIGHT );\n\nexport const tileToPixels = ( tile ) => ( {\n  x: ( tile.x * TILE_WIDTH ) + TILE_WIDTH / 2,\n  y: ( tile.y * TILE_HEIGHT ) + TILE_HEIGHT / 2,\n} );\n\nexport const pixelsToTile = ( coords ) => ( {\n  x: Math.floor( coords.x / TILE_WIDTH ),\n  y: Math.floor( coords.y / TILE_HEIGHT ),\n} );\n\nexport const getWallsPostions = ( layer ) => {\n  const walls = layer.getTiles( 0, 0, 2048, 2048 );\n  const wallsArr = [];\n\n  let currentY = [];\n\n  walls.forEach( ( v, i ) => {\n    if ( v.index !== -1 ) {\n      currentY.push( 1 );\n    } else {\n      currentY.push( 0 );\n    }\n\n    if ( i % MAP_WIDTH === ( MAP_WIDTH - 1 ) ) {\n      wallsArr.push( currentY );\n      currentY = [];\n    }\n  } );\n\n  return wallsArr;\n};\n",
    "export const getScreenCenter = ( game ) => ( {\n  x: game.camera.x + game.camera.width / 2,\n  y: game.camera.y + game.camera.height / 2,\n} );\n\nexport function showBackgroundLayer( game ) {\n  const screenCenter = getScreenCenter( game );\n\n  const backgroundLayer = game.add.sprite( screenCenter.x, screenCenter.y, 'layer-background' );\n  backgroundLayer.width = game.width + 100;\n  backgroundLayer.height = game.height + 100;\n  backgroundLayer.anchor.setTo( 0.5 );\n  backgroundLayer.alpha = 0.2;\n\n  return backgroundLayer;\n}\n"
  ]
}