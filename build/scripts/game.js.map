{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/easystarjs/src/easystar.js",
    "node_modules/easystarjs/src/instance.js",
    "node_modules/easystarjs/src/node.js",
    "node_modules/heap/index.js",
    "node_modules/heap/lib/heap.js",
    "src/ProjectNostradamus.js",
    "src/constants/PlayerConstants.js",
    "src/constants/TileMapConstants.js",
    "src/constants/ZombieConstants.js",
    "src/index.js",
    "src/objects/Entity.js",
    "src/objects/EntityWalkingOnPath.js",
    "src/objects/PathFinder.js",
    "src/objects/Player.js",
    "src/objects/TileMap.js",
    "src/objects/WalkingEntitiesManager.js",
    "src/objects/Zombie.js",
    "src/objects/ZombiesManager.js",
    "src/states/Boot.js",
    "src/states/Game.js",
    "src/states/Menu.js",
    "src/states/Preload.js",
    "src/utils/EntityManagerUtils.js",
    "src/utils/MapUtils.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvXA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;I,AAEM;gCACJ;;8B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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/**\n*   EasyStar.js\n*   github.com/prettymuchbryce/EasyStarJS\n*   Licensed under the MIT license.\n*\n*   Implementation By Bryce Neal (@prettymuchbryce)\n**/\n\nvar EasyStar = {}\nvar Instance = require('./instance');\nvar Node = require('./node');\nvar Heap = require('heap');\n\nconst CLOSED_LIST = 0;\nconst OPEN_LIST = 1;\n\nmodule.exports = EasyStar;\n\nEasyStar.js = function() {\n    var STRAIGHT_COST = 1.0;\n    var DIAGONAL_COST = 1.4;\n    var syncEnabled = false;\n    var pointsToAvoid = {};\n    var collisionGrid;\n    var costMap = {};\n    var pointsToCost = {};\n    var directionalConditions = {};\n    var allowCornerCutting = true;\n    var iterationsSoFar;\n    var instances = [];\n    var iterationsPerCalculation = Number.MAX_VALUE;\n    var acceptableTiles;\n    var diagonalsEnabled = false;\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array|Number} tiles An array of numbers that represent\n    * which tiles in your grid should be considered\n    * acceptable, or \"walkable\".\n    **/\n    this.setAcceptableTiles = function(tiles) {\n        if (tiles instanceof Array) {\n            // Array\n            acceptableTiles = tiles;\n        } else if (!isNaN(parseFloat(tiles)) && isFinite(tiles)) {\n            // Number\n            acceptableTiles = [tiles];\n        }\n    };\n\n    /**\n    * Enables sync mode for this EasyStar instance..\n    * if you're into that sort of thing.\n    **/\n    this.enableSync = function() {\n        syncEnabled = true;\n    };\n\n    /**\n    * Disables sync mode for this EasyStar instance.\n    **/\n    this.disableSync = function() {\n        syncEnabled = false;\n    };\n\n    /**\n     * Enable diagonal pathfinding.\n     */\n    this.enableDiagonals = function() {\n        diagonalsEnabled = true;\n    }\n\n    /**\n     * Disable diagonal pathfinding.\n     */\n    this.disableDiagonals = function() {\n        diagonalsEnabled = false;\n    }\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array} grid The collision grid that this EasyStar instance will read from.\n    * This should be a 2D Array of Numbers.\n    **/\n    this.setGrid = function(grid) {\n        collisionGrid = grid;\n\n        //Setup cost map\n        for (var y = 0; y < collisionGrid.length; y++) {\n            for (var x = 0; x < collisionGrid[0].length; x++) {\n                if (!costMap[collisionGrid[y][x]]) {\n                    costMap[collisionGrid[y][x]] = 1\n                }\n            }\n        }\n    };\n\n    /**\n    * Sets the tile cost for a particular tile type.\n    *\n    * @param {Number} The tile type to set the cost for.\n    * @param {Number} The multiplicative cost associated with the given tile.\n    **/\n    this.setTileCost = function(tileType, cost) {\n        costMap[tileType] = cost;\n    };\n\n    /**\n    * Sets the an additional cost for a particular point.\n    * Overrides the cost from setTileCost.\n    *\n    * @param {Number} x The x value of the point to cost.\n    * @param {Number} y The y value of the point to cost.\n    * @param {Number} The multiplicative cost associated with the given point.\n    **/\n    this.setAdditionalPointCost = function(x, y, cost) {\n        pointsToCost[x + '_' + y] = cost;\n    };\n\n    /**\n    * Remove the additional cost for a particular point.\n    *\n    * @param {Number} x The x value of the point to stop costing.\n    * @param {Number} y The y value of the point to stop costing.\n    **/\n    this.removeAdditionalPointCost = function(x, y) {\n        delete pointsToCost[x + '_' + y];\n    }\n\n    /**\n    * Remove all additional point costs.\n    **/\n    this.removeAllAdditionalPointCosts = function() {\n        pointsToCost = {};\n    }\n\n    /**\n    * Sets a directional condition on a tile\n    *\n    * @param {Number} x The x value of the point.\n    * @param {Number} y The y value of the point.\n    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access\n    * the tile.\n    **/\n    this.setDirectionalCondition = function(x, y, allowedDirections) {\n        directionalConditions[x + '_' + y] = allowedDirections;\n    };\n\n    /**\n    * Remove all directional conditions\n    **/\n    this.removeAllDirectionalConditions = function() {\n        directionalConditions = {};\n    };\n\n    /**\n    * Sets the number of search iterations per calculation.\n    * A lower number provides a slower result, but more practical if you\n    * have a large tile-map and don't want to block your thread while\n    * finding a path.\n    *\n    * @param {Number} iterations The number of searches to prefrom per calculate() call.\n    **/\n    this.setIterationsPerCalculation = function(iterations) {\n        iterationsPerCalculation = iterations;\n    };\n\n    /**\n    * Avoid a particular point on the grid,\n    * regardless of whether or not it is an acceptable tile.\n    *\n    * @param {Number} x The x value of the point to avoid.\n    * @param {Number} y The y value of the point to avoid.\n    **/\n    this.avoidAdditionalPoint = function(x, y) {\n        pointsToAvoid[x + \"_\" + y] = 1;\n    };\n\n    /**\n    * Stop avoiding a particular point on the grid.\n    *\n    * @param {Number} x The x value of the point to stop avoiding.\n    * @param {Number} y The y value of the point to stop avoiding.\n    **/\n    this.stopAvoidingAdditionalPoint = function(x, y) {\n        delete pointsToAvoid[x + \"_\" + y];\n    };\n\n    /**\n    * Enables corner cutting in diagonal movement.\n    **/\n    this.enableCornerCutting = function() {\n        allowCornerCutting = true;\n    };\n\n    /**\n    * Disables corner cutting in diagonal movement.\n    **/\n    this.disableCornerCutting = function() {\n        allowCornerCutting = false;\n    };\n\n    /**\n    * Stop avoiding all additional points on the grid.\n    **/\n    this.stopAvoidingAllAdditionalPoints = function() {\n        pointsToAvoid = {};\n    };\n\n    /**\n    * Find a path.\n    *\n    * @param {Number} startX The X position of the starting point.\n    * @param {Number} startY The Y position of the starting point.\n    * @param {Number} endX The X position of the ending point.\n    * @param {Number} endY The Y position of the ending point.\n    * @param {Function} callback A function that is called when your path\n    * is found, or no path is found.\n    *\n    **/\n    this.findPath = function(startX, startY, endX, endY, callback) {\n        // Wraps the callback for sync vs async logic\n        var callbackWrapper = function(result) {\n            if (syncEnabled) {\n                callback(result);\n            } else {\n                setTimeout(function() {\n                    callback(result);\n                });\n            }\n        }\n\n        // No acceptable tiles were set\n        if (acceptableTiles === undefined) {\n            throw new Error(\"You can't set a path without first calling setAcceptableTiles() on EasyStar.\");\n        }\n        // No grid was set\n        if (collisionGrid === undefined) {\n            throw new Error(\"You can't set a path without first calling setGrid() on EasyStar.\");\n        }\n\n        // Start or endpoint outside of scope.\n        if (startX < 0 || startY < 0 || endX < 0 || endY < 0 ||\n        startX > collisionGrid[0].length-1 || startY > collisionGrid.length-1 ||\n        endX > collisionGrid[0].length-1 || endY > collisionGrid.length-1) {\n            throw new Error(\"Your start or end point is outside the scope of your grid.\");\n        }\n\n        // Start and end are the same tile.\n        if (startX===endX && startY===endY) {\n            callbackWrapper([]);\n            return;\n        }\n\n        // End point is not an acceptable tile.\n        var endTile = collisionGrid[endY][endX];\n        var isAcceptable = false;\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (endTile === acceptableTiles[i]) {\n                isAcceptable = true;\n                break;\n            }\n        }\n\n        if (isAcceptable === false) {\n            callbackWrapper(null);\n            return;\n        }\n\n        // Create the instance\n        var instance = new Instance();\n        instance.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.bestGuessDistance() - nodeB.bestGuessDistance();\n        });\n        instance.isDoneCalculating = false;\n        instance.nodeHash = {};\n        instance.startX = startX;\n        instance.startY = startY;\n        instance.endX = endX;\n        instance.endY = endY;\n        instance.callback = callbackWrapper;\n\n        instance.openList.push(coordinateToNode(instance, instance.startX,\n            instance.startY, null, STRAIGHT_COST));\n\n        instances.push(instance);\n    };\n\n    /**\n    * This method steps through the A* Algorithm in an attempt to\n    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.\n    * You can change the number of calculations done in a call by using\n    * easystar.setIteratonsPerCalculation().\n    **/\n    this.calculate = function() {\n        if (instances.length === 0 || collisionGrid === undefined || acceptableTiles === undefined) {\n            return;\n        }\n        for (iterationsSoFar = 0; iterationsSoFar < iterationsPerCalculation; iterationsSoFar++) {\n            if (instances.length === 0) {\n                return;\n            }\n\n            if (syncEnabled) {\n                // If this is a sync instance, we want to make sure that it calculates synchronously.\n                iterationsSoFar = 0;\n            }\n\n            // Couldn't find a path.\n            if (instances[0].openList.size() === 0) {\n                var ic = instances[0];\n                ic.callback(null);\n                instances.shift();\n                continue;\n            }\n\n            var searchNode = instances[0].openList.pop();\n\n            // Handles the case where we have found the destination\n            if (instances[0].endX === searchNode.x && instances[0].endY === searchNode.y) {\n                instances[0].isDoneCalculating = true;\n                var path = [];\n                path.push({x: searchNode.x, y: searchNode.y});\n                var parent = searchNode.parent;\n                while (parent!=null) {\n                    path.push({x: parent.x, y:parent.y});\n                    parent = parent.parent;\n                }\n                path.reverse();\n                var ic = instances[0];\n                var ip = path;\n                ic.callback(ip);\n                return\n            }\n\n            var tilesToSearch = [];\n            searchNode.list = CLOSED_LIST;\n\n            if (searchNode.y > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: -1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y-1)});\n            }\n            if (searchNode.x < collisionGrid[0].length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x+1, searchNode.y)});\n            }\n            if (searchNode.y < collisionGrid.length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: 1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y+1)});\n            }\n            if (searchNode.x > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: -1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x-1, searchNode.y)});\n            }\n            if (diagonalsEnabled) {\n                if (searchNode.x > 0 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y+1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x > 0 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y+1)});\n                    }\n                }\n            }\n\n            var isDoneCalculating = false;\n\n            // Search all of the surrounding nodes\n            for (var i = 0; i < tilesToSearch.length; i++) {\n                checkAdjacentNode(tilesToSearch[i].instance, tilesToSearch[i].searchNode,\n                    tilesToSearch[i].x, tilesToSearch[i].y, tilesToSearch[i].cost);\n                if (tilesToSearch[i].instance.isDoneCalculating === true) {\n                    isDoneCalculating = true;\n                    break;\n                }\n            }\n\n            if (isDoneCalculating) {\n                instances.shift();\n                continue;\n            }\n\n        }\n    };\n\n    // Private methods follow\n    var checkAdjacentNode = function(instance, searchNode, x, y, cost) {\n        var adjacentCoordinateX = searchNode.x+x;\n        var adjacentCoordinateY = searchNode.y+y;\n\n        if (pointsToAvoid[adjacentCoordinateX + \"_\" + adjacentCoordinateY] === undefined &&\n            isTileWalkable(collisionGrid, acceptableTiles, adjacentCoordinateX, adjacentCoordinateY, searchNode)) {\n            var node = coordinateToNode(instance, adjacentCoordinateX,\n                adjacentCoordinateY, searchNode, cost);\n\n            if (node.list === undefined) {\n                node.list = OPEN_LIST;\n                instance.openList.push(node);\n            } else if (searchNode.costSoFar + cost < node.costSoFar) {\n                node.costSoFar = searchNode.costSoFar + cost;\n                node.parent = searchNode;\n                instance.openList.updateItem(node);\n            }\n        }\n    };\n\n    // Helpers\n    var isTileWalkable = function(collisionGrid, acceptableTiles, x, y, sourceNode) {\n        if (directionalConditions[x + \"_\" + y]) {\n            var direction = calculateDirection(sourceNode.x - x, sourceNode.y - y)\n            var directionIncluded = function () {\n                for (var i = 0; i < directionalConditions[x + \"_\" + y].length; i++) {\n                    if (directionalConditions[x + \"_\" + y][i] === direction) return true\n                }\n                return false\n            }\n            if (!directionIncluded()) return false\n        }\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (collisionGrid[y][x] === acceptableTiles[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * -1, -1 | 0, -1  | 1, -1\n     * -1,  0 | SOURCE | 1,  0\n     * -1,  1 | 0,  1  | 1,  1\n     */\n    var calculateDirection = function (diffX, diffY) {\n        if (diffX === 0, diffY === -1) return EasyStar.BOTTOM\n        else if (diffX === 1, diffY === -1) return EasyStar.BOTTOM_LEFT\n        else if (diffX === 1, diffY === 0) return EasyStar.LEFT\n        else if (diffX === 1, diffY === 1) return EasyStar.TOP_LEFT\n        else if (diffX === 0, diffY === 1) return EasyStar.TOP\n        else if (diffX === -1, diffY === 1) return EasyStar.TOP_RIGHT\n        else if (diffX === -1, diffY === 0) return EasyStar.RIGHT\n        else if (diffX === -1, diffY === -1) return EasyStar.BOTTOM_RIGHT\n        throw new Error('These differences are not valid: ' + diffX + ', ' + diffY)\n    };\n\n    var getTileCost = function(x, y) {\n        return pointsToCost[x + '_' + y] || costMap[collisionGrid[y][x]]\n    };\n\n    var coordinateToNode = function(instance, x, y, parent, cost) {\n        if (instance.nodeHash[x + \"_\" + y]!==undefined) {\n            return instance.nodeHash[x + \"_\" + y];\n        }\n        var simpleDistanceToTarget = getDistance(x, y, instance.endX, instance.endY);\n        if (parent!==null) {\n            var costSoFar = parent.costSoFar + cost;\n        } else {\n            costSoFar = 0;\n        }\n        var node = new Node(parent,x,y,costSoFar,simpleDistanceToTarget);\n        instance.nodeHash[x + \"_\" + y] = node;\n        return node;\n    };\n\n    var getDistance = function(x1,y1,x2,y2) {\n        if (diagonalsEnabled) {\n            // Octile distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            if (dx < dy) {\n                return DIAGONAL_COST * dx + dy;\n            } else {\n                return DIAGONAL_COST * dy + dx;\n            }\n        } else {\n            // Manhattan distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            return (dx + dy);\n        }\n    };\n}\n\nEasyStar.TOP = 'TOP'\nEasyStar.TOP_RIGHT = 'TOP_RIGHT'\nEasyStar.RIGHT = 'RIGHT'\nEasyStar.BOTTOM_RIGHT = 'BOTTOM_RIGHT'\nEasyStar.BOTTOM = 'BOTTOM'\nEasyStar.BOTTOM_LEFT = 'BOTTOM_LEFT'\nEasyStar.LEFT = 'LEFT'\nEasyStar.TOP_LEFT = 'TOP_LEFT'\n",
    "/**\n * Represents a single instance of EasyStar.\n * A path that is in the queue to eventually be found.\n */\nmodule.exports = function() {\n    this.isDoneCalculating = true;\n    this.pointsToAvoid = {};\n    this.startX;\n    this.callback;\n    this.startY;\n    this.endX;\n    this.endY;\n    this.nodeHash = {};\n    this.openList;\n};",
    "/**\n* A simple Node that represents a single tile on the grid.\n* @param {Object} parent The parent node.\n* @param {Number} x The x position on the grid.\n* @param {Number} y The y position on the grid.\n* @param {Number} costSoFar How far this node is in moves*cost from the start.\n* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.\n**/\nmodule.exports = function(parent, x, y, costSoFar, simpleDistanceToTarget) {\n    this.parent = parent;\n    this.x = x;\n    this.y = y;\n    this.costSoFar = costSoFar;\n    this.simpleDistanceToTarget = simpleDistanceToTarget;\n\n    /**\n    * @return {Number} Best guess distance of a cost using this node.\n    **/\n    this.bestGuessDistance = function() {\n        return this.costSoFar + this.simpleDistanceToTarget;\n    }\n};",
    "module.exports = require('./lib/heap');\n",
    "// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n",
    "import Boot from './states/Boot';\nimport Preload from './states/Preload';\nimport Menu from './states/Menu';\nimport Game from './states/Game';\n\nclass ProjectNostradamus extends Phaser.Game {\n  constructor( width, height, renderer, parent ) {\n    super( width, height, renderer, parent );\n    this.state.add( 'Preload', Preload );\n    this.state.add( 'Boot', Boot );\n    this.state.add( 'Preload', Preload );\n    this.state.add( 'Menu', Menu );\n    this.state.add( 'Game', Game );\n\n    this.state.start( 'Boot' );\n  }\n}\nexport default ProjectNostradamus;\n",
    "export const PLAYER_WIDTH = 30;\nexport const PLAYER_HEIGHT = 24;\nexport const PLAYER_INITIAL_FRAME = 1;\nexport const PLAYER_SPEED = 120;\nexport const PLAYER_SNEAK_MULTIPLIER = 0.75;\nexport const PLAYER_SPRINT_MULTIPLIER = 1.5;\nexport const PLAYER_WALK_ANIMATION_FRAMERATE = 5;\nexport const PLAYER_FIGHT_ANIMATION_FRAMERATE = 10;\n",
    "export const TILE_WIDTH = 64;\nexport const TILE_HEIGHT = 64;\nexport const MAP_WIDTH = 32;\nexport const MAP_HEIGHT = 32;\n",
    "export const ZOMBIE_WIDTH = 30;\nexport const ZOMBIE_HEIGHT = 24;\nexport const ZOMBIE_INITIAL_FRAME = 1;\nexport const ZOMBIE_SPEED = 50;\nexport const ZOMBIE_SPEED_CHASING_MULTIPLIER = 2;\nexport const ZOMBIE_LOOKING_OFFSET = 10;\nexport const ZOMBIE_WALK_ANIMATION_FRAMERATE = 5;\nexport const ZOMBIE_FIGHT_ANIMATION_FRAMERATE = 10;\nexport const MIN_DISTANCE_TO_TARGET = 10;\nexport const ZOMBIE_SIGHT_ANGLE = 45;\nexport const ZOMBIE_SIGHT_RANGE = 500;\nexport const ZOMBIE_HEARING_RANGE = 100;\nexport const ZOMBIE_ROTATING_SPEED = 50;\n",
    "import ProjectNostradamus from './ProjectNostradamus';\n\nnew ProjectNostradamus( '100%', '100%', Phaser.AUTO, 'content' );\n\n/*\n!!! This is protection against leaving page while still in game. It is commented out since it was driving me crazy that i had to confirm leavinmg every time browsersync fired. !!!\nwindow.onbeforeunload = (e) => {\n  return 'Really want to quit the game?';\n};\n\ndocument.onkeydown = ( e ) => {\n  e = e || window.event;\n  if ( e.ctrlKey ) {\n    const c = e.which || e.keyCode;\n    switch ( c ) {\n    case 83:\n    case 87:\n      e.preventDefault();\n      e.stopPropagation();\n      break;\n    }\n  }\n};\n*/\n",
    "class Entity extends Phaser.Sprite {\n  constructor( game, x, y, imageKey, frame ) {\n    super( game, x, y, imageKey, frame );\n\n    this.anchor.setTo( 0.5, 0.5 );\n\n    this.game.physics.p2.enable( this );\n    this.body.collideWorldBounds = true;\n\n    this.game.world.add( this );\n  }\n  lookAt( targetX, targetY ) {\n    const targetPoint = new Phaser.Point( targetX, targetY );\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\n\n    let targetAngle = Phaser.Math.radToDeg( Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) ) - 90;\n\n    if ( targetAngle < 0 ) {\n      targetAngle += 360;\n    }\n\n    this.body.angle = targetAngle;\n  }\n  normalizeVelocity() {\n    if ( this.body.velocity.x !== 0 && this.body.velocity.y !== 0 ) {\n      this.body.velocity.x = this.body.velocity.x * Math.sqrt( 2 ) * 1 / 2;\n      this.body.velocity.y = this.body.velocity.y * Math.sqrt( 2 ) * 1 / 2;\n    }\n  }\n  resetVelocity() {\n    this.body.velocity.x = 0;\n    this.body.velocity.y = 0;\n  }\n  isMoving() {\n    return this.body.velocity.x !== 0 || this.body.velocity.y !== 0;\n  }\n}\n\nexport default Entity;\n",
    "import Entity from './Entity';\nimport PathFinder from '../objects/PathFinder.js';\nimport { ZOMBIE_SPEED, ZOMBIE_ROTATING_SPEED, MIN_DISTANCE_TO_TARGET } from '../constants/ZombieConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { tileToPixels, getWallsPostions } from '../utils/MapUtils.js';\n\n/** Create Entity that is supposed to walk on given path. Set position of entity on first given target*/\nexport default class EntityWalkingOnPath extends Entity {\n  constructor( game, imageKey, frame, targets, walls ) {\n    const position = tileToPixels( targets[ 0 ] );\n\n    super( game, position.x, position.y, imageKey, frame );\n\n    this.pathfinder = new PathFinder();\n    this.wallsPositions = getWallsPostions( walls );\n\n    this.pathfinder.setGrid( this.wallsPositions );\n\n    this.targets = targets;\n\n    this.pathsBetweenPathTargets = [];\n\n    this.currentPathIndex = 0;\n    this.currentStepIndex = 0;\n\n    this.isOnStandardPath = true;\n    this.temporaryPath = [];\n    this.temporaryStepIndex = 0;\n\n    /* disable update until paths are calculated */\n    this.isInitialized = false;\n    this.canMove = false;\n\n    this.calculatePathsBetweenTargets( () => {\n      this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n      this.isInitialized = true;\n      this.canMove = true;\n    } );\n  }\n  /**Recursive function that calculates standard paths and save them into pathsBetweenPathTargets container.  Recurse approach is used to handle asynchronous nature of findPath method */\n  calculatePathsBetweenTargets( doneCallback, index = 0 ) {\n    if ( this.pathsBetweenPathTargets.length === this.targets.length ) {\n      doneCallback();\n      return;\n    }\n\n    const start = this.targets[ index ];\n    const target = ( index === this.targets.length - 1 ) ? this.targets[ 0 ] : this.targets[ index + 1 ];\n\n    this.pathfinder.findPath( start.x, start.y, target.x, target.y, ( path ) => {\n      this.pathsBetweenPathTargets.push( { path, start, target } );\n      this.calculatePathsBetweenTargets( doneCallback, index + 1 );\n    } );\n  }\n  update() {\n    /** Check if current target or step target is reached. Move body in stepTarget direction. */\n    if ( this.canMove ) {\n      if ( this.isReached( this.stepTarget ) ) {\n        this.onStepTargetReach();\n      }\n      this.game.physics.arcade.moveToObject( this, tileToPixels( this.stepTarget ), ZOMBIE_SPEED );\n\n      this.updateLookDirection();\n    }\n  }\n  /** When current step target or temporary step target is reached, set step target to the next one.*/\n  /** If current target is reached or temporary target is reached set path to the next one, or get back to standard path*/\n  onStepTargetReach() {\n    if ( this.isOnStandardPath ) {\n      if ( this.currentStepIndex + 1 === this.pathsBetweenPathTargets[ this.currentPathIndex ].path.length ) {\n        this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenPathTargets.length ) ? 0 : this.currentPathIndex + 1;\n        this.currentStepIndex = 0;\n      } else {\n        this.currentStepIndex++;\n      }\n      this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n    } else {\n      if ( this.temporaryStepIndex + 1 === this.temporaryPath.length ) {\n        this.changePathToStandard();\n      } else {\n        this.temporaryStepIndex++;\n        this.stepTarget = this.temporaryPath[ this.temporaryStepIndex ];\n      }\n    }\n  }\n  updateLookDirection() {\n    //TODO make target point be the end of target tile\n    const lookTarget = this.getTilesEndCoords( this.stepTarget );\n    const targetPoint = new Phaser.Point( lookTarget.x, lookTarget.y );\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\n\n    let deltaTargetRad = this.rotation - Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) - 1.5 * Math.PI;\n\n    deltaTargetRad = deltaTargetRad % ( Math.PI * 2 );\n\n    if ( deltaTargetRad != deltaTargetRad % ( Math.PI ) ) {\n      deltaTargetRad = deltaTargetRad + Math.PI * ( ( deltaTargetRad < 0 ) ? 2 : -2 );\n    }\n\n    this.body.rotateLeft( ZOMBIE_ROTATING_SPEED * deltaTargetRad );\n  }\n  getTilesEndCoords( tile ) {\n    const tileCoords = tileToPixels( tile );\n    if ( Math.abs( this.body.velocity.x ) > Math.abs( this.body.velocity.y ) ) {\n      if ( this.body.velocity.x > 0 ) {\n        tileCoords.x += 1000 * TILE_WIDTH;\n      } else {\n        tileCoords.x -= 1000 * TILE_WIDTH;\n      }\n    } else if ( Math.abs( this.body.velocity.x ) < Math.abs( this.body.velocity.y ) ) {\n      if ( this.body.velocity.y > 0 ) {\n        tileCoords.y += 1000 * TILE_HEIGHT;\n      } else {\n        tileCoords.y -= 1000 * TILE_HEIGHT;\n      }\n    }\n\n    return tileCoords;\n  }\n  isReached( target ) {\n    const distanceToTarget = this.game.physics.arcade.distanceBetween( this, tileToPixels( target ) );\n    return distanceToTarget <= MIN_DISTANCE_TO_TARGET;\n  }\n  calculateTemporaryPath( start, target, callback ) {\n    this.pathfinder.findPath( start.x, start.y, target.x, target.y, callback );\n  }\n  /**\n  * Change path to temporary and automatically get back to standard path, after reaching temporary target.\n  * @param {tile} start - start tile coordinates, if this tile is different that entity's tile then it goes straight to this tile.\n  */\n  changePathToTemporary( start ) {\n    const currentTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].target;\n\n    this.canMove = false;\n    this.calculateTemporaryPath( start, currentTarget, ( path ) => {\n      if ( path.length === 0 ) {\n        this.changePathToStandard();\n        return;\n      }\n      this.temporaryPath = path;\n      this.temporaryStepIndex = 0;\n      this.stepTarget = path[ this.temporaryStepIndex ];\n      this.isOnStandardPath = false;\n      this.canMove = true;\n    } );\n  }\n  changePathToStandard() {\n    this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenPathTargets.length ) ? 0 : this.currentPathIndex + 1;\n    this.currentStepIndex = 0;\n    this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n    this.isOnStandardPath = true;\n  }\n  disableMovement() {\n    this.canMove = false;\n    this.resetVelocity();\n  }\n  enableMovement() {\n    this.canMove = true;\n  }\n}\n",
    "import EasyStar from 'easystarjs';\n\nexport default class PathFinder {\n  constructor( ) {\n    this.easystar = new EasyStar.js();\n\n    this.easystar.setAcceptableTiles( [ 0 ] );\n  }\n  setGrid( grid ) {\n    this.easystar.setGrid( grid );\n  }\n  findPath( startX, startY, endX, endY, callback ) {\n    this.easystar.findPath( startX, startY, endX, endY, callback );\n    this.easystar.calculate();\n  }\n}\n",
    "import Entity from './Entity';\nimport { PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_SPEED, PLAYER_SNEAK_MULTIPLIER, PLAYER_SPRINT_MULTIPLIER, PLAYER_WALK_ANIMATION_FRAMERATE, PLAYER_FIGHT_ANIMATION_FRAMERATE } from '../constants/PlayerConstants';\n\nexport default class Player extends Entity {\n  constructor( game, x, y, imageKey, frame ) {\n    super( game, x, y, imageKey, frame );\n\n    this.width = PLAYER_WIDTH;\n    this.height = PLAYER_HEIGHT;\n\n    this.isSneaking = false;\n    this.isSprinting = false;\n\n    this.cursors = {\n      up: this.game.input.keyboard.addKey( Phaser.Keyboard.W ),\n      down: this.game.input.keyboard.addKey( Phaser.Keyboard.S ),\n      left: this.game.input.keyboard.addKey( Phaser.Keyboard.A ),\n      right: this.game.input.keyboard.addKey( Phaser.Keyboard.D ),\n      sneak: this.game.input.keyboard.addKey( Phaser.Keyboard.ALT ),\n      sprint: this.game.input.keyboard.addKey( Phaser.Keyboard.SHIFT ),\n    };\n\n    this.animations.add( 'walk', [ 1, 2, 1, 0 ], 1 );\n    this.animations.add( 'fight', [ 3, 5, 4 ], 3 );\n\n    this.body.addCircle( Math.max( PLAYER_WIDTH, PLAYER_HEIGHT ) );\n  }\n  update() {\n    this.handleMovement();\n    this.handleAnimation();\n    this.lookAtMouse();\n  }\n  handleMovement() {\n    this.resetVelocity();\n\n    if ( this.cursors.up.isDown ) {\n      this.body.velocity.y = -PLAYER_SPEED;\n    } else if ( this.cursors.down.isDown ) {\n      this.body.velocity.y = PLAYER_SPEED;\n    }\n\n    if ( this.cursors.left.isDown ) {\n      this.body.velocity.x = -PLAYER_SPEED;\n    } else if ( this.cursors.right.isDown ) {\n      this.body.velocity.x = PLAYER_SPEED;\n    }\n\n    this.handleMovementSpecialModes();\n\n    this.normalizeVelocity();\n  }\n  handleMovementSpecialModes() {\n    let specialEffectMultiplier = 1;\n\n    this.isSneaking = false;\n    this.isSprinting = false;\n\n    if ( this.cursors.sneak.isDown ) {\n      specialEffectMultiplier = PLAYER_SNEAK_MULTIPLIER;\n      this.isSneaking = true;\n    } else if ( this.cursors.sprint.isDown ) {\n      specialEffectMultiplier = PLAYER_SPRINT_MULTIPLIER;\n      this.isSprinting = true;\n    }\n\n    this.body.velocity.x *= specialEffectMultiplier;\n    this.body.velocity.y *= specialEffectMultiplier;\n  }\n  handleAnimation() {\n    if ( this.body.velocity.x !== 0 || this.body.velocity.y !== 0 ) {\n      this.animations.play( 'walk', PLAYER_WALK_ANIMATION_FRAMERATE, true );\n    } else {\n      this.animations.stop( 'walk', true );\n    }\n    if ( this.game.input.activePointer.leftButton.isDown ) {\n      this.animations.play( 'fight', PLAYER_FIGHT_ANIMATION_FRAMERATE, false );\n    }\n  }\n  lookAtMouse() {\n    const mouseX = this.game.input.mousePointer.worldX;\n    const mouseY = this.game.input.mousePointer.worldY;\n\n    this.lookAt( mouseX, mouseY );\n  }\n\n}\n",
    "import { pixelsToTile } from '../utils/MapUtils.js';\n\nexport default class TileMap extends Phaser.Tilemap {\n  constructor( game, key, tileWidth, tileHeight ) {\n    super( game, key, tileWidth, tileHeight );\n\n    this.addTilesetImage( 'tilemap' );\n\n    this.ground = this.createLayer( 'background' );\n    this.walls = this.createLayer( 'walls' );\n\n    this.paths = [];\n\n    this.setCollisionByExclusion( [], true, this.walls );\n\n    this.ground.resizeWorld();\n\n    this.wallsBodiesArray = game.physics.p2.convertTilemap( this, this.walls );\n\n    this.wallsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n\n    for ( const body of this.wallsBodiesArray ) {\n      body.setCollisionGroup( this.wallsCollisionGroup );\n    }\n\n    this.createPathPoints();\n  }\n  collides( collisionGroup, callback ) {\n    for ( const body of this.wallsBodiesArray ) {\n      body.collides( collisionGroup, callback );\n    }\n  }\n  createPathPoints() {\n    this.objects[ 'ZombiePaths' ].forEach( ( v ) => {\n      const props = v.properties;\n      if ( !this.paths[ props.PathId ] ) {\n        this.paths[ props.PathId ] = [];\n      }\n\n      this.paths[ props.PathId ][ props.PathIndex ] = pixelsToTile( { x: v.x, y: v.y } );\n    } );\n\n    this.normalizePaths();\n  }\n  normalizePaths() {\n    this.paths.forEach( ( pathArr ) => {\n      const tempArr = [];\n      pathArr.forEach( ( v ) => {\n        tempArr.push( v );\n      } );\n\n      pathArr = tempArr;\n    } );\n  }\n  getPath( i ) {\n    return this.paths[ i ];\n  }\n}\n",
    "import { willEntitiesBeOnTheSameTile, getFreeTileAroundEntityExcludingOtherEntity } from '../utils/EntityManagerUtils';\nimport { pixelsToTile, getWallsPostions } from '../utils/MapUtils.js';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\n\nexport default class WalkingEntitiesManager extends Phaser.Group {\n  constructor( game, grid ) {\n    super( game );\n    this.mapGrid = getWallsPostions( grid );\n    this.allEntitiesInitialized = false;\n  }\n  update() {\n    if ( this.allEntitiesInitialized || this.areAllEntitiesInitialized() ) {\n      this.manageMovingEntities();\n    }\n\n    Phaser.Group.prototype.update.call( this );\n  }\n  manageMovingEntities() {\n    for ( const entityIndex1 in this.children ) {\n      for ( const entityIndex2 in this.children ) {\n        if ( entityIndex1 === entityIndex2 ) {\n          continue;\n        }\n        const currentHandledEntity = this.children[ Math.min( entityIndex1, entityIndex2 ) ];\n        const otherEntity = this.children[ Math.max( entityIndex1, entityIndex2 ) ];\n\n        if ( currentHandledEntity.canMove && otherEntity.canMove && willEntitiesBeOnTheSameTile( currentHandledEntity, otherEntity ) ) {\n          const freeTile = getFreeTileAroundEntityExcludingOtherEntity( currentHandledEntity, otherEntity, this.mapGrid );\n          const currentTarget = currentHandledEntity.pathsBetweenPathTargets[ currentHandledEntity.currentPathIndex ].target;\n\n          currentHandledEntity.changePathToTemporary( freeTile, currentTarget );\n        }\n      }\n    }\n  }\n  onCollisionWihOtherEntity( entity1, entity2 ) {\n    const freeTile1 = getFreeTileAroundEntityExcludingOtherEntity( entity1, entity2, this.mapGrid );\n    const freeTile2 = getFreeTileAroundEntityExcludingOtherEntity( entity2, entity1, this.mapGrid );\n\n    entity1.changePathToTemporary( freeTile1 );\n    entity1.changePathToTemporary( freeTile2 );\n  }\n  onCollisionWithWalls( entity, tileBody ) {\n    const entityTile = pixelsToTile( entity );\n    const tile = pixelsToTile( { x: tileBody.x + TILE_WIDTH / 2, y: tileBody.y + TILE_HEIGHT / 2 } );\n    let freeTile;\n\n    if ( entityTile.x > tile.x ) {\n      freeTile = { x: entityTile.x + 1, y: entityTile.y };\n    } else if ( entityTile.x < tile.x ) {\n      freeTile = { x: entityTile.x - 1, y: entityTile.y };\n    } else if ( entityTile.y < tile.y ) {\n      freeTile = { x: entityTile.x, y: entityTile.y - 1 };\n    } else if ( entityTile.y > tile.y ) {\n      freeTile = { x: entityTile.x, y: entityTile.y + 1 };\n    }\n\n    entity.changePathToTemporary( freeTile );\n  }\n  areAllEntitiesInitialized() {\n    for ( const entity of this.children ) {\n      if ( !entity.isInitialized ) {\n        return false;\n      }\n    }\n    this.allEntitiesInitialized = true;\n    return true;\n  }\n}\n",
    "import EntityWalkingOnPath from './EntityWalkingOnPath';\nimport { ZOMBIE_SPEED, MIN_DISTANCE_TO_TARGET, ZOMBIE_SPEED_CHASING_MULTIPLIER, ZOMBIE_SIGHT_ANGLE, ZOMBIE_SIGHT_RANGE, ZOMBIE_HEARING_RANGE } from '../constants/ZombieConstants';\nimport { pixelsToTile } from '../utils/MapUtils.js';\n\nexport default class Zombie extends EntityWalkingOnPath {\n  constructor( game, imageKey, frame, targets, walls, player ) {\n    super( game, imageKey, frame, targets, walls );\n\n    this.player = player;\n    this.walls = walls;\n    this.playerSeekingRay = new Phaser.Line();\n    this.tileHits = [];\n    this.isChasing = false;\n    this.lastKnownPlayerPosition = { x: 1, y: 1 };\n  }\n  update() {\n    if ( this.canSeePlayer() ) {\n      this.isChasing = true;\n      this.lastKnownPlayerPosition = { x: this.player.x, y: this.player.y };\n    }\n\n    if ( !this.isChasing ) {\n      EntityWalkingOnPath.prototype.update.call( this );\n    } else {\n      this.chasePlayer();\n    }\n  }\n  canSeePlayer() {\n    /** Draw line between player and zombie and check if it can see him. If yes, chase him. */\n    this.playerSeekingRay.start.set( this.x, this.y );\n    this.playerSeekingRay.end.set( this.player.x, this.player.y );\n\n    this.tileHits = this.walls.getRayCastTiles( this.playerSeekingRay, 0, false, false );\n\n    if ( this.tileHits.length > 0 ) {\n      for ( let i = 0; i < this.tileHits.length; i++ ) {\n        if ( this.tileHits[ i ].index >= 0 ) {\n          return false;\n        }\n      }\n    }\n\n    const angleDelta = Math.abs( Phaser.Math.radToDeg( Phaser.Math.angleBetween( this.x, this.y, this.player.x, this.player.y ) ) + 90 - this.angle );\n\n    return ( ( angleDelta <= ZOMBIE_SIGHT_ANGLE || angleDelta >= ( 360 - ZOMBIE_SIGHT_ANGLE ) ) && ( this.isChasing || this.playerSeekingRay.length < ZOMBIE_SIGHT_RANGE ) ) || ( this.playerSeekingRay.length < ZOMBIE_HEARING_RANGE && !this.player.isSneaking && this.player.isMoving() );\n  }\n  chasePlayer() {\n    this.game.physics.arcade.moveToObject( this, this.lastKnownPlayerPosition, ZOMBIE_SPEED * ZOMBIE_SPEED_CHASING_MULTIPLIER );\n    this.lookAt( this.lastKnownPlayerPosition.x, this.lastKnownPlayerPosition.y );\n\n    const distanceToTarget = this.game.physics.arcade.distanceBetween( this, this.lastKnownPlayerPosition );\n    if ( !this.canSeePlayer() && ( distanceToTarget <= MIN_DISTANCE_TO_TARGET ) ) {\n      this.body.velocity.x = 0;\n      this.body.velocity.y = 0;\n      this.isChasing = false;\n      this.changePathToTemporary( pixelsToTile( this ) );\n    }\n  }\n\n}\n",
    "import WalkingEntitiesManager from '../objects/WalkingEntitiesManager';\n\nexport default class ZombieManager extends WalkingEntitiesManager {\n  constructor( game, grid ) {\n    super( game, grid );\n  }\n\n  update() {\n    WalkingEntitiesManager.prototype.update.call( this );\n  }\n\n}\n",
    "class Boot extends Phaser.State {\n  preload() {\n  }\n  create() {\n    // this.game.stage.disableVisibilityChange = true;\n\n    // this.game.scale.maxWidth = 800;\n    // this.game.scale.maxHeight = 600;\n\n    this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n    this.game.scale.updateLayout();\n\n    this.game.physics.startSystem( Phaser.Physics.P2JS );\n    this.game.physics.p2.setImpactEvents( true );\n    this.state.start( 'Preload' );\n  }\n}\n\nexport default Boot;\n",
    "import Player from '../objects/Player';\nimport Zombie from '../objects/Zombie';\nimport TileMap from '../objects/TileMap';\nimport ZombiesManager from '../objects/ZombiesManager';\n\nimport { PLAYER_INITIAL_FRAME } from '../constants/PlayerConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\n\nexport default class Game extends Phaser.State {\n  create() {\n    this.map = new TileMap( this.game, 'map', 64, 64 );\n\n    this.player = new Player( this.game, 10 * TILE_WIDTH + TILE_WIDTH / 2, 2 * TILE_HEIGHT + TILE_HEIGHT / 2, 'player', PLAYER_INITIAL_FRAME );\n    this.game.camera.follow( this.player );\n\n    //  Create our collision groups. One for the player, one for the pandas\n    this.playerCollisionGroup = this.game.physics.p2.createCollisionGroup( this.player );\n    this.zombiesCollisionGroup = this.game.physics.p2.createCollisionGroup();\n\n    this.zombies = new ZombiesManager( this.game, this.map.walls );\n    for ( let i = 0; i < this.map.paths.length; i++ ) {\n      const newZombie = this.zombies.add( new Zombie( this.game, 'zombie', PLAYER_INITIAL_FRAME, this.map.getPath( i ), this.map.walls, this.player ) );\n\n      newZombie.body.setCollisionGroup( this.zombiesCollisionGroup );\n      newZombie.body.collides( this.zombiesCollisionGroup, ( body1, body2 ) => this.zombies.onCollisionWihOtherEntity( body1.sprite, body2.sprite ) );\n      newZombie.body.collides( this.map.wallsCollisionGroup, ( body, tileBody ) => this.zombies.onCollisionWithWalls( body.sprite, tileBody ) );\n      newZombie.body.collides( this.playerCollisionGroup );\n    }\n    this.player.body.collides( [ this.zombiesCollisionGroup, this.map.wallsCollisionGroup ] );\n\n    this.map.collides( this.zombiesCollisionGroup );\n    this.map.collides( this.playerCollisionGroup );\n  }\n  update() {\n  }\n}\n",
    "class Menu extends Phaser.State {\n  create() {\n    this.state.start( 'Game' );\n  }\n}\n\nexport default Menu;\n",
    "import { PLAYER_WIDTH, PLAYER_HEIGHT } from '../constants/PlayerConstants.js';\nimport { ZOMBIE_WIDTH, ZOMBIE_HEIGHT } from '../constants/ZombieConstants.js';\n\nclass Preload extends Phaser.State {\n  preload() {\n    this.load.tilemap( 'map', 'assets/tilemaps/maps/map.json', null, Phaser.Tilemap.TILED_JSON );\n    this.load.image( 'tilemap', 'assets/tilemaps/tiles/tilemap.png' );\n\n    this.game.load.spritesheet( 'player', './assets/images/player-sheet.png', PLAYER_WIDTH, PLAYER_HEIGHT );\n    this.game.load.spritesheet( 'zombie', './assets/images/zombie-sheet.png', ZOMBIE_WIDTH, ZOMBIE_HEIGHT );\n  }\n  create() {\n    this.state.start( 'Menu' );\n  }\n}\n\nexport default Preload;\n",
    "import { pixelsToTile } from '../utils/MapUtils';\n\nexport const getEntityNextTile = ( entity ) => {\n  if ( entity.isOnStandardPath ) {\n    let pathIndex = entity.currentPathIndex;\n    let stepIndex = entity.currentStepIndex;\n\n    if ( entity.pathsBetweenPathTargets[ pathIndex ].path.length === stepIndex + 1 ) {\n      stepIndex = 0;\n\n      if ( entity.pathsBetweenPathTargets.length === pathIndex + 1 ) {\n        pathIndex = 0;\n      } else {\n        pathIndex++;\n      }\n    } else {\n      stepIndex++;\n    }\n    if ( entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ] == undefined ) {\n      throw new Error( `Wrong path data: pathIndex: ${pathIndex}, stepIndex: ${stepIndex}, entity: ${entity}` );\n    }\n    return entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ];\n  } else {\n    let stepIndex = entity.temporaryStepIndex;\n    if ( stepIndex + 1 === entity.temporaryPath.length ) {\n      stepIndex = 0;\n      let pathIndex = ( entity.currentPathIndex + 1 === entity.pathsBetweenPathTargets.length ) ? 0 : entity.currentPathIndex + 1;\n      if ( entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ] == undefined ) {\n        throw new Error( `Wrong path data: pathIndex: ${pathIndex}, stepIndex: ${stepIndex}, entity: ${entity}` );\n      }\n      return entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ];\n    } else {\n      if ( entity.temporaryPath[ stepIndex ] == undefined ) {\n        throw new Error( `Wrong temporary path data: stepIndex: ${stepIndex}` );\n      }\n      return entity.temporaryPath[ stepIndex ];\n    }\n  }\n};\n\nconst areTilesTheSame = ( tile1, tile2 ) => tile1.x === tile2.x && tile1.y === tile2.y;\n\nexport const getEntityCurrentStepTarget = ( entity ) => ( entity.isOnStandardPath ) ? entity.pathsBetweenPathTargets[ entity.currentPathIndex ].path[ entity.currentStepIndex ] : entity.temporaryPath[ entity.temporaryStepIndex ];\n\nexport const willEntitiesBeOnTheSameTile = ( entity1, entity2 ) => {\n  const entityNextTarget1 = getEntityNextTile( entity1 );\n  const entityNextTarget2 = getEntityNextTile( entity2 );\n  const entityCurrentTarget1 = getEntityCurrentStepTarget( entity1 );\n  const entityCurrentTarget2 = getEntityCurrentStepTarget( entity2 );\n\n  return areTilesTheSame( entityNextTarget1, entityNextTarget2 )\n  || areTilesTheSame( entityNextTarget1, entityCurrentTarget2 )\n   || areTilesTheSame( entityCurrentTarget1, entityCurrentTarget2 );\n};\n\nconst getDirectionBetweenTiles = ( tile1, tile2 ) => {\n  if ( tile1.y === tile2.y ) {\n    if ( tile1.x > tile2.x ) {\n      return 'WEST';\n    } else if ( tile1.x < tile2.x ) {\n      return 'EAST';\n    } else {\n      throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n    }\n  } else if ( tile1.x === tile2.x ) {\n    if ( tile1.y > tile2.y ) {\n      return 'NORTH';\n    } else if ( tile1.y < tile2.y ) {\n      return 'SOUTH';\n    } else {\n      throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n    }\n  } else {\n    if ( tile1.y < tile2.y && tile1.x < tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'SOUTH' : 'EAST';\n    } else if ( tile1.y > tile2.y && tile1.x < tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'NORTH' : 'EAST';\n    } else if ( tile1.y < tile2.y && tile1.x > tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'NORTH' : 'WEST';\n    } else if ( tile1.y > tile2.y && tile1.x > tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'SOUTH' : 'WEST';\n    }\n  }\n  throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n};\n\nconst getDirectionBetweenEntities = ( entity1, entity2 ) => {\n  const entityTile1 = pixelsToTile( entity1 );\n  const entityTile2 = pixelsToTile( entity2 );\n\n  if ( areTilesTheSame( entityTile1, entityTile2 ) ) {\n    console.warn( 'Doing somethink untested: ' );\n    return getDirectionBetweenTiles( entity1, entity2 );\n  } else {\n    return getDirectionBetweenTiles( entityTile1, entityTile2 );\n  }\n};\n\nexport const getFreeTileAroundEntityExcludingOtherEntity = ( entity, entityToExclude, mapGrid ) => {\n  const entityTile = pixelsToTile( entity );\n  const tileToExclude = getEntityNextTile( entityToExclude );\n\n  let directionToExclude;\n\n  if ( ( entityTile.x === tileToExclude.x && entityTile.y === tileToExclude.y ) || ( entityTile.x !== tileToExclude.x && entityTile.y !== tileToExclude.y ) ) {\n    directionToExclude = getDirectionBetweenEntities( entity, entityToExclude );\n  } else {\n    directionToExclude = getDirectionBetweenTiles( entityTile, tileToExclude );\n  }\n\n  switch ( directionToExclude ) {\n  case 'NORTH':\n    return getFreeTileExcludingNorth( entityTile, mapGrid );\n  case 'SOUTH':\n    return getFreeTileExcludingSouth( entityTile, mapGrid );\n  case 'WEST':\n    return getFreeTileExcludingWest( entityTile, mapGrid );\n  case 'EAST':\n    return getFreeTileExcludingEast( entityTile, mapGrid );\n  }\n\n  throw new Error( `Couldn't find free tile entityTile: ${entityTile}, directionToExclude: ${directionToExclude}` );\n};\n\nfunction getFreeTileExcludingNorth( entityTile, mapGrid ) {\n  let freeTile = { x: -1, y: entityTile.y };\n  if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 && mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = ( Math.random() > 0.5 ) ? entityTile.x - 1 : entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x - 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile = { x: entityTile.x, y: entityTile.y + 1 };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingSouth( entityTile, mapGrid ) {\n  let freeTile = { x: -1, y: entityTile.y };\n  if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 && mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = ( Math.random() > 0.5 ) ? entityTile.x - 1 : entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x - 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile = { x: entityTile.x, y: entityTile.y - 1 };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingWest( entityTile, mapGrid ) {\n  let freeTile = { x: entityTile.x, y: -1 };\n  if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 && mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = ( Math.random() > 0.5 ) ? entityTile.y - 1 : entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile.y = entityTile.y - 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile = { x: entityTile.x + 1, y: entityTile.y };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingEast( entityTile, mapGrid ) {\n  let freeTile = { x: entityTile.x, y: -1 };\n  if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 && mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = ( Math.random() > 0.5 ) ? entityTile.y - 1 : entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile.y = entityTile.y - 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile = { x: entityTile.x - 1, y: entityTile.y };\n  }\n  return freeTile;\n}\n",
    "import { TILE_WIDTH, TILE_HEIGHT, MAP_WIDTH } from '../constants/TileMapConstants';\n\nexport const pixelsToTileX = ( coord ) => Math.floor( coord / TILE_WIDTH );\nexport const pixelsToTileY = ( coord ) => Math.floor( coord / TILE_HEIGHT );\n\nexport const tileToPixels = ( tile ) => ( {\n  x: ( tile.x * TILE_WIDTH ) + TILE_WIDTH / 2,\n  y: ( tile.y * TILE_HEIGHT ) + TILE_HEIGHT / 2,\n} );\n\nexport const pixelsToTile = ( coords ) => ( {\n  x: Math.floor( coords.x / TILE_WIDTH ),\n  y: Math.floor( coords.y / TILE_HEIGHT ),\n} );\n\nexport const getWallsPostions = ( layer ) => {\n  const walls = layer.getTiles( 0, 0, 2048, 2048 );\n  const wallsArr = [];\n\n  let currentY = [];\n\n  walls.forEach( ( v, i ) => {\n    if ( v.index !== -1 ) {\n      currentY.push( 1 );\n    } else {\n      currentY.push( 0 );\n    }\n\n    if ( i % MAP_WIDTH === ( MAP_WIDTH - 1 ) ) {\n      wallsArr.push( currentY );\n      currentY = [];\n    }\n  } );\n\n  return wallsArr;\n};\n"
  ]
}