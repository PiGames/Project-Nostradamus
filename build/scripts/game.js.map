{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/easystarjs/src/easystar.js",
    "node_modules/easystarjs/src/instance.js",
    "node_modules/easystarjs/src/node.js",
    "node_modules/heap/index.js",
    "node_modules/heap/lib/heap.js",
    "src/ProjectNostradamus.js",
    "src/constants/ItemConstants.js",
    "src/constants/PlayerConstants.js",
    "src/constants/TileMapConstants.js",
    "src/constants/ZombieConstants.js",
    "src/index.js",
    "src/objects/BoidsManager.js",
    "src/objects/Entity.js",
    "src/objects/EntityWalkingOnPath.js",
    "src/objects/Journal.js",
    "src/objects/JournalsManager.js",
    "src/objects/PathFinder.js",
    "src/objects/Player.js",
    "src/objects/TileMap.js",
    "src/objects/WalkingEntitiesManager.js",
    "src/objects/Zombie.js",
    "src/objects/ZombiesManager.js",
    "src/states/Boot.js",
    "src/states/Game.js",
    "src/states/Menu.js",
    "src/states/Preload.js",
    "src/utils/EntityManagerUtils.js",
    "src/utils/MapUtils.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvXA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;I,AAEM;gCACJ;;8B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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/**\n*   EasyStar.js\n*   github.com/prettymuchbryce/EasyStarJS\n*   Licensed under the MIT license.\n*\n*   Implementation By Bryce Neal (@prettymuchbryce)\n**/\n\nvar EasyStar = {}\nvar Instance = require('./instance');\nvar Node = require('./node');\nvar Heap = require('heap');\n\nconst CLOSED_LIST = 0;\nconst OPEN_LIST = 1;\n\nmodule.exports = EasyStar;\n\nEasyStar.js = function() {\n    var STRAIGHT_COST = 1.0;\n    var DIAGONAL_COST = 1.4;\n    var syncEnabled = false;\n    var pointsToAvoid = {};\n    var collisionGrid;\n    var costMap = {};\n    var pointsToCost = {};\n    var directionalConditions = {};\n    var allowCornerCutting = true;\n    var iterationsSoFar;\n    var instances = [];\n    var iterationsPerCalculation = Number.MAX_VALUE;\n    var acceptableTiles;\n    var diagonalsEnabled = false;\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array|Number} tiles An array of numbers that represent\n    * which tiles in your grid should be considered\n    * acceptable, or \"walkable\".\n    **/\n    this.setAcceptableTiles = function(tiles) {\n        if (tiles instanceof Array) {\n            // Array\n            acceptableTiles = tiles;\n        } else if (!isNaN(parseFloat(tiles)) && isFinite(tiles)) {\n            // Number\n            acceptableTiles = [tiles];\n        }\n    };\n\n    /**\n    * Enables sync mode for this EasyStar instance..\n    * if you're into that sort of thing.\n    **/\n    this.enableSync = function() {\n        syncEnabled = true;\n    };\n\n    /**\n    * Disables sync mode for this EasyStar instance.\n    **/\n    this.disableSync = function() {\n        syncEnabled = false;\n    };\n\n    /**\n     * Enable diagonal pathfinding.\n     */\n    this.enableDiagonals = function() {\n        diagonalsEnabled = true;\n    }\n\n    /**\n     * Disable diagonal pathfinding.\n     */\n    this.disableDiagonals = function() {\n        diagonalsEnabled = false;\n    }\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array} grid The collision grid that this EasyStar instance will read from.\n    * This should be a 2D Array of Numbers.\n    **/\n    this.setGrid = function(grid) {\n        collisionGrid = grid;\n\n        //Setup cost map\n        for (var y = 0; y < collisionGrid.length; y++) {\n            for (var x = 0; x < collisionGrid[0].length; x++) {\n                if (!costMap[collisionGrid[y][x]]) {\n                    costMap[collisionGrid[y][x]] = 1\n                }\n            }\n        }\n    };\n\n    /**\n    * Sets the tile cost for a particular tile type.\n    *\n    * @param {Number} The tile type to set the cost for.\n    * @param {Number} The multiplicative cost associated with the given tile.\n    **/\n    this.setTileCost = function(tileType, cost) {\n        costMap[tileType] = cost;\n    };\n\n    /**\n    * Sets the an additional cost for a particular point.\n    * Overrides the cost from setTileCost.\n    *\n    * @param {Number} x The x value of the point to cost.\n    * @param {Number} y The y value of the point to cost.\n    * @param {Number} The multiplicative cost associated with the given point.\n    **/\n    this.setAdditionalPointCost = function(x, y, cost) {\n        pointsToCost[x + '_' + y] = cost;\n    };\n\n    /**\n    * Remove the additional cost for a particular point.\n    *\n    * @param {Number} x The x value of the point to stop costing.\n    * @param {Number} y The y value of the point to stop costing.\n    **/\n    this.removeAdditionalPointCost = function(x, y) {\n        delete pointsToCost[x + '_' + y];\n    }\n\n    /**\n    * Remove all additional point costs.\n    **/\n    this.removeAllAdditionalPointCosts = function() {\n        pointsToCost = {};\n    }\n\n    /**\n    * Sets a directional condition on a tile\n    *\n    * @param {Number} x The x value of the point.\n    * @param {Number} y The y value of the point.\n    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access\n    * the tile.\n    **/\n    this.setDirectionalCondition = function(x, y, allowedDirections) {\n        directionalConditions[x + '_' + y] = allowedDirections;\n    };\n\n    /**\n    * Remove all directional conditions\n    **/\n    this.removeAllDirectionalConditions = function() {\n        directionalConditions = {};\n    };\n\n    /**\n    * Sets the number of search iterations per calculation.\n    * A lower number provides a slower result, but more practical if you\n    * have a large tile-map and don't want to block your thread while\n    * finding a path.\n    *\n    * @param {Number} iterations The number of searches to prefrom per calculate() call.\n    **/\n    this.setIterationsPerCalculation = function(iterations) {\n        iterationsPerCalculation = iterations;\n    };\n\n    /**\n    * Avoid a particular point on the grid,\n    * regardless of whether or not it is an acceptable tile.\n    *\n    * @param {Number} x The x value of the point to avoid.\n    * @param {Number} y The y value of the point to avoid.\n    **/\n    this.avoidAdditionalPoint = function(x, y) {\n        pointsToAvoid[x + \"_\" + y] = 1;\n    };\n\n    /**\n    * Stop avoiding a particular point on the grid.\n    *\n    * @param {Number} x The x value of the point to stop avoiding.\n    * @param {Number} y The y value of the point to stop avoiding.\n    **/\n    this.stopAvoidingAdditionalPoint = function(x, y) {\n        delete pointsToAvoid[x + \"_\" + y];\n    };\n\n    /**\n    * Enables corner cutting in diagonal movement.\n    **/\n    this.enableCornerCutting = function() {\n        allowCornerCutting = true;\n    };\n\n    /**\n    * Disables corner cutting in diagonal movement.\n    **/\n    this.disableCornerCutting = function() {\n        allowCornerCutting = false;\n    };\n\n    /**\n    * Stop avoiding all additional points on the grid.\n    **/\n    this.stopAvoidingAllAdditionalPoints = function() {\n        pointsToAvoid = {};\n    };\n\n    /**\n    * Find a path.\n    *\n    * @param {Number} startX The X position of the starting point.\n    * @param {Number} startY The Y position of the starting point.\n    * @param {Number} endX The X position of the ending point.\n    * @param {Number} endY The Y position of the ending point.\n    * @param {Function} callback A function that is called when your path\n    * is found, or no path is found.\n    *\n    **/\n    this.findPath = function(startX, startY, endX, endY, callback) {\n        // Wraps the callback for sync vs async logic\n        var callbackWrapper = function(result) {\n            if (syncEnabled) {\n                callback(result);\n            } else {\n                setTimeout(function() {\n                    callback(result);\n                });\n            }\n        }\n\n        // No acceptable tiles were set\n        if (acceptableTiles === undefined) {\n            throw new Error(\"You can't set a path without first calling setAcceptableTiles() on EasyStar.\");\n        }\n        // No grid was set\n        if (collisionGrid === undefined) {\n            throw new Error(\"You can't set a path without first calling setGrid() on EasyStar.\");\n        }\n\n        // Start or endpoint outside of scope.\n        if (startX < 0 || startY < 0 || endX < 0 || endY < 0 ||\n        startX > collisionGrid[0].length-1 || startY > collisionGrid.length-1 ||\n        endX > collisionGrid[0].length-1 || endY > collisionGrid.length-1) {\n            throw new Error(\"Your start or end point is outside the scope of your grid.\");\n        }\n\n        // Start and end are the same tile.\n        if (startX===endX && startY===endY) {\n            callbackWrapper([]);\n            return;\n        }\n\n        // End point is not an acceptable tile.\n        var endTile = collisionGrid[endY][endX];\n        var isAcceptable = false;\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (endTile === acceptableTiles[i]) {\n                isAcceptable = true;\n                break;\n            }\n        }\n\n        if (isAcceptable === false) {\n            callbackWrapper(null);\n            return;\n        }\n\n        // Create the instance\n        var instance = new Instance();\n        instance.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.bestGuessDistance() - nodeB.bestGuessDistance();\n        });\n        instance.isDoneCalculating = false;\n        instance.nodeHash = {};\n        instance.startX = startX;\n        instance.startY = startY;\n        instance.endX = endX;\n        instance.endY = endY;\n        instance.callback = callbackWrapper;\n\n        instance.openList.push(coordinateToNode(instance, instance.startX,\n            instance.startY, null, STRAIGHT_COST));\n\n        instances.push(instance);\n    };\n\n    /**\n    * This method steps through the A* Algorithm in an attempt to\n    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.\n    * You can change the number of calculations done in a call by using\n    * easystar.setIteratonsPerCalculation().\n    **/\n    this.calculate = function() {\n        if (instances.length === 0 || collisionGrid === undefined || acceptableTiles === undefined) {\n            return;\n        }\n        for (iterationsSoFar = 0; iterationsSoFar < iterationsPerCalculation; iterationsSoFar++) {\n            if (instances.length === 0) {\n                return;\n            }\n\n            if (syncEnabled) {\n                // If this is a sync instance, we want to make sure that it calculates synchronously.\n                iterationsSoFar = 0;\n            }\n\n            // Couldn't find a path.\n            if (instances[0].openList.size() === 0) {\n                var ic = instances[0];\n                ic.callback(null);\n                instances.shift();\n                continue;\n            }\n\n            var searchNode = instances[0].openList.pop();\n\n            // Handles the case where we have found the destination\n            if (instances[0].endX === searchNode.x && instances[0].endY === searchNode.y) {\n                instances[0].isDoneCalculating = true;\n                var path = [];\n                path.push({x: searchNode.x, y: searchNode.y});\n                var parent = searchNode.parent;\n                while (parent!=null) {\n                    path.push({x: parent.x, y:parent.y});\n                    parent = parent.parent;\n                }\n                path.reverse();\n                var ic = instances[0];\n                var ip = path;\n                ic.callback(ip);\n                return\n            }\n\n            var tilesToSearch = [];\n            searchNode.list = CLOSED_LIST;\n\n            if (searchNode.y > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: -1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y-1)});\n            }\n            if (searchNode.x < collisionGrid[0].length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x+1, searchNode.y)});\n            }\n            if (searchNode.y < collisionGrid.length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: 1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y+1)});\n            }\n            if (searchNode.x > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: -1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x-1, searchNode.y)});\n            }\n            if (diagonalsEnabled) {\n                if (searchNode.x > 0 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y+1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x > 0 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y+1)});\n                    }\n                }\n            }\n\n            var isDoneCalculating = false;\n\n            // Search all of the surrounding nodes\n            for (var i = 0; i < tilesToSearch.length; i++) {\n                checkAdjacentNode(tilesToSearch[i].instance, tilesToSearch[i].searchNode,\n                    tilesToSearch[i].x, tilesToSearch[i].y, tilesToSearch[i].cost);\n                if (tilesToSearch[i].instance.isDoneCalculating === true) {\n                    isDoneCalculating = true;\n                    break;\n                }\n            }\n\n            if (isDoneCalculating) {\n                instances.shift();\n                continue;\n            }\n\n        }\n    };\n\n    // Private methods follow\n    var checkAdjacentNode = function(instance, searchNode, x, y, cost) {\n        var adjacentCoordinateX = searchNode.x+x;\n        var adjacentCoordinateY = searchNode.y+y;\n\n        if (pointsToAvoid[adjacentCoordinateX + \"_\" + adjacentCoordinateY] === undefined &&\n            isTileWalkable(collisionGrid, acceptableTiles, adjacentCoordinateX, adjacentCoordinateY, searchNode)) {\n            var node = coordinateToNode(instance, adjacentCoordinateX,\n                adjacentCoordinateY, searchNode, cost);\n\n            if (node.list === undefined) {\n                node.list = OPEN_LIST;\n                instance.openList.push(node);\n            } else if (searchNode.costSoFar + cost < node.costSoFar) {\n                node.costSoFar = searchNode.costSoFar + cost;\n                node.parent = searchNode;\n                instance.openList.updateItem(node);\n            }\n        }\n    };\n\n    // Helpers\n    var isTileWalkable = function(collisionGrid, acceptableTiles, x, y, sourceNode) {\n        if (directionalConditions[x + \"_\" + y]) {\n            var direction = calculateDirection(sourceNode.x - x, sourceNode.y - y)\n            var directionIncluded = function () {\n                for (var i = 0; i < directionalConditions[x + \"_\" + y].length; i++) {\n                    if (directionalConditions[x + \"_\" + y][i] === direction) return true\n                }\n                return false\n            }\n            if (!directionIncluded()) return false\n        }\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (collisionGrid[y][x] === acceptableTiles[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * -1, -1 | 0, -1  | 1, -1\n     * -1,  0 | SOURCE | 1,  0\n     * -1,  1 | 0,  1  | 1,  1\n     */\n    var calculateDirection = function (diffX, diffY) {\n        if (diffX === 0, diffY === -1) return EasyStar.BOTTOM\n        else if (diffX === 1, diffY === -1) return EasyStar.BOTTOM_LEFT\n        else if (diffX === 1, diffY === 0) return EasyStar.LEFT\n        else if (diffX === 1, diffY === 1) return EasyStar.TOP_LEFT\n        else if (diffX === 0, diffY === 1) return EasyStar.TOP\n        else if (diffX === -1, diffY === 1) return EasyStar.TOP_RIGHT\n        else if (diffX === -1, diffY === 0) return EasyStar.RIGHT\n        else if (diffX === -1, diffY === -1) return EasyStar.BOTTOM_RIGHT\n        throw new Error('These differences are not valid: ' + diffX + ', ' + diffY)\n    };\n\n    var getTileCost = function(x, y) {\n        return pointsToCost[x + '_' + y] || costMap[collisionGrid[y][x]]\n    };\n\n    var coordinateToNode = function(instance, x, y, parent, cost) {\n        if (instance.nodeHash[x + \"_\" + y]!==undefined) {\n            return instance.nodeHash[x + \"_\" + y];\n        }\n        var simpleDistanceToTarget = getDistance(x, y, instance.endX, instance.endY);\n        if (parent!==null) {\n            var costSoFar = parent.costSoFar + cost;\n        } else {\n            costSoFar = 0;\n        }\n        var node = new Node(parent,x,y,costSoFar,simpleDistanceToTarget);\n        instance.nodeHash[x + \"_\" + y] = node;\n        return node;\n    };\n\n    var getDistance = function(x1,y1,x2,y2) {\n        if (diagonalsEnabled) {\n            // Octile distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            if (dx < dy) {\n                return DIAGONAL_COST * dx + dy;\n            } else {\n                return DIAGONAL_COST * dy + dx;\n            }\n        } else {\n            // Manhattan distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            return (dx + dy);\n        }\n    };\n}\n\nEasyStar.TOP = 'TOP'\nEasyStar.TOP_RIGHT = 'TOP_RIGHT'\nEasyStar.RIGHT = 'RIGHT'\nEasyStar.BOTTOM_RIGHT = 'BOTTOM_RIGHT'\nEasyStar.BOTTOM = 'BOTTOM'\nEasyStar.BOTTOM_LEFT = 'BOTTOM_LEFT'\nEasyStar.LEFT = 'LEFT'\nEasyStar.TOP_LEFT = 'TOP_LEFT'\n",
    "/**\n * Represents a single instance of EasyStar.\n * A path that is in the queue to eventually be found.\n */\nmodule.exports = function() {\n    this.isDoneCalculating = true;\n    this.pointsToAvoid = {};\n    this.startX;\n    this.callback;\n    this.startY;\n    this.endX;\n    this.endY;\n    this.nodeHash = {};\n    this.openList;\n};",
    "/**\n* A simple Node that represents a single tile on the grid.\n* @param {Object} parent The parent node.\n* @param {Number} x The x position on the grid.\n* @param {Number} y The y position on the grid.\n* @param {Number} costSoFar How far this node is in moves*cost from the start.\n* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.\n**/\nmodule.exports = function(parent, x, y, costSoFar, simpleDistanceToTarget) {\n    this.parent = parent;\n    this.x = x;\n    this.y = y;\n    this.costSoFar = costSoFar;\n    this.simpleDistanceToTarget = simpleDistanceToTarget;\n\n    /**\n    * @return {Number} Best guess distance of a cost using this node.\n    **/\n    this.bestGuessDistance = function() {\n        return this.costSoFar + this.simpleDistanceToTarget;\n    }\n};",
    "module.exports = require('./lib/heap');\n",
    "// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n",
    "import Boot from './states/Boot';\nimport Preload from './states/Preload';\nimport Menu from './states/Menu';\nimport Game from './states/Game';\n\nclass ProjectNostradamus extends Phaser.Game {\n  constructor( width, height, renderer, parent ) {\n    super( width, height, renderer, parent );\n    this.state.add( 'Preload', Preload );\n    this.state.add( 'Boot', Boot );\n    this.state.add( 'Preload', Preload );\n    this.state.add( 'Menu', Menu );\n    this.state.add( 'Game', Game );\n\n    this.state.start( 'Boot' );\n  }\n}\nexport default ProjectNostradamus;\n",
    "export const COMPUTER_WIDTH = 32;\nexport const COMPUTER_HEIGHT = 39;\nexport const JOURNAL_TEXT_FIELD_WIDTH = 544;\nexport const JOURNAL_TEXT_FIELD_HEIGHT = 344;\nexport const JOURNAL_TEXT_SCROLL_STEP = 32;\nexport const JOURNAL_TEXT_FONT_SIZE = 16;\n",
    "export const PLAYER_WIDTH = 29;\nexport const PLAYER_HEIGHT = 31;\nexport const PLAYER_INITIAL_FRAME = 1;\nexport const PLAYER_SPEED = 120;\nexport const PLAYER_SNEAK_MULTIPLIER = 0.25;\nexport const PLAYER_SPRINT_MULTIPLIER = 1.5;\nexport const PLAYER_WALK_ANIMATION_FRAMERATE = 7;\nexport const PLAYER_FIGHT_ANIMATION_FRAMERATE = 10;\nexport const PLAYER_HAND_ATTACK_RANGE = 50;\nexport const PLAYER_HAND_ATTACK_ANGLE = 60;\nexport const PLAYER_HAND_ATTACK_DAMAGE = 0.2;\n",
    "export const TILE_WIDTH = 64;\nexport const TILE_HEIGHT = 64;\nexport const MAP_WIDTH = 32;\nexport const MAP_HEIGHT = 32;\n",
    "export const ZOMBIE_WIDTH = 36;\nexport const ZOMBIE_HEIGHT = 36;\nexport const ZOMBIE_INITIAL_FRAME = 1;\nexport const ZOMBIE_SPEED = 50;\nexport const ZOMBIE_SPEED_CHASING_MULTIPLIER = 2;\nexport const ZOMBIE_LOOKING_OFFSET = 10;\nexport const ZOMBIE_WALK_ANIMATION_FRAMERATE = 6;\nexport const ZOMBIE_FIGHT_ANIMATION_FRAMERATE = 10;\nexport const MIN_DISTANCE_TO_TARGET = 10;\nexport const ZOMBIE_SIGHT_ANGLE = 45;\nexport const ZOMBIE_SIGHT_RANGE = 500;\nexport const ZOMBIE_HEARING_RANGE = 100;\nexport const ZOMBIE_ROTATING_SPEED = 50;\nexport const ZOMBIE_DAMAGE_MULTIPLIER = 1;\nexport const ZOMBIE_DAMAGE_COOLDOWN = 0.2;\n",
    "import ProjectNostradamus from './ProjectNostradamus';\n\nnew ProjectNostradamus( '100%', '100%', Phaser.AUTO, 'content' );\n\n/*\n!!! This is protection against leaving page while still in game. It is commented out since it was driving me crazy that i had to confirm leavinmg every time browsersync fired. !!!\nwindow.onbeforeunload = (e) => {\n  return 'Really want to quit the game?';\n};\n\ndocument.onkeydown = ( e ) => {\n  e = e || window.event;\n  if ( e.ctrlKey ) {\n    const c = e.which || e.keyCode;\n    switch ( c ) {\n    case 83:\n    case 87:\n      e.preventDefault();\n      e.stopPropagation();\n      break;\n    }\n  }\n};\n*/\n",
    "import { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { pixelsToTile, tileToPixels } from '../utils/MapUtils.js';\n\nexport default class BoidsManager {\n  constructor( game, entities, mapGrid, boidsDistance = Math.max( TILE_WIDTH, TILE_HEIGHT ), distanceBetweenBoidsAndWalls = boidsDistance ) {\n    this.entities = entities;\n    this.mapGrid = mapGrid;\n    this.boidsDistance = boidsDistance;\n    this.distanceBetweenBoidsAndWalls = distanceBetweenBoidsAndWalls;\n    this.game = game;\n  }\n  update() {\n    for ( const boid of this.entities ) {\n      if ( boid.isChasing === false ) {\n        continue;\n      }\n      const velocity1 = this.flyTowardsMassCenterRule( boid );\n      const velocity2 = this.keepSmallDistanceFromObstaclesRule( boid );\n      const velocity3 = this.tryMatchingOtherEnitiesVelocityRule( boid );\n\n      boid.body.velocity.x += velocity1.x + velocity2.x + velocity3.x;\n      boid.body.velocity.y += velocity1.y + velocity2.y + velocity3.y;\n    }\n  }\n  flyTowardsMassCenterRule( boid ) {\n    const velocity = { x: 0, y: 0 };\n\n    for ( const entity of this.entities ) {\n      if ( entity === boid ) {\n        continue;\n      }\n      velocity.x += entity.body.x;\n      velocity.y += entity.body.y;\n    }\n\n    velocity.x = ( velocity.x / ( this.entities.length - 1 ) ) / 100;\n    velocity.y = ( velocity.y / ( this.entities.length - 1 ) ) / 100;\n\n    return velocity;\n  }\n  keepSmallDistanceFromObstaclesRule( boid ) {\n    const velocity = { x: 0, y: 0 };\n\n    for ( const otherBoid of this.entities ) {\n      if ( otherBoid === boid ) {\n        continue;\n      }\n      if ( this.game.physics.arcade.distanceBetween( otherBoid, boid ) <= this.boidsDistance ) {\n        velocity.x -= otherBoid.body.x - boid.body.x;\n        velocity.y -= otherBoid.body.y - boid.body.y;\n      }\n    }\n\n    const wallBodies = this.getAdjoiningWallBodies( boid );\n    for ( const wallBody of wallBodies ) {\n      if ( this.game.physics.arcade.distanceBetween( wallBody, boid ) <= this.distanceBetweenBoidsAndWalls ) {\n        velocity.x -= wallBody.x - boid.body.x;\n        velocity.y -= wallBody.y - boid.body.y;\n      }\n    }\n\n    return velocity;\n  }\n  getAdjoiningWallBodies( entity ) {\n    const entityTile = pixelsToTile( entity );\n    const adjoiningTiles = [\n      { x: entityTile.x - 1, y: entityTile.y - 1 },\n      { x: entityTile.x - 1, y: entityTile.y },\n      { x: entityTile.x - 1, y: entityTile.y + 1 },\n      { x: entityTile.x, y: entityTile.y - 1 },\n      { x: entityTile.x, y: entityTile.y + 1 },\n      { x: entityTile.x + 1, y: entityTile.y - 1 },\n      { x: entityTile.x + 1, y: entityTile.y },\n      { x: entityTile.x + 1, y: entityTile.y + 1 },\n    ];\n\n    const adjoiningWallTiles = adjoiningTiles.filter( ( tile ) => this.mapGrid[ tile.y ][ tile.x ] === 1 );\n    return adjoiningWallTiles.map( tileToPixels );\n  }\n  tryMatchingOtherEnitiesVelocityRule() {\n    return { x: 0, y: 0 };\n  }\n}\n",
    "class Entity extends Phaser.Sprite {\n  constructor( game, x, y, imageKey, frame ) {\n    super( game, x, y, imageKey, frame );\n\n    this.anchor.setTo( 0.5, 0.5 );\n\n    this.game.physics.p2.enable( this );\n    this.body.collideWorldBounds = true;\n\n    this.game.world.add( this );\n  }\n  lookAt( targetX, targetY ) {\n    const targetPoint = new Phaser.Point( targetX, targetY );\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\n\n    let targetAngle = Phaser.Math.radToDeg( Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) ) - 90;\n\n    if ( targetAngle < 0 ) {\n      targetAngle += 360;\n    }\n\n    this.body.angle = targetAngle;\n  }\n  normalizeVelocity() {\n    if ( this.body.velocity.x !== 0 && this.body.velocity.y !== 0 ) {\n      this.body.velocity.x = this.body.velocity.x * Math.sqrt( 2 ) * 1 / 2;\n      this.body.velocity.y = this.body.velocity.y * Math.sqrt( 2 ) * 1 / 2;\n    }\n  }\n  resetVelocity() {\n    this.body.velocity.x = 0;\n    this.body.velocity.y = 0;\n  }\n  isMoving() {\n    return this.body.velocity.x !== 0 || this.body.velocity.y !== 0;\n  }\n  isInDegreeRange( entity, target, sightAngle ) {\n    const angleDelta = Math.abs( Phaser.Math.radToDeg( Phaser.Math.angleBetween( entity.x, entity.y, target.x, target.y ) ) + 90 - entity.angle );\n\n    return angleDelta <= sightAngle || angleDelta >= ( 360 - sightAngle );\n  }\n}\n\nexport default Entity;\n",
    "import Entity from './Entity';\nimport PathFinder from '../objects/PathFinder.js';\nimport { ZOMBIE_SPEED, ZOMBIE_ROTATING_SPEED, MIN_DISTANCE_TO_TARGET } from '../constants/ZombieConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { tileToPixels, getWallsPostions } from '../utils/MapUtils.js';\n\n/** Create Entity that is supposed to walk on given path. Set position of entity on first given target*/\nexport default class EntityWalkingOnPath extends Entity {\n  constructor( game, imageKey, frame, targets, walls ) {\n    const position = tileToPixels( targets[ 0 ] );\n\n    super( game, position.x, position.y, imageKey, frame );\n\n    this.pathfinder = new PathFinder();\n    this.wallsPositions = getWallsPostions( walls );\n\n    this.pathfinder.setGrid( this.wallsPositions );\n\n    this.targets = targets;\n\n    this.pathsBetweenPathTargets = [];\n\n    this.currentPathIndex = 0;\n    this.currentStepIndex = 0;\n\n    this.isOnStandardPath = true;\n    this.temporaryPath = [];\n    this.temporaryStepIndex = 0;\n\n    /* disable update until paths are calculated */\n    this.isInitialized = false;\n    this.canMove = false;\n\n    this.calculatePathsBetweenTargets( () => {\n      this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n      this.isInitialized = true;\n      this.canMove = true;\n    } );\n  }\n  /**Recursive function that calculates standard paths and save them into pathsBetweenPathTargets container.  Recurse approach is used to handle asynchronous nature of findPath method */\n  calculatePathsBetweenTargets( doneCallback, index = 0 ) {\n    if ( this.pathsBetweenPathTargets.length === this.targets.length ) {\n      doneCallback();\n      return;\n    }\n\n    const start = this.targets[ index ];\n    const target = ( index === this.targets.length - 1 ) ? this.targets[ 0 ] : this.targets[ index + 1 ];\n\n    this.pathfinder.findPath( start.x, start.y, target.x, target.y, ( path ) => {\n      this.pathsBetweenPathTargets.push( { path, start, target } );\n      this.calculatePathsBetweenTargets( doneCallback, index + 1 );\n    } );\n  }\n  update() {\n    /** Check if current target or step target is reached. Move body in stepTarget direction. */\n    if ( this.canMove ) {\n      if ( this.isReached( this.stepTarget ) ) {\n        this.onStepTargetReach();\n      }\n      this.game.physics.arcade.moveToObject( this, tileToPixels( this.stepTarget ), ZOMBIE_SPEED );\n\n      this.updateLookDirection();\n    }\n  }\n  /** When current step target or temporary step target is reached, set step target to the next one.*/\n  /** If current target is reached or temporary target is reached set path to the next one, or get back to standard path*/\n  onStepTargetReach() {\n    if ( this.isOnStandardPath ) {\n      if ( this.currentStepIndex + 1 === this.pathsBetweenPathTargets[ this.currentPathIndex ].path.length ) {\n        this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenPathTargets.length ) ? 0 : this.currentPathIndex + 1;\n        this.currentStepIndex = 0;\n      } else {\n        this.currentStepIndex++;\n      }\n      this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n    } else {\n      if ( this.temporaryStepIndex + 1 === this.temporaryPath.length ) {\n        this.changePathToStandard();\n      } else {\n        this.temporaryStepIndex++;\n        this.stepTarget = this.temporaryPath[ this.temporaryStepIndex ];\n      }\n    }\n  }\n  updateLookDirection() {\n    const lookTarget = this.getTilesEndCoords( this.stepTarget );\n    const targetPoint = new Phaser.Point( lookTarget.x, lookTarget.y );\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\n\n    let deltaTargetRad = this.rotation - Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) - 1.5 * Math.PI;\n\n    deltaTargetRad = deltaTargetRad % ( Math.PI * 2 );\n\n    if ( deltaTargetRad != deltaTargetRad % ( Math.PI ) ) {\n      deltaTargetRad = deltaTargetRad + Math.PI * ( ( deltaTargetRad < 0 ) ? 2 : -2 );\n    }\n\n    this.body.rotateLeft( ZOMBIE_ROTATING_SPEED * deltaTargetRad );\n  }\n  getTilesEndCoords( tile ) {\n    const tileCoords = tileToPixels( tile );\n    const veryFarAway = 1000;\n    if ( Math.abs( this.body.velocity.x ) > Math.abs( this.body.velocity.y ) ) {\n      if ( this.body.velocity.x > 0 ) {\n        tileCoords.x += veryFarAway * TILE_WIDTH;\n      } else {\n        tileCoords.x -= veryFarAway * TILE_WIDTH;\n      }\n    } else if ( Math.abs( this.body.velocity.x ) < Math.abs( this.body.velocity.y ) ) {\n      if ( this.body.velocity.y > 0 ) {\n        tileCoords.y += veryFarAway * TILE_HEIGHT;\n      } else {\n        tileCoords.y -= veryFarAway * TILE_HEIGHT;\n      }\n    }\n\n    return tileCoords;\n  }\n  isReached( target ) {\n    const distanceToTarget = this.game.physics.arcade.distanceBetween( this, tileToPixels( target ) );\n    return distanceToTarget <= MIN_DISTANCE_TO_TARGET;\n  }\n  calculateTemporaryPath( start, target, callback ) {\n    this.pathfinder.findPath( start.x, start.y, target.x, target.y, callback );\n  }\n  /**\n  * Change path to temporary and automatically get back to standard path, after reaching temporary target.\n  * @param {tile} start - start tile coordinates, if this tile is different that entity's tile then it goes straight to this tile.\n  */\n  changePathToTemporary( start ) {\n    const currentTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].target;\n\n    this.canMove = false;\n    this.calculateTemporaryPath( start, currentTarget, ( path ) => {\n      if ( path.length === 0 ) {\n        this.changePathToStandard();\n        return;\n      }\n      this.temporaryPath = path;\n      this.temporaryStepIndex = 0;\n      this.stepTarget = path[ this.temporaryStepIndex ];\n      this.isOnStandardPath = false;\n      this.canMove = true;\n    } );\n  }\n  changePathToStandard() {\n    this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenPathTargets.length ) ? 0 : this.currentPathIndex + 1;\n    this.currentStepIndex = 0;\n    this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n    this.isOnStandardPath = true;\n  }\n  disableMovement() {\n    this.canMove = false;\n    this.resetVelocity();\n  }\n  enableMovement() {\n    this.canMove = true;\n  }\n}\n",
    "import { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\nimport { COMPUTER_WIDTH, COMPUTER_HEIGHT } from '../constants/ItemConstants';\n\nexport default class Journal extends Phaser.Sprite {\n  constructor( game, tileX, tileY, cornerX, cornerY, imageKey ) {\n    const offsetX = ( cornerX === 'WEST' ) ? ( COMPUTER_WIDTH / 2 ) : TILE_WIDTH - ( COMPUTER_WIDTH / 2 );\n    const offsetY = ( cornerY === 'NORTH' ) ? ( COMPUTER_HEIGHT / 2 ) : TILE_HEIGHT - ( COMPUTER_HEIGHT / 2 );\n\n    const x = tileX + offsetX;\n    const y = tileY + offsetY;\n\n    super( game, x, y, imageKey );\n\n    this.game.world.add( this );\n\n    this.game.physics.p2.enable( this );\n    this.body.static = true;\n\n    let sensorOffsetX = ( TILE_WIDTH - COMPUTER_WIDTH ) / ( ( cornerX === 'WEST' ) ? 2 : -2 );\n    let sensorOffsetY = ( TILE_HEIGHT - COMPUTER_HEIGHT ) / ( ( cornerY === 'NORTH' ) ? 2 : -2 );\n\n    if ( cornerY === 'SOUTH' ) {\n      this.body.angle = 180;\n      sensorOffsetX += ( TILE_WIDTH - COMPUTER_WIDTH ) * ( ( sensorOffsetX < 0 ) ? 1 : -1 );\n      sensorOffsetY += ( TILE_HEIGHT - COMPUTER_HEIGHT ) * ( ( sensorOffsetY < 0 ) ? 1 : -1 );\n    }\n\n    const rectangleSensor = this.body.addRectangle( TILE_WIDTH, TILE_HEIGHT, sensorOffsetX, sensorOffsetY );\n    rectangleSensor.sensor = true;\n\n    this.hasPlayerApproached = false;\n  }\n}\n",
    "import { JOURNAL_TEXT_FIELD_WIDTH, JOURNAL_TEXT_FIELD_HEIGHT, JOURNAL_TEXT_SCROLL_STEP, JOURNAL_TEXT_FONT_SIZE } from '../constants/ItemConstants';\n\nexport default class JournalsManager extends Phaser.Group {\n  constructor( game, messageText ) {\n    super( game );\n\n    this.messageText = messageText;\n\n    this.activateKey = this.game.input.keyboard.addKey( Phaser.Keyboard.E );\n    this.activateKey.onDown.add( this.tryToShowJournal, this );\n    this.game.input.keyboard.removeKeyCapture( Phaser.Keyboard.E );\n\n    this.activateKey = this.game.input.keyboard.addKey( Phaser.Keyboard.ESC );\n    this.activateKey.onDown.add( this.tryToHideJournal, this );\n    this.game.input.keyboard.removeKeyCapture( Phaser.Keyboard.ESC );\n\n    this.isJournalOpened = false;\n  }\n  tryToShowJournal() {\n    if ( this.isJournalOpened ) {\n      return;\n    }\n    const approachedJournals = this.children.filter( journal => journal.hasPlayerApproached );\n    if ( approachedJournals.length > 0 ) {\n      this.isJournalOpened = true;\n      this.game.paused = true;\n      this.messageText.setText( 'Press \\'ESC\\' to close personal journal.' );\n      this.showJournal( approachedJournals[ 0 ] );\n    }\n  }\n  showJournal( ) {\n    const screenCenterX = this.game.camera.x + this.game.camera.width / 2;\n    const screenCenterY = this.game.camera.y + this.game.camera.height / 2;\n\n    this.backgroundLayer = this.game.add.sprite( screenCenterX, screenCenterY, 'layer-background' );\n    this.backgroundLayer.width = this.game.width + 100;\n    this.backgroundLayer.height = this.game.height + 100;\n    this.backgroundLayer.anchor.setTo( 0.5 );\n    this.backgroundLayer.alpha = 0.2;\n\n    this.ui = this.game.add.sprite( screenCenterX, screenCenterY, 'journal-ui' );\n    this.ui.anchor.setTo( 0.5 );\n\n    const textStyle = {\n      align: 'left',\n      fill: '#10aede',\n      font: `bold ${JOURNAL_TEXT_FONT_SIZE}px Arial`,\n    };\n\n    // TODO make text an internal property of journal object\n    this.uiText = this.game.add.text( screenCenterX, screenCenterY,\n       'Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam lobortis tristique libero, in facilisis libero elementum ac. Interdum et malesuada fames ac ante ipsum primis in faucibus. Duis blandit leo mauris, sit amet facilisis augue interdum non. Aliquam imperdiet sapien quis ante consequat tempor. Sed lectus purus, rhoncus a justo quis, tempor ullamcorper dui. Vivamus tortor nulla, ultricies quis leo et, interdum scelerisque lectus. Donec ornare volutpat nisl ac placerat. Curabitur efficitur elementum augue, a vehicula est convallis vitae. Suspendisse ut fermentum odio, vel tempor dui. Praesent id fermentum lorem. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nullam lobortis tristique libero, in facilisis libero elementum ac. Interdum et malesuada fames ac ante ipsum primis in faucibus. Duis blandit leo mauris, sit amet facilisis augue interdum non. Aliquam imperdiet sapien quis ante consequat tempor. Sed lectus purus, rhoncus a justo quis, tempor ullamcorper dui. Vivamus tortor nulla, ultricies quis leo et, interdum scelerisque lectus. Donec ornare volutpat nisl ac placerat. Curabitur efficitur elementum augue, a vehicula est convallis vitae. Suspendisse ut fermentum odio, vel tempor dui. Praesent id fermentum lorem. Etiam gravida risus ante, eget ornare libero luctus vel. QuisqueEtiam gravida risus ante, eget ornare libero luctus vel. Quisque sed mattis ex, id bibendum enim. Morbi vitae nulla eget ante egestas posuere.'\n    , textStyle );\n    this.uiText.wordWrap = true;\n    this.uiText.wordWrapWidth = JOURNAL_TEXT_FIELD_WIDTH;\n    this.uiText.setTextBounds( -JOURNAL_TEXT_FIELD_WIDTH / 2, -JOURNAL_TEXT_FIELD_HEIGHT / 2, JOURNAL_TEXT_FIELD_WIDTH, JOURNAL_TEXT_FIELD_HEIGHT );\n\n    this.maskGraphics = this.game.add.graphics( 0, 0 );\n    this.maskGraphics.beginFill( 0xffffff );\n    this.maskGraphics.drawRect( screenCenterX - JOURNAL_TEXT_FIELD_WIDTH / 2, screenCenterY - JOURNAL_TEXT_FIELD_HEIGHT / 2, JOURNAL_TEXT_FIELD_WIDTH, JOURNAL_TEXT_FIELD_HEIGHT );\n\n    this.uiText.mask = this.maskGraphics;\n  }\n  tryToHideJournal() {\n    if ( this.isJournalOpened && this.game.paused ) {\n      this.isJournalOpened = false;\n      this.game.paused = false;\n      this.messageText.setText( 'Press \\'E\\' to open personal journal.' );\n      this.backgroundLayer.destroy();\n      this.ui.destroy();\n      this.uiText.destroy();\n      this.maskGraphics.destroy();\n    }\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.messageText.setText( 'Press \\'E\\' to open personal journal.' );\n      bodyA.sprite.hasPlayerApproached = true;\n    }\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.messageText.setText( '' );\n      bodyA.sprite.hasPlayerApproached = false;\n    }\n  }\n  isItSensorArea( body, shape ) {\n    if ( body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n    // for now this line assume that there is only one type of computer's textures\n    // TODO enable different sprite key's handling\n    return body.sprite.key === 'computer' && shape.sensor;\n  }\n  onMouseWheel( ) {\n    if ( this.isJournalOpened === false ) {\n      return;\n    }\n\n    const directionY = this.game.input.mouse.wheelDelta;\n    if ( directionY === 1 && !( this.uiText.y >= this.game.camera.y + this.game.camera.height / 2 ) ) {\n      this.uiText.y += JOURNAL_TEXT_SCROLL_STEP;\n    } else if ( directionY === -1 && !( this.uiText.y <= this.game.camera.y + this.game.camera.height / 2 + JOURNAL_TEXT_FIELD_HEIGHT - this.uiText.height ) ) {\n      this.uiText.y -= JOURNAL_TEXT_SCROLL_STEP;\n    }\n  }\n}\n",
    "import EasyStar from 'easystarjs';\n\nexport default class PathFinder {\n  constructor( ) {\n    this.easystar = new EasyStar.js();\n\n    this.easystar.setAcceptableTiles( [ 0 ] );\n  }\n  setGrid( grid ) {\n    this.easystar.setGrid( grid );\n  }\n  findPath( startX, startY, endX, endY, callback ) {\n    this.easystar.findPath( startX, startY, endX, endY, callback );\n    this.easystar.calculate();\n  }\n}\n",
    "import Entity from './Entity';\nimport { PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_SPEED, PLAYER_SNEAK_MULTIPLIER, PLAYER_SPRINT_MULTIPLIER, PLAYER_WALK_ANIMATION_FRAMERATE, PLAYER_FIGHT_ANIMATION_FRAMERATE, PLAYER_HAND_ATTACK_RANGE, PLAYER_HAND_ATTACK_ANGLE, PLAYER_HAND_ATTACK_DAMAGE } from '../constants/PlayerConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\n\nexport default class Player extends Entity {\n  constructor( game, x, y, imageKey, frame, zombies ) {\n    super( game, x + TILE_WIDTH / 2, y + TILE_HEIGHT / 2, imageKey, frame );\n\n    this.width = PLAYER_WIDTH;\n    this.height = PLAYER_HEIGHT;\n\n    this.zombies = zombies.children;\n\n    this.isSneaking = false;\n    this.isSprinting = false;\n\n    this.attackRange = PLAYER_HAND_ATTACK_RANGE;\n    this.dealingDamage = PLAYER_HAND_ATTACK_DAMAGE;\n\n    this.healthbar = this.game.add.graphics( 0, 0 );\n    this.healthbar.anchor.x = 1;\n    this.healthbar.anchor.y = 1;\n    this.healthbar.fixedToCamera = true;\n\n    this.cursors = {\n      up: this.game.input.keyboard.addKey( Phaser.Keyboard.W ),\n      down: this.game.input.keyboard.addKey( Phaser.Keyboard.S ),\n      left: this.game.input.keyboard.addKey( Phaser.Keyboard.A ),\n      right: this.game.input.keyboard.addKey( Phaser.Keyboard.D ),\n      sneak: this.game.input.keyboard.addKey( Phaser.Keyboard.CAPS_LOCK ),\n      sprint: this.game.input.keyboard.addKey( Phaser.Keyboard.SHIFT ),\n    };\n\n    this.isSneakPressed = false;\n\n    const style = { font: '16px Arial', fill: '#fff' };\n\n    this.sneakText = this.game.add.text( 0, 0, 'Sneaking: off', style );\n    this.sneakText.x = this.game.width - ( this.sneakText.width + 24 );\n    this.sneakText.y = this.game.height - ( this.sneakText.height + 24 + 32 );\n    this.sneakText.fixedToCamera = true;\n\n    this.sprintText = this.game.add.text( 0, 0, 'Sprinting: off', style );\n    this.sprintText.x = this.game.width - ( this.sprintText.width + 24 );\n    this.sprintText.y = this.game.height - ( this.sprintText.height + 24 + 32 + this.sneakText.height );\n    this.sprintText.fixedToCamera = true;\n\n    this.animations.add( 'walk', [ 0, 1, 2, 3, 4, 5 ] );\n    this.animations.add( 'fight', [ 6, 7, 8, 9, 0 ] );\n\n    this.body.clearShapes();\n    this.body.addCircle( Math.min( PLAYER_WIDTH, PLAYER_HEIGHT ) );\n\n    this.drawHealthBar();\n  }\n\n  update() {\n    this.handleMovement();\n    this.handleAnimation();\n    this.lookAtMouse();\n    this.handleAttack();\n  }\n  handleMovement() {\n    this.resetVelocity();\n\n    if ( this.cursors.up.isDown ) {\n      this.body.velocity.y = -PLAYER_SPEED;\n    } else if ( this.cursors.down.isDown ) {\n      this.body.velocity.y = PLAYER_SPEED;\n    }\n\n    if ( this.cursors.left.isDown ) {\n      this.body.velocity.x = -PLAYER_SPEED;\n    } else if ( this.cursors.right.isDown ) {\n      this.body.velocity.x = PLAYER_SPEED;\n    }\n\n    this.handleMovementSpecialModes();\n\n    this.normalizeVelocity();\n  }\n  handleMovementSpecialModes() {\n    let specialEffectMultiplier = 1;\n\n    this.isSprinting = false;\n\n    if ( this.cursors.sneak.isDown ) {\n      this.isSneakPressed = true;\n    } else if ( this.isSneakPressed ) {\n      this.isSneaking = !this.isSneaking;\n      this.isSneakPressed = false;\n    }\n\n    if ( this.cursors.sprint.isDown ) {\n      this.isSprinting = true;\n      this.isSneaking = false;\n      specialEffectMultiplier = PLAYER_SPRINT_MULTIPLIER;\n    }\n\n    if ( this.isSneaking ) {\n      specialEffectMultiplier = PLAYER_SNEAK_MULTIPLIER;\n    }\n\n    this.sneakText.setText( 'Sneaking: ' + ( ( this.isSneaking ) ? 'on' : 'off' ) );\n    this.sprintText.setText( 'Sprinting: ' + ( ( this.isSprinting ) ? 'on' : 'off' ) );\n\n    this.body.velocity.x *= specialEffectMultiplier;\n    this.body.velocity.y *= specialEffectMultiplier;\n  }\n  handleAnimation() {\n    if ( this.game.input.activePointer.leftButton.isDown ) {\n      this.animations.play( 'fight', PLAYER_FIGHT_ANIMATION_FRAMERATE, false );\n    }\n    if ( ( this.body.velocity.x !== 0 || this.body.velocity.y !== 0 ) && !this.animations.getAnimation( 'fight' ).isPlaying ) {\n      this.animations.play( 'walk', PLAYER_WALK_ANIMATION_FRAMERATE, true );\n    } else {\n      this.animations.stop( 'walk', true );\n    }\n  }\n\n  lookAtMouse() {\n    const mouseX = this.game.input.mousePointer.worldX;\n    const mouseY = this.game.input.mousePointer.worldY;\n\n    this.lookAt( mouseX, mouseY );\n  }\n\n  handleAttack() {\n    if ( this.game.input.activePointer.leftButton.isDown ) {\n      this.zombies.forEach( ( v ) => {\n        if ( v.alive ) {\n          const distanceToZombie = this.game.physics.arcade.distanceBetween( this, v );\n          if ( distanceToZombie < this.attackRange && this.isInDegreeRange( this, v, PLAYER_HAND_ATTACK_ANGLE ) ) {\n            v.takeDamage( this.dealingDamage );\n          }\n        }\n      } );\n    }\n  }\n\n  takeDamage( damage ) {\n    this.damage( damage );\n    this.drawHealthBar();\n  }\n\n  drawHealthBar() {\n    const width = 300;\n    const height = 32;\n\n    this.healthbar.clear();\n    this.healthbar.beginFill( 0xFF0000, 0.85 );\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width * Math.max( this.health, 0 ), height );\n    this.healthbar.endFill();\n    this.healthbar.lineStyle( 2, 0x880000, 1 );\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width, height );\n    this.healthbar.lineStyle( 0 );\n  }\n}\n",
    "import { pixelsToTile } from '../utils/MapUtils.js';\n\nexport default class TileMap extends Phaser.Tilemap {\n  constructor( game, key, tileWidth, tileHeight ) {\n    super( game, key, tileWidth, tileHeight );\n\n    this.addTilesetImage( 'tilemap' );\n\n    this.ground = this.createLayer( 'background' );\n    this.walls = this.createLayer( 'walls' );\n\n    this.paths = [];\n    this.journals = [];\n\n    this.setCollisionByExclusion( [], true, this.walls );\n\n    this.ground.resizeWorld();\n\n    this.wallsBodiesArray = game.physics.p2.convertTilemap( this, this.walls );\n\n    this.wallsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n\n    for ( const body of this.wallsBodiesArray ) {\n      body.setCollisionGroup( this.wallsCollisionGroup );\n    }\n\n    this.createPathPoints();\n  }\n  collides( collisionGroup, callback ) {\n    for ( const body of this.wallsBodiesArray ) {\n      body.collides( collisionGroup, callback );\n    }\n  }\n  createPathPoints() {\n    this.objects[ 'ZombiePaths' ].forEach( ( v ) => {\n      const props = v.properties;\n      if ( !this.paths[ props.PathId ] ) {\n        this.paths[ props.PathId ] = [];\n      }\n\n      this.paths[ props.PathId ][ props.PathIndex ] = pixelsToTile( { x: v.x, y: v.y } );\n    } );\n\n    this.normalizePaths();\n  }\n  getJournals() {\n    const allJournals = this.objects[ 'Journals' ];\n    const journals = [];\n    allJournals.forEach( ( v ) => {\n      const props = v.properties;\n      journals.push(\n        {\n          x: v.x,\n          y: v.y,\n          cornerX: props.cornerX,\n          cornerY: props.cornerY,\n          title: v.name,\n          content: props.content,\n        }\n      );\n    } );\n\n    return journals;\n  }\n  getPlayerInitialPosition() {\n    const player = this.objects[ 'PlayerPos' ][ 0 ];\n    const posObj = {\n      x: player.x,\n      y: player.y,\n    };\n    return posObj;\n  }\n  normalizePaths() {\n    this.paths.forEach( ( pathArr ) => {\n      const tempArr = [];\n      pathArr.forEach( ( v ) => {\n        tempArr.push( v );\n      } );\n\n      pathArr = tempArr;\n    } );\n  }\n  getPath( i ) {\n    return this.paths[ i ];\n  }\n}\n",
    "import { willEntitiesBeOnTheSameTile, getFreeTileAroundEntityExcludingOtherEntity, getDirectionBetweenEntities } from '../utils/EntityManagerUtils';\nimport { pixelsToTile, getWallsPostions } from '../utils/MapUtils.js';\nimport BoidsManager from './BoidsManager.js';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\n\nexport default class WalkingEntitiesManager extends Phaser.Group {\n  constructor( game, grid ) {\n    super( game );\n    this.mapGrid = getWallsPostions( grid );\n    this.allEntitiesInitialized = false;\n\n    this.boidsManager = new BoidsManager( this.game, this.children, this.mapGrid );\n  }\n  update() {\n    if ( this.allEntitiesInitialized || this.areAllEntitiesInitialized() ) {\n      this.manageMovingEntities();\n    }\n\n    Phaser.Group.prototype.update.call( this );\n\n    this.boidsManager.update();\n  }\n  manageMovingEntities() {\n    for ( const entityIndex1 in this.children ) {\n      for ( const entityIndex2 in this.children ) {\n        if ( entityIndex1 === entityIndex2 ) {\n          continue;\n        }\n        const currentHandledEntity = this.children[ Math.min( entityIndex1, entityIndex2 ) ];\n        const otherEntity = this.children[ Math.max( entityIndex1, entityIndex2 ) ];\n\n        if ( currentHandledEntity.canMove && otherEntity.canMove && willEntitiesBeOnTheSameTile( currentHandledEntity, otherEntity ) ) {\n          const freeTile = getFreeTileAroundEntityExcludingOtherEntity( currentHandledEntity, otherEntity, this.mapGrid );\n          const currentTarget = currentHandledEntity.pathsBetweenPathTargets[ currentHandledEntity.currentPathIndex ].target;\n\n          currentHandledEntity.changePathToTemporary( freeTile, currentTarget );\n        }\n      }\n    }\n  }\n  onCollisionWihOtherEntity( entity1, entity2 ) {\n    const freeTile1 = getFreeTileAroundEntityExcludingOtherEntity( entity1, entity2, this.mapGrid );\n    const freeTile2 = getFreeTileAroundEntityExcludingOtherEntity( entity2, entity1, this.mapGrid );\n\n    entity1.changePathToTemporary( freeTile1 );\n    entity1.changePathToTemporary( freeTile2 );\n  }\n  onCollisionWithWalls( entity, tileBody ) {\n    if ( entity.isChasing === false ) {\n      this.findAdjoiningFreeTileAndGoBackOnPath( entity, tileBody );\n    } else {\n      this.resetVelocityInCorrespondingDimension( entity, tileBody );\n    }\n  }\n  findAdjoiningFreeTileAndGoBackOnPath( entity, tileBody ) {\n    const entityTile = pixelsToTile( entity );\n    const tile = pixelsToTile( { x: tileBody.x + TILE_WIDTH / 2, y: tileBody.y + TILE_HEIGHT / 2 } );\n    let freeTile;\n\n    if ( entityTile.x > tile.x ) {\n      freeTile = { x: entityTile.x + 1, y: entityTile.y };\n    } else if ( entityTile.x < tile.x ) {\n      freeTile = { x: entityTile.x - 1, y: entityTile.y };\n    } else if ( entityTile.y < tile.y ) {\n      freeTile = { x: entityTile.x, y: entityTile.y - 1 };\n    } else if ( entityTile.y > tile.y ) {\n      freeTile = { x: entityTile.x, y: entityTile.y + 1 };\n    }\n\n    entity.changePathToTemporary( freeTile );\n  }\n  resetVelocityInCorrespondingDimension( entity, tileBody ) {\n    const direction = getDirectionBetweenEntities( entity, tileBody );\n    // direction is not always correct becuase of the cases when zombie is colliding with tile's corner\n    if ( direction === 'NORTH' || direction === 'SOUTH' ) {\n      entity.body.velocity.x = ( entity.body.velocity.x / Math.abs( entity.body.velocity.x ) ) * Math.sqrt( Math.pow( entity.body.velocity.x, 2 ) + Math.pow( entity.body.velocity.y, 2 ) );\n      entity.body.velocity.y = 0;\n    } else {\n      entity.body.velocity.y = ( entity.body.velocity.y / Math.abs( entity.body.velocity.y ) ) * Math.sqrt( Math.pow( entity.body.velocity.x, 2 ) + Math.pow( entity.body.velocity.y, 2 ) );\n      entity.body.velocity.x = 0;\n    }\n  }\n  areAllEntitiesInitialized() {\n    for ( const entity of this.children ) {\n      if ( !entity.isInitialized ) {\n        return false;\n      }\n    }\n    this.allEntitiesInitialized = true;\n    return true;\n  }\n}\n",
    "import EntityWalkingOnPath from './EntityWalkingOnPath';\nimport { ZOMBIE_SPEED, MIN_DISTANCE_TO_TARGET, ZOMBIE_SPEED_CHASING_MULTIPLIER, ZOMBIE_SIGHT_ANGLE, ZOMBIE_SIGHT_RANGE, ZOMBIE_HEARING_RANGE, ZOMBIE_DAMAGE_TAKEN, ZOMBIE_DAMAGE_COOLDOWN, ZOMBIE_DAMAGE_MULTIPLIER, ZOMBIE_WALK_ANIMATION_FRAMERATE, ZOMBIE_FIGHT_ANIMATION_FRAMERATE } from '../constants/ZombieConstants';\nimport { pixelsToTile } from '../utils/MapUtils.js';\n\nexport default class Zombie extends EntityWalkingOnPath {\n  constructor( game, imageKey, frame, targets, walls, player ) {\n    super( game, imageKey, frame, targets, walls );\n\n    this.player = player;\n    this.walls = walls;\n    this.playerSeekingRay = new Phaser.Line();\n    this.tileHits = [];\n    this.isChasing = false;\n    this.lastKnownPlayerPosition = { x: 1, y: 1 };\n    this.canDealDamage = true;\n\n    this.damageTaken = ZOMBIE_DAMAGE_TAKEN;\n\n    this.animations.add( 'walk', [ 0, 1, 2, 3, 4, 5 ], 0 );\n    this.animations.add( 'attack', [ 6, 7, 8, 9 ], 6 );\n    this.animations.play( 'walk', ZOMBIE_WALK_ANIMATION_FRAMERATE, true );\n  }\n  update() {\n    if ( this.canSeePlayer() ) {\n      this.isChasing = true;\n      this.lastKnownPlayerPosition = { x: this.player.x, y: this.player.y };\n      if ( this.shouldAttack() ) {\n        this.handleAttack();\n      }\n    }\n\n    if ( !this.isChasing ) {\n      EntityWalkingOnPath.prototype.update.call( this );\n    } else {\n      this.chasePlayer();\n    }\n  }\n  canSeePlayer() {\n    /** Draw line between player and zombie and check if it can see him. If yes, chase him. */\n    this.playerSeekingRay.start.set( this.x, this.y );\n    this.playerSeekingRay.end.set( this.player.x, this.player.y );\n\n    this.tileHits = this.walls.getRayCastTiles( this.playerSeekingRay, 0, false, false );\n\n    if ( this.tileHits.length > 0 ) {\n      for ( let i = 0; i < this.tileHits.length; i++ ) {\n        if ( this.tileHits[ i ].index >= 0 ) {\n          return false;\n        }\n      }\n    }\n\n    return ( this.isInDegreeRange( this, this.player, ZOMBIE_SIGHT_ANGLE )\n    && ( this.isChasing || this.playerSeekingRay.length < ZOMBIE_SIGHT_RANGE ) )\n    || ( this.playerSeekingRay.length < ZOMBIE_HEARING_RANGE && !this.player.isSneaking && this.player.isMoving() );\n  }\n\n  chasePlayer() {\n    this.game.physics.arcade.moveToObject( this, this.lastKnownPlayerPosition, ZOMBIE_SPEED * ZOMBIE_SPEED_CHASING_MULTIPLIER );\n    this.lookAt( this.lastKnownPlayerPosition.x, this.lastKnownPlayerPosition.y );\n\n    const distanceToTarget = this.game.physics.arcade.distanceBetween( this, this.lastKnownPlayerPosition );\n    if ( !this.canSeePlayer() && ( distanceToTarget <= MIN_DISTANCE_TO_TARGET ) ) {\n      this.stopChasingPlayer();\n    }\n  }\n\n  takeDamage( damage ) {\n    this.damage( damage * ZOMBIE_DAMAGE_MULTIPLIER );\n  }\n\n  endCooldown() {\n    this.canDealDamage = true;\n  }\n\n  stopChasingPlayer() {\n    this.body.velocity.x = 0;\n    this.body.velocity.y = 0;\n    this.isChasing = false;\n    this.changePathToTemporary( pixelsToTile( this ) );\n  }\n  shouldAttack() {\n    return this.alive && this.canDealDamage && this.game.physics.arcade.distanceBetween( this, this.player ) < 50;\n  }\n  handleAttack() {\n    this.animations.play( 'attack', ZOMBIE_FIGHT_ANIMATION_FRAMERATE, false );\n    this.player.takeDamage( 0.1 );\n    this.canDealDamage = false;\n    this.game.time.events.add( Phaser.Timer.SECOND * ZOMBIE_DAMAGE_COOLDOWN, this.endCooldown, this );\n    this.game.camera.shake( 0.005, 100, false );\n  }\n}\n",
    "import WalkingEntitiesManager from '../objects/WalkingEntitiesManager';\n\nexport default class ZombieManager extends WalkingEntitiesManager {\n  constructor( game, grid ) {\n    super( game, grid );\n  }\n\n  update() {\n    WalkingEntitiesManager.prototype.update.call( this );\n  }\n\n}\n",
    "class Boot extends Phaser.State {\n  preload() {\n  }\n  create() {\n    // this.game.stage.disableVisibilityChange = true;\n\n    // this.game.scale.maxWidth = 800;\n    // this.game.scale.maxHeight = 600;\n\n    this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n    this.game.scale.updateLayout();\n\n    this.game.physics.startSystem( Phaser.Physics.P2JS );\n    this.game.physics.p2.setImpactEvents( true );\n    this.state.start( 'Preload' );\n  }\n}\n\nexport default Boot;\n",
    "import Player from '../objects/Player';\nimport Zombie from '../objects/Zombie';\nimport TileMap from '../objects/TileMap';\nimport ZombiesManager from '../objects/ZombiesManager';\nimport JournalsManager from '../objects/JournalsManager';\nimport Journal from '../objects/Journal';\n\nimport { PLAYER_INITIAL_FRAME } from '../constants/PlayerConstants';\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\n\nexport default class Game extends Phaser.State {\n  create() {\n\n    this.map = new TileMap( this.game, 'map', TILE_WIDTH, TILE_HEIGHT );\n    this.zombies = new ZombiesManager( this.game, this.map.walls );\n    const playerPos = this.map.getPlayerInitialPosition();\n    this.player = new Player( this.game, playerPos.x, playerPos.y, 'player', PLAYER_INITIAL_FRAME, this.zombies );\n\n    const style = { font: '24px Arial', fill: '#fff' };\n\n    this.messageText = this.game.add.text( 0, 0, '', style );\n    this.messageText.x = 24;\n    this.messageText.y = this.game.height - 24 - 32;\n    this.messageText.fixedToCamera = true;\n\n    this.journals = new JournalsManager( this.game, this.messageText );\n\n    this.playerCollisionGroup = this.game.physics.p2.createCollisionGroup( this.player );\n    this.zombiesCollisionGroup = this.game.physics.p2.createCollisionGroup();\n    this.journalsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n\n    // init player\n    this.game.camera.follow( this.player );\n\n    this.map.collides( [ this.playerCollisionGroup ] );\n    this.player.body.collides( [ this.map.wallsCollisionGroup ] );\n\n    // init zombies\n    for ( let i = 0; i < this.map.paths.length; i++ ) {\n      const newZombie = this.zombies.add( new Zombie( this.game, 'zombie', PLAYER_INITIAL_FRAME, this.map.getPath( i ), this.map.walls, this.player ) );\n\n      newZombie.body.setCollisionGroup( this.zombiesCollisionGroup );\n      newZombie.body.collides( this.zombiesCollisionGroup, ( body1, body2 ) => this.zombies.onCollisionWihOtherEntity( body1.sprite, body2.sprite ) );\n      newZombie.body.collides( this.map.wallsCollisionGroup, ( body, tileBody ) => this.zombies.onCollisionWithWalls( body.sprite, tileBody ) );\n      newZombie.body.collides( [ this.playerCollisionGroup, this.journalsCollisionGroup ] );\n    }\n    this.player.body.collides( [ this.zombiesCollisionGroup ] );\n    this.map.collides( [ this.zombiesCollisionGroup ] );\n\n    // init journals\n    const journalsData = this.map.getJournals();\n\n    this.game.input.mouse.mouseWheelCallback = () => this.journals.onMouseWheel();\n\n    for ( let i = 0; i < journalsData.length; i++ ) {\n      const newJournal = this.journals.add( new Journal( this.game, journalsData[ i ].x, journalsData[ i ].y, journalsData[ i ].cornerX, journalsData[ i ].cornerY, 'computer' ) );\n      newJournal.body.setCollisionGroup( this.journalsCollisionGroup );\n      newJournal.body.collides( [ this.playerCollisionGroup, this.zombiesCollisionGroup ] );\n    }\n    this.player.body.collides( this.journalsCollisionGroup );\n\n    this.player.body.onBeginContact.add( ( ...args ) => this.journals.onCollisionEnter( ...args ) );\n    this.player.body.onEndContact.add( ( ...args ) => this.journals.onCollisionLeave( ...args ) );\n  }\n}\n",
    "class Menu extends Phaser.State {\n  create() {\n    this.state.start( 'Game' );\n  }\n}\n\nexport default Menu;\n",
    "import { PLAYER_WIDTH, PLAYER_HEIGHT } from '../constants/PlayerConstants.js';\nimport { ZOMBIE_WIDTH, ZOMBIE_HEIGHT } from '../constants/ZombieConstants.js';\n\nclass Preload extends Phaser.State {\n  preload() {\n    this.load.tilemap( 'map', 'assets/tilemaps/maps/map.json', null, Phaser.Tilemap.TILED_JSON );\n    this.load.image( 'tilemap', 'assets/tilemaps/tiles/tilemap.png' );\n\n    this.game.load.spritesheet( 'player', './assets/images/player-sheet.png', PLAYER_WIDTH, PLAYER_HEIGHT );\n    this.game.load.spritesheet( 'zombie', './assets/images/zombie-sheet.png', ZOMBIE_WIDTH, ZOMBIE_HEIGHT );\n\n    this.game.load.image( 'computer', './assets/images/computer.png' );\n    this.game.load.image( 'layer-background', './assets/images/bg-color.png' );\n    this.game.load.image( 'journal-ui', './assets/images/journal-ui.png' );\n  }\n  create() {\n    this.state.start( 'Menu' );\n  }\n}\n\nexport default Preload;\n",
    "import { pixelsToTile } from '../utils/MapUtils';\n\nexport const getEntityNextTile = ( entity ) => {\n  if ( entity.isOnStandardPath ) {\n    let pathIndex = entity.currentPathIndex;\n    let stepIndex = entity.currentStepIndex;\n\n    if ( entity.pathsBetweenPathTargets[ pathIndex ].path.length === stepIndex + 1 ) {\n      stepIndex = 0;\n\n      if ( entity.pathsBetweenPathTargets.length === pathIndex + 1 ) {\n        pathIndex = 0;\n      } else {\n        pathIndex++;\n      }\n    } else {\n      stepIndex++;\n    }\n    if ( entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ] == undefined ) {\n      throw new Error( `Wrong path data: pathIndex: ${pathIndex}, stepIndex: ${stepIndex}, entity: ${entity}` );\n    }\n    return entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ];\n  } else {\n    let stepIndex = entity.temporaryStepIndex;\n    if ( stepIndex + 1 === entity.temporaryPath.length ) {\n      stepIndex = 0;\n      let pathIndex = ( entity.currentPathIndex + 1 === entity.pathsBetweenPathTargets.length ) ? 0 : entity.currentPathIndex + 1;\n      if ( entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ] == undefined ) {\n        throw new Error( `Wrong path data: pathIndex: ${pathIndex}, stepIndex: ${stepIndex}, entity: ${entity}` );\n      }\n      return entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ];\n    } else {\n      if ( entity.temporaryPath[ stepIndex ] == undefined ) {\n        throw new Error( `Wrong temporary path data: stepIndex: ${stepIndex}` );\n      }\n      return entity.temporaryPath[ stepIndex ];\n    }\n  }\n};\n\nconst areTilesTheSame = ( tile1, tile2 ) => tile1.x === tile2.x && tile1.y === tile2.y;\n\nexport const getEntityCurrentStepTarget = ( entity ) => ( entity.isOnStandardPath ) ? entity.pathsBetweenPathTargets[ entity.currentPathIndex ].path[ entity.currentStepIndex ] : entity.temporaryPath[ entity.temporaryStepIndex ];\n\nexport const willEntitiesBeOnTheSameTile = ( entity1, entity2 ) => {\n  const entityNextTarget1 = getEntityNextTile( entity1 );\n  const entityNextTarget2 = getEntityNextTile( entity2 );\n  const entityCurrentTarget1 = getEntityCurrentStepTarget( entity1 );\n  const entityCurrentTarget2 = getEntityCurrentStepTarget( entity2 );\n\n  return areTilesTheSame( entityNextTarget1, entityNextTarget2 )\n  || areTilesTheSame( entityNextTarget1, entityCurrentTarget2 )\n   || areTilesTheSame( entityCurrentTarget1, entityCurrentTarget2 );\n};\n\nconst getDirectionBetweenTiles = ( tile1, tile2 ) => {\n  if ( tile1.y === tile2.y ) {\n    if ( tile1.x > tile2.x ) {\n      return 'WEST';\n    } else if ( tile1.x < tile2.x ) {\n      return 'EAST';\n    } else {\n      throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n    }\n  } else if ( tile1.x === tile2.x ) {\n    if ( tile1.y > tile2.y ) {\n      return 'NORTH';\n    } else if ( tile1.y < tile2.y ) {\n      return 'SOUTH';\n    } else {\n      throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n    }\n  } else {\n    if ( tile1.y < tile2.y && tile1.x < tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'SOUTH' : 'EAST';\n    } else if ( tile1.y > tile2.y && tile1.x < tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'NORTH' : 'EAST';\n    } else if ( tile1.y < tile2.y && tile1.x > tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'NORTH' : 'WEST';\n    } else if ( tile1.y > tile2.y && tile1.x > tile2.x ) {\n      return ( Math.random() > 0.5 ) ? 'SOUTH' : 'WEST';\n    }\n  }\n  throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\n};\n\nexport const getDirectionBetweenEntities = ( entity1, entity2 ) => {\n  const entityTile1 = pixelsToTile( entity1 );\n  const entityTile2 = pixelsToTile( entity2 );\n\n  if ( areTilesTheSame( entityTile1, entityTile2 ) ) {\n    // this case maybe can be handled better\n    return getDirectionBetweenTiles( entity1, entity2 );\n  } else {\n    return getDirectionBetweenTiles( entityTile1, entityTile2 );\n  }\n};\n\nexport const getFreeTileAroundEntityExcludingOtherEntity = ( entity, entityToExclude, mapGrid ) => {\n  const entityTile = pixelsToTile( entity );\n  const tileToExclude = getEntityNextTile( entityToExclude );\n\n  let directionToExclude;\n\n  if ( ( entityTile.x === tileToExclude.x && entityTile.y === tileToExclude.y ) || ( entityTile.x !== tileToExclude.x && entityTile.y !== tileToExclude.y ) ) {\n    directionToExclude = getDirectionBetweenEntities( entity, entityToExclude );\n  } else {\n    directionToExclude = getDirectionBetweenTiles( entityTile, tileToExclude );\n  }\n\n  switch ( directionToExclude ) {\n  case 'NORTH':\n    return getFreeTileExcludingNorth( entityTile, mapGrid );\n  case 'SOUTH':\n    return getFreeTileExcludingSouth( entityTile, mapGrid );\n  case 'WEST':\n    return getFreeTileExcludingWest( entityTile, mapGrid );\n  case 'EAST':\n    return getFreeTileExcludingEast( entityTile, mapGrid );\n  }\n\n  throw new Error( `Couldn't find free tile entityTile: ${entityTile}, directionToExclude: ${directionToExclude}` );\n};\n\nfunction getFreeTileExcludingNorth( entityTile, mapGrid ) {\n  let freeTile = { x: -1, y: entityTile.y };\n  if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 && mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = ( Math.random() > 0.5 ) ? entityTile.x - 1 : entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x - 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile = { x: entityTile.x, y: entityTile.y + 1 };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingSouth( entityTile, mapGrid ) {\n  let freeTile = { x: -1, y: entityTile.y };\n  if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 && mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = ( Math.random() > 0.5 ) ? entityTile.x - 1 : entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x - 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile.x = entityTile.x + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile = { x: entityTile.x, y: entityTile.y - 1 };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingWest( entityTile, mapGrid ) {\n  let freeTile = { x: entityTile.x, y: -1 };\n  if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 && mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = ( Math.random() > 0.5 ) ? entityTile.y - 1 : entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile.y = entityTile.y - 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\n    freeTile = { x: entityTile.x + 1, y: entityTile.y };\n  }\n  return freeTile;\n}\nfunction getFreeTileExcludingEast( entityTile, mapGrid ) {\n  let freeTile = { x: entityTile.x, y: -1 };\n  if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 && mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = ( Math.random() > 0.5 ) ? entityTile.y - 1 : entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\n    freeTile.y = entityTile.y - 1;\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\n    freeTile.y = entityTile.y + 1;\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\n    freeTile = { x: entityTile.x - 1, y: entityTile.y };\n  }\n  return freeTile;\n}\n",
    "import { TILE_WIDTH, TILE_HEIGHT, MAP_WIDTH } from '../constants/TileMapConstants';\n\nexport const pixelsToTileX = ( coord ) => Math.floor( coord / TILE_WIDTH );\nexport const pixelsToTileY = ( coord ) => Math.floor( coord / TILE_HEIGHT );\n\nexport const tileToPixels = ( tile ) => ( {\n  x: ( tile.x * TILE_WIDTH ) + TILE_WIDTH / 2,\n  y: ( tile.y * TILE_HEIGHT ) + TILE_HEIGHT / 2,\n} );\n\nexport const pixelsToTile = ( coords ) => ( {\n  x: Math.floor( coords.x / TILE_WIDTH ),\n  y: Math.floor( coords.y / TILE_HEIGHT ),\n} );\n\nexport const getWallsPostions = ( layer ) => {\n  const walls = layer.getTiles( 0, 0, 2048, 2048 );\n  const wallsArr = [];\n\n  let currentY = [];\n\n  walls.forEach( ( v, i ) => {\n    if ( v.index !== -1 ) {\n      currentY.push( 1 );\n    } else {\n      currentY.push( 0 );\n    }\n\n    if ( i % MAP_WIDTH === ( MAP_WIDTH - 1 ) ) {\n      wallsArr.push( currentY );\n      currentY = [];\n    }\n  } );\n\n  return wallsArr;\n};\n"
  ]
}