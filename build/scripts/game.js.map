{
  "version": 3,
  "sources": [
    "node_modules/browser-pack/_prelude.js",
    "node_modules/easystarjs/src/easystar.js",
    "node_modules/easystarjs/src/instance.js",
    "node_modules/easystarjs/src/node.js",
    "node_modules/heap/index.js",
    "node_modules/heap/lib/heap.js",
    "src\\ProjectNostradamus.js",
    "src\\constants\\PlayerConstants.js",
    "src\\constants\\TileMapConstants.js",
    "src\\constants\\ZombieConstants.js",
    "src\\index.js",
    "src\\objects\\Entity.js",
    "src\\objects\\EntityWalkingOnPath.js",
    "src\\objects\\PathFinder.js",
    "src\\objects\\Player.js",
    "src\\objects\\TileMap.js",
    "src\\objects\\WalkingEntitiesManager.js",
    "src\\objects\\Zombie.js",
    "src\\objects\\ZombiesManager.js",
    "src\\states\\Boot.js",
    "src\\states\\Game.js",
    "src\\states\\Menu.js",
    "src\\states\\Preload.js",
    "src\\utils\\BoidsManager.js",
    "src\\utils\\EntityManagerUtils.js",
    "src\\utils\\MapUtils.js"
  ],
  "names": [],
  "mappings": "AAAA;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9gBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;;ACDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvXA;;;;AACA;;;;AACA;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;I,AAEM;gCACJ;;8B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",
  "file": "generated.js",
  "sourceRoot": "",
  "sourcesContent": [
    "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})",
    "/**\n*   EasyStar.js\n*   github.com/prettymuchbryce/EasyStarJS\n*   Licensed under the MIT license.\n*\n*   Implementation By Bryce Neal (@prettymuchbryce)\n**/\n\nvar EasyStar = {}\nvar Instance = require('./instance');\nvar Node = require('./node');\nvar Heap = require('heap');\n\nconst CLOSED_LIST = 0;\nconst OPEN_LIST = 1;\n\nmodule.exports = EasyStar;\n\nEasyStar.js = function() {\n    var STRAIGHT_COST = 1.0;\n    var DIAGONAL_COST = 1.4;\n    var syncEnabled = false;\n    var pointsToAvoid = {};\n    var collisionGrid;\n    var costMap = {};\n    var pointsToCost = {};\n    var directionalConditions = {};\n    var allowCornerCutting = true;\n    var iterationsSoFar;\n    var instances = [];\n    var iterationsPerCalculation = Number.MAX_VALUE;\n    var acceptableTiles;\n    var diagonalsEnabled = false;\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array|Number} tiles An array of numbers that represent\n    * which tiles in your grid should be considered\n    * acceptable, or \"walkable\".\n    **/\n    this.setAcceptableTiles = function(tiles) {\n        if (tiles instanceof Array) {\n            // Array\n            acceptableTiles = tiles;\n        } else if (!isNaN(parseFloat(tiles)) && isFinite(tiles)) {\n            // Number\n            acceptableTiles = [tiles];\n        }\n    };\n\n    /**\n    * Enables sync mode for this EasyStar instance..\n    * if you're into that sort of thing.\n    **/\n    this.enableSync = function() {\n        syncEnabled = true;\n    };\n\n    /**\n    * Disables sync mode for this EasyStar instance.\n    **/\n    this.disableSync = function() {\n        syncEnabled = false;\n    };\n\n    /**\n     * Enable diagonal pathfinding.\n     */\n    this.enableDiagonals = function() {\n        diagonalsEnabled = true;\n    }\n\n    /**\n     * Disable diagonal pathfinding.\n     */\n    this.disableDiagonals = function() {\n        diagonalsEnabled = false;\n    }\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array} grid The collision grid that this EasyStar instance will read from.\n    * This should be a 2D Array of Numbers.\n    **/\n    this.setGrid = function(grid) {\n        collisionGrid = grid;\n\n        //Setup cost map\n        for (var y = 0; y < collisionGrid.length; y++) {\n            for (var x = 0; x < collisionGrid[0].length; x++) {\n                if (!costMap[collisionGrid[y][x]]) {\n                    costMap[collisionGrid[y][x]] = 1\n                }\n            }\n        }\n    };\n\n    /**\n    * Sets the tile cost for a particular tile type.\n    *\n    * @param {Number} The tile type to set the cost for.\n    * @param {Number} The multiplicative cost associated with the given tile.\n    **/\n    this.setTileCost = function(tileType, cost) {\n        costMap[tileType] = cost;\n    };\n\n    /**\n    * Sets the an additional cost for a particular point.\n    * Overrides the cost from setTileCost.\n    *\n    * @param {Number} x The x value of the point to cost.\n    * @param {Number} y The y value of the point to cost.\n    * @param {Number} The multiplicative cost associated with the given point.\n    **/\n    this.setAdditionalPointCost = function(x, y, cost) {\n        pointsToCost[x + '_' + y] = cost;\n    };\n\n    /**\n    * Remove the additional cost for a particular point.\n    *\n    * @param {Number} x The x value of the point to stop costing.\n    * @param {Number} y The y value of the point to stop costing.\n    **/\n    this.removeAdditionalPointCost = function(x, y) {\n        delete pointsToCost[x + '_' + y];\n    }\n\n    /**\n    * Remove all additional point costs.\n    **/\n    this.removeAllAdditionalPointCosts = function() {\n        pointsToCost = {};\n    }\n\n    /**\n    * Sets a directional condition on a tile\n    *\n    * @param {Number} x The x value of the point.\n    * @param {Number} y The y value of the point.\n    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access\n    * the tile.\n    **/\n    this.setDirectionalCondition = function(x, y, allowedDirections) {\n        directionalConditions[x + '_' + y] = allowedDirections;\n    };\n\n    /**\n    * Remove all directional conditions\n    **/\n    this.removeAllDirectionalConditions = function() {\n        directionalConditions = {};\n    };\n\n    /**\n    * Sets the number of search iterations per calculation.\n    * A lower number provides a slower result, but more practical if you\n    * have a large tile-map and don't want to block your thread while\n    * finding a path.\n    *\n    * @param {Number} iterations The number of searches to prefrom per calculate() call.\n    **/\n    this.setIterationsPerCalculation = function(iterations) {\n        iterationsPerCalculation = iterations;\n    };\n\n    /**\n    * Avoid a particular point on the grid,\n    * regardless of whether or not it is an acceptable tile.\n    *\n    * @param {Number} x The x value of the point to avoid.\n    * @param {Number} y The y value of the point to avoid.\n    **/\n    this.avoidAdditionalPoint = function(x, y) {\n        pointsToAvoid[x + \"_\" + y] = 1;\n    };\n\n    /**\n    * Stop avoiding a particular point on the grid.\n    *\n    * @param {Number} x The x value of the point to stop avoiding.\n    * @param {Number} y The y value of the point to stop avoiding.\n    **/\n    this.stopAvoidingAdditionalPoint = function(x, y) {\n        delete pointsToAvoid[x + \"_\" + y];\n    };\n\n    /**\n    * Enables corner cutting in diagonal movement.\n    **/\n    this.enableCornerCutting = function() {\n        allowCornerCutting = true;\n    };\n\n    /**\n    * Disables corner cutting in diagonal movement.\n    **/\n    this.disableCornerCutting = function() {\n        allowCornerCutting = false;\n    };\n\n    /**\n    * Stop avoiding all additional points on the grid.\n    **/\n    this.stopAvoidingAllAdditionalPoints = function() {\n        pointsToAvoid = {};\n    };\n\n    /**\n    * Find a path.\n    *\n    * @param {Number} startX The X position of the starting point.\n    * @param {Number} startY The Y position of the starting point.\n    * @param {Number} endX The X position of the ending point.\n    * @param {Number} endY The Y position of the ending point.\n    * @param {Function} callback A function that is called when your path\n    * is found, or no path is found.\n    *\n    **/\n    this.findPath = function(startX, startY, endX, endY, callback) {\n        // Wraps the callback for sync vs async logic\n        var callbackWrapper = function(result) {\n            if (syncEnabled) {\n                callback(result);\n            } else {\n                setTimeout(function() {\n                    callback(result);\n                });\n            }\n        }\n\n        // No acceptable tiles were set\n        if (acceptableTiles === undefined) {\n            throw new Error(\"You can't set a path without first calling setAcceptableTiles() on EasyStar.\");\n        }\n        // No grid was set\n        if (collisionGrid === undefined) {\n            throw new Error(\"You can't set a path without first calling setGrid() on EasyStar.\");\n        }\n\n        // Start or endpoint outside of scope.\n        if (startX < 0 || startY < 0 || endX < 0 || endY < 0 ||\n        startX > collisionGrid[0].length-1 || startY > collisionGrid.length-1 ||\n        endX > collisionGrid[0].length-1 || endY > collisionGrid.length-1) {\n            throw new Error(\"Your start or end point is outside the scope of your grid.\");\n        }\n\n        // Start and end are the same tile.\n        if (startX===endX && startY===endY) {\n            callbackWrapper([]);\n            return;\n        }\n\n        // End point is not an acceptable tile.\n        var endTile = collisionGrid[endY][endX];\n        var isAcceptable = false;\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (endTile === acceptableTiles[i]) {\n                isAcceptable = true;\n                break;\n            }\n        }\n\n        if (isAcceptable === false) {\n            callbackWrapper(null);\n            return;\n        }\n\n        // Create the instance\n        var instance = new Instance();\n        instance.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.bestGuessDistance() - nodeB.bestGuessDistance();\n        });\n        instance.isDoneCalculating = false;\n        instance.nodeHash = {};\n        instance.startX = startX;\n        instance.startY = startY;\n        instance.endX = endX;\n        instance.endY = endY;\n        instance.callback = callbackWrapper;\n\n        instance.openList.push(coordinateToNode(instance, instance.startX,\n            instance.startY, null, STRAIGHT_COST));\n\n        instances.push(instance);\n    };\n\n    /**\n    * This method steps through the A* Algorithm in an attempt to\n    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.\n    * You can change the number of calculations done in a call by using\n    * easystar.setIteratonsPerCalculation().\n    **/\n    this.calculate = function() {\n        if (instances.length === 0 || collisionGrid === undefined || acceptableTiles === undefined) {\n            return;\n        }\n        for (iterationsSoFar = 0; iterationsSoFar < iterationsPerCalculation; iterationsSoFar++) {\n            if (instances.length === 0) {\n                return;\n            }\n\n            if (syncEnabled) {\n                // If this is a sync instance, we want to make sure that it calculates synchronously.\n                iterationsSoFar = 0;\n            }\n\n            // Couldn't find a path.\n            if (instances[0].openList.size() === 0) {\n                var ic = instances[0];\n                ic.callback(null);\n                instances.shift();\n                continue;\n            }\n\n            var searchNode = instances[0].openList.pop();\n\n            // Handles the case where we have found the destination\n            if (instances[0].endX === searchNode.x && instances[0].endY === searchNode.y) {\n                instances[0].isDoneCalculating = true;\n                var path = [];\n                path.push({x: searchNode.x, y: searchNode.y});\n                var parent = searchNode.parent;\n                while (parent!=null) {\n                    path.push({x: parent.x, y:parent.y});\n                    parent = parent.parent;\n                }\n                path.reverse();\n                var ic = instances[0];\n                var ip = path;\n                ic.callback(ip);\n                return\n            }\n\n            var tilesToSearch = [];\n            searchNode.list = CLOSED_LIST;\n\n            if (searchNode.y > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: -1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y-1)});\n            }\n            if (searchNode.x < collisionGrid[0].length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x+1, searchNode.y)});\n            }\n            if (searchNode.y < collisionGrid.length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: 1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y+1)});\n            }\n            if (searchNode.x > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: -1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x-1, searchNode.y)});\n            }\n            if (diagonalsEnabled) {\n                if (searchNode.x > 0 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y+1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x > 0 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y+1)});\n                    }\n                }\n            }\n\n            var isDoneCalculating = false;\n\n            // Search all of the surrounding nodes\n            for (var i = 0; i < tilesToSearch.length; i++) {\n                checkAdjacentNode(tilesToSearch[i].instance, tilesToSearch[i].searchNode,\n                    tilesToSearch[i].x, tilesToSearch[i].y, tilesToSearch[i].cost);\n                if (tilesToSearch[i].instance.isDoneCalculating === true) {\n                    isDoneCalculating = true;\n                    break;\n                }\n            }\n\n            if (isDoneCalculating) {\n                instances.shift();\n                continue;\n            }\n\n        }\n    };\n\n    // Private methods follow\n    var checkAdjacentNode = function(instance, searchNode, x, y, cost) {\n        var adjacentCoordinateX = searchNode.x+x;\n        var adjacentCoordinateY = searchNode.y+y;\n\n        if (pointsToAvoid[adjacentCoordinateX + \"_\" + adjacentCoordinateY] === undefined &&\n            isTileWalkable(collisionGrid, acceptableTiles, adjacentCoordinateX, adjacentCoordinateY, searchNode)) {\n            var node = coordinateToNode(instance, adjacentCoordinateX,\n                adjacentCoordinateY, searchNode, cost);\n\n            if (node.list === undefined) {\n                node.list = OPEN_LIST;\n                instance.openList.push(node);\n            } else if (searchNode.costSoFar + cost < node.costSoFar) {\n                node.costSoFar = searchNode.costSoFar + cost;\n                node.parent = searchNode;\n                instance.openList.updateItem(node);\n            }\n        }\n    };\n\n    // Helpers\n    var isTileWalkable = function(collisionGrid, acceptableTiles, x, y, sourceNode) {\n        if (directionalConditions[x + \"_\" + y]) {\n            var direction = calculateDirection(sourceNode.x - x, sourceNode.y - y)\n            var directionIncluded = function () {\n                for (var i = 0; i < directionalConditions[x + \"_\" + y].length; i++) {\n                    if (directionalConditions[x + \"_\" + y][i] === direction) return true\n                }\n                return false\n            }\n            if (!directionIncluded()) return false\n        }\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (collisionGrid[y][x] === acceptableTiles[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * -1, -1 | 0, -1  | 1, -1\n     * -1,  0 | SOURCE | 1,  0\n     * -1,  1 | 0,  1  | 1,  1\n     */\n    var calculateDirection = function (diffX, diffY) {\n        if (diffX === 0, diffY === -1) return EasyStar.BOTTOM\n        else if (diffX === 1, diffY === -1) return EasyStar.BOTTOM_LEFT\n        else if (diffX === 1, diffY === 0) return EasyStar.LEFT\n        else if (diffX === 1, diffY === 1) return EasyStar.TOP_LEFT\n        else if (diffX === 0, diffY === 1) return EasyStar.TOP\n        else if (diffX === -1, diffY === 1) return EasyStar.TOP_RIGHT\n        else if (diffX === -1, diffY === 0) return EasyStar.RIGHT\n        else if (diffX === -1, diffY === -1) return EasyStar.BOTTOM_RIGHT\n        throw new Error('These differences are not valid: ' + diffX + ', ' + diffY)\n    };\n\n    var getTileCost = function(x, y) {\n        return pointsToCost[x + '_' + y] || costMap[collisionGrid[y][x]]\n    };\n\n    var coordinateToNode = function(instance, x, y, parent, cost) {\n        if (instance.nodeHash[x + \"_\" + y]!==undefined) {\n            return instance.nodeHash[x + \"_\" + y];\n        }\n        var simpleDistanceToTarget = getDistance(x, y, instance.endX, instance.endY);\n        if (parent!==null) {\n            var costSoFar = parent.costSoFar + cost;\n        } else {\n            costSoFar = 0;\n        }\n        var node = new Node(parent,x,y,costSoFar,simpleDistanceToTarget);\n        instance.nodeHash[x + \"_\" + y] = node;\n        return node;\n    };\n\n    var getDistance = function(x1,y1,x2,y2) {\n        if (diagonalsEnabled) {\n            // Octile distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            if (dx < dy) {\n                return DIAGONAL_COST * dx + dy;\n            } else {\n                return DIAGONAL_COST * dy + dx;\n            }\n        } else {\n            // Manhattan distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            return (dx + dy);\n        }\n    };\n}\n\nEasyStar.TOP = 'TOP'\nEasyStar.TOP_RIGHT = 'TOP_RIGHT'\nEasyStar.RIGHT = 'RIGHT'\nEasyStar.BOTTOM_RIGHT = 'BOTTOM_RIGHT'\nEasyStar.BOTTOM = 'BOTTOM'\nEasyStar.BOTTOM_LEFT = 'BOTTOM_LEFT'\nEasyStar.LEFT = 'LEFT'\nEasyStar.TOP_LEFT = 'TOP_LEFT'\n",
    "/**\n * Represents a single instance of EasyStar.\n * A path that is in the queue to eventually be found.\n */\nmodule.exports = function() {\n    this.isDoneCalculating = true;\n    this.pointsToAvoid = {};\n    this.startX;\n    this.callback;\n    this.startY;\n    this.endX;\n    this.endY;\n    this.nodeHash = {};\n    this.openList;\n};",
    "/**\n* A simple Node that represents a single tile on the grid.\n* @param {Object} parent The parent node.\n* @param {Number} x The x position on the grid.\n* @param {Number} y The y position on the grid.\n* @param {Number} costSoFar How far this node is in moves*cost from the start.\n* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.\n**/\nmodule.exports = function(parent, x, y, costSoFar, simpleDistanceToTarget) {\n    this.parent = parent;\n    this.x = x;\n    this.y = y;\n    this.costSoFar = costSoFar;\n    this.simpleDistanceToTarget = simpleDistanceToTarget;\n\n    /**\n    * @return {Number} Best guess distance of a cost using this node.\n    **/\n    this.bestGuessDistance = function() {\n        return this.costSoFar + this.simpleDistanceToTarget;\n    }\n};",
    "module.exports = require('./lib/heap');\n",
    "// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (typeof define === 'function' && define.amd) {\n      return define([], factory);\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n",
    "import Boot from './states/Boot';\r\nimport Preload from './states/Preload';\r\nimport Menu from './states/Menu';\r\nimport Game from './states/Game';\r\n\r\nclass ProjectNostradamus extends Phaser.Game {\r\n  constructor( width, height, renderer, parent ) {\r\n    super( width, height, renderer, parent );\r\n    this.state.add( 'Preload', Preload );\r\n    this.state.add( 'Boot', Boot );\r\n    this.state.add( 'Preload', Preload );\r\n    this.state.add( 'Menu', Menu );\r\n    this.state.add( 'Game', Game );\r\n\r\n    this.state.start( 'Boot' );\r\n  }\r\n}\r\nexport default ProjectNostradamus;\r\n",
    "export const PLAYER_WIDTH = 30;\r\nexport const PLAYER_HEIGHT = 24;\r\nexport const PLAYER_INITIAL_FRAME = 1;\r\nexport const PLAYER_SPEED = 120;\r\nexport const PLAYER_SNEAK_MULTIPLIER = 0.75;\r\nexport const PLAYER_SPRINT_MULTIPLIER = 2 * 1.5;\r\nexport const PLAYER_WALK_ANIMATION_FRAMERATE = 5;\r\nexport const PLAYER_FIGHT_ANIMATION_FRAMERATE = 10;\r\nexport const PLAYER_HAND_ATTACK_RANGE = 50;\r\nexport const PLAYER_HAND_ATTACK_ANGLE = 60;\r\nexport const PLAYER_HAND_ATTACK_DAMAGE = 0.2;\r\n",
    "export const TILE_WIDTH = 64;\r\nexport const TILE_HEIGHT = 64;\r\nexport const MAP_WIDTH = 32;\r\nexport const MAP_HEIGHT = 32;\r\n",
    "export const ZOMBIE_WIDTH = 30;\r\nexport const ZOMBIE_HEIGHT = 24;\r\nexport const ZOMBIE_INITIAL_FRAME = 1;\r\nexport const ZOMBIE_SPEED = 50;\r\nexport const ZOMBIE_SPEED_CHASING_MULTIPLIER = 2;\r\nexport const ZOMBIE_LOOKING_OFFSET = 10;\r\nexport const ZOMBIE_WALK_ANIMATION_FRAMERATE = 5;\r\nexport const ZOMBIE_FIGHT_ANIMATION_FRAMERATE = 10;\r\nexport const MIN_DISTANCE_TO_TARGET = 10;\r\nexport const ZOMBIE_SIGHT_ANGLE = 45;\r\nexport const ZOMBIE_SIGHT_RANGE = 500;\r\nexport const ZOMBIE_HEARING_RANGE = 100;\r\nexport const ZOMBIE_ROTATING_SPEED = 50;\r\nexport const ZOMBIE_DAMAGE_MULTIPLIER = 1;\r\nexport const ZOMBIE_DAMAGE_COOLDOWN = 0.05;\r\n",
    "import ProjectNostradamus from './ProjectNostradamus';\r\n\r\nnew ProjectNostradamus( '100%', '100%', Phaser.AUTO, 'content' );\r\n\r\n/*\r\n!!! This is protection against leaving page while still in game. It is commented out since it was driving me crazy that i had to confirm leavinmg every time browsersync fired. !!!\r\nwindow.onbeforeunload = (e) => {\r\n  return 'Really want to quit the game?';\r\n};\r\n\r\ndocument.onkeydown = ( e ) => {\r\n  e = e || window.event;\r\n  if ( e.ctrlKey ) {\r\n    const c = e.which || e.keyCode;\r\n    switch ( c ) {\r\n    case 83:\r\n    case 87:\r\n      e.preventDefault();\r\n      e.stopPropagation();\r\n      break;\r\n    }\r\n  }\r\n};\r\n*/\r\n",
    "class Entity extends Phaser.Sprite {\r\n  constructor( game, x, y, imageKey, frame ) {\r\n    super( game, x, y, imageKey, frame );\r\n\r\n    this.anchor.setTo( 0.5, 0.5 );\r\n\r\n    this.game.physics.p2.enable( this );\r\n    this.body.collideWorldBounds = true;\r\n\r\n    this.game.world.add( this );\r\n  }\r\n  lookAt( targetX, targetY ) {\r\n    const targetPoint = new Phaser.Point( targetX, targetY );\r\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\r\n\r\n    let targetAngle = Phaser.Math.radToDeg( Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) ) - 90;\r\n\r\n    if ( targetAngle < 0 ) {\r\n      targetAngle += 360;\r\n    }\r\n\r\n    this.body.angle = targetAngle;\r\n  }\r\n  normalizeVelocity() {\r\n    if ( this.body.velocity.x !== 0 && this.body.velocity.y !== 0 ) {\r\n      this.body.velocity.x = this.body.velocity.x * Math.sqrt( 2 ) * 1 / 2;\r\n      this.body.velocity.y = this.body.velocity.y * Math.sqrt( 2 ) * 1 / 2;\r\n    }\r\n  }\r\n  resetVelocity() {\r\n    this.body.velocity.x = 0;\r\n    this.body.velocity.y = 0;\r\n  }\r\n  isMoving() {\r\n    return this.body.velocity.x !== 0 || this.body.velocity.y !== 0;\r\n  }\r\n  isInDegreeRange( entity, target, sightAngle ) {\r\n    const angleDelta = Math.abs( Phaser.Math.radToDeg( Phaser.Math.angleBetween( entity.x, entity.y, target.x, target.y ) ) + 90 - entity.angle );\r\n\r\n    return angleDelta <= sightAngle || angleDelta >= ( 360 - sightAngle );\r\n  }\r\n}\r\n\r\nexport default Entity;\r\n",
    "import Entity from './Entity';\r\nimport PathFinder from '../objects/PathFinder.js';\r\nimport { ZOMBIE_SPEED, ZOMBIE_ROTATING_SPEED, MIN_DISTANCE_TO_TARGET } from '../constants/ZombieConstants';\r\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\r\nimport { tileToPixels, getWallsPostions } from '../utils/MapUtils.js';\r\n\r\n/** Create Entity that is supposed to walk on given path. Set position of entity on first given target*/\r\nexport default class EntityWalkingOnPath extends Entity {\r\n  constructor( game, imageKey, frame, targets, walls ) {\r\n    const position = tileToPixels( targets[ 0 ] );\r\n\r\n    super( game, position.x, position.y, imageKey, frame );\r\n\r\n    this.pathfinder = new PathFinder();\r\n    this.wallsPositions = getWallsPostions( walls );\r\n\r\n    this.pathfinder.setGrid( this.wallsPositions );\r\n\r\n    this.targets = targets;\r\n\r\n    this.pathsBetweenPathTargets = [];\r\n\r\n    this.currentPathIndex = 0;\r\n    this.currentStepIndex = 0;\r\n\r\n    this.isOnStandardPath = true;\r\n    this.temporaryPath = [];\r\n    this.temporaryStepIndex = 0;\r\n\r\n    /* disable update until paths are calculated */\r\n    this.isInitialized = false;\r\n    this.canMove = false;\r\n\r\n    this.calculatePathsBetweenTargets( () => {\r\n      this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\r\n      this.isInitialized = true;\r\n      this.canMove = true;\r\n    } );\r\n  }\r\n  /**Recursive function that calculates standard paths and save them into pathsBetweenPathTargets container.  Recurse approach is used to handle asynchronous nature of findPath method */\r\n  calculatePathsBetweenTargets( doneCallback, index = 0 ) {\r\n    if ( this.pathsBetweenPathTargets.length === this.targets.length ) {\r\n      doneCallback();\r\n      return;\r\n    }\r\n\r\n    const start = this.targets[ index ];\r\n    const target = ( index === this.targets.length - 1 ) ? this.targets[ 0 ] : this.targets[ index + 1 ];\r\n\r\n    this.pathfinder.findPath( start.x, start.y, target.x, target.y, ( path ) => {\r\n      this.pathsBetweenPathTargets.push( { path, start, target } );\r\n      this.calculatePathsBetweenTargets( doneCallback, index + 1 );\r\n    } );\r\n  }\r\n  update() {\r\n    /** Check if current target or step target is reached. Move body in stepTarget direction. */\r\n    if ( this.canMove ) {\r\n      if ( this.isReached( this.stepTarget ) ) {\r\n        this.onStepTargetReach();\r\n      }\r\n      this.game.physics.arcade.moveToObject( this, tileToPixels( this.stepTarget ), ZOMBIE_SPEED );\r\n\r\n      this.updateLookDirection();\r\n    }\r\n  }\r\n  /** When current step target or temporary step target is reached, set step target to the next one.*/\r\n  /** If current target is reached or temporary target is reached set path to the next one, or get back to standard path*/\r\n  onStepTargetReach() {\r\n    if ( this.isOnStandardPath ) {\r\n      if ( this.currentStepIndex + 1 === this.pathsBetweenPathTargets[ this.currentPathIndex ].path.length ) {\r\n        this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenPathTargets.length ) ? 0 : this.currentPathIndex + 1;\r\n        this.currentStepIndex = 0;\r\n      } else {\r\n        this.currentStepIndex++;\r\n      }\r\n      this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\r\n    } else {\r\n      if ( this.temporaryStepIndex + 1 === this.temporaryPath.length ) {\r\n        this.changePathToStandard();\r\n      } else {\r\n        this.temporaryStepIndex++;\r\n        this.stepTarget = this.temporaryPath[ this.temporaryStepIndex ];\r\n      }\r\n    }\r\n  }\r\n  updateLookDirection() {\r\n    const lookTarget = this.getTilesEndCoords( this.stepTarget );\r\n    const targetPoint = new Phaser.Point( lookTarget.x, lookTarget.y );\r\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\r\n\r\n    let deltaTargetRad = this.rotation - Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) - 1.5 * Math.PI;\r\n\r\n    deltaTargetRad = deltaTargetRad % ( Math.PI * 2 );\r\n\r\n    if ( deltaTargetRad != deltaTargetRad % ( Math.PI ) ) {\r\n      deltaTargetRad = deltaTargetRad + Math.PI * ( ( deltaTargetRad < 0 ) ? 2 : -2 );\r\n    }\r\n\r\n    this.body.rotateLeft( ZOMBIE_ROTATING_SPEED * deltaTargetRad );\r\n  }\r\n  getTilesEndCoords( tile ) {\r\n    const tileCoords = tileToPixels( tile );\r\n    const veryFarAway = 1000;\r\n    if ( Math.abs( this.body.velocity.x ) > Math.abs( this.body.velocity.y ) ) {\r\n      if ( this.body.velocity.x > 0 ) {\r\n        tileCoords.x += veryFarAway * TILE_WIDTH;\r\n      } else {\r\n        tileCoords.x -= veryFarAway * TILE_WIDTH;\r\n      }\r\n    } else if ( Math.abs( this.body.velocity.x ) < Math.abs( this.body.velocity.y ) ) {\r\n      if ( this.body.velocity.y > 0 ) {\r\n        tileCoords.y += veryFarAway * TILE_HEIGHT;\r\n      } else {\r\n        tileCoords.y -= veryFarAway * TILE_HEIGHT;\r\n      }\r\n    }\r\n\r\n    return tileCoords;\r\n  }\r\n  isReached( target ) {\r\n    const distanceToTarget = this.game.physics.arcade.distanceBetween( this, tileToPixels( target ) );\r\n    return distanceToTarget <= MIN_DISTANCE_TO_TARGET;\r\n  }\r\n  calculateTemporaryPath( start, target, callback ) {\r\n    this.pathfinder.findPath( start.x, start.y, target.x, target.y, callback );\r\n  }\r\n  /**\r\n  * Change path to temporary and automatically get back to standard path, after reaching temporary target.\r\n  * @param {tile} start - start tile coordinates, if this tile is different that entity's tile then it goes straight to this tile.\r\n  */\r\n  changePathToTemporary( start ) {\r\n    const currentTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].target;\r\n\r\n    this.canMove = false;\r\n    this.calculateTemporaryPath( start, currentTarget, ( path ) => {\r\n      if ( path.length === 0 ) {\r\n        this.changePathToStandard();\r\n        return;\r\n      }\r\n      this.temporaryPath = path;\r\n      this.temporaryStepIndex = 0;\r\n      this.stepTarget = path[ this.temporaryStepIndex ];\r\n      this.isOnStandardPath = false;\r\n      this.canMove = true;\r\n    } );\r\n  }\r\n  changePathToStandard() {\r\n    this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenPathTargets.length ) ? 0 : this.currentPathIndex + 1;\r\n    this.currentStepIndex = 0;\r\n    this.stepTarget = this.pathsBetweenPathTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\r\n    this.isOnStandardPath = true;\r\n  }\r\n  disableMovement() {\r\n    this.canMove = false;\r\n    this.resetVelocity();\r\n  }\r\n  enableMovement() {\r\n    this.canMove = true;\r\n  }\r\n}\r\n",
    "import EasyStar from 'easystarjs';\r\n\r\nexport default class PathFinder {\r\n  constructor( ) {\r\n    this.easystar = new EasyStar.js();\r\n\r\n    this.easystar.setAcceptableTiles( [ 0 ] );\r\n  }\r\n  setGrid( grid ) {\r\n    this.easystar.setGrid( grid );\r\n  }\r\n  findPath( startX, startY, endX, endY, callback ) {\r\n    this.easystar.findPath( startX, startY, endX, endY, callback );\r\n    this.easystar.calculate();\r\n  }\r\n}\r\n",
    "import Entity from './Entity';\r\nimport { PLAYER_WIDTH, PLAYER_HEIGHT, PLAYER_SPEED, PLAYER_SNEAK_MULTIPLIER, PLAYER_SPRINT_MULTIPLIER, PLAYER_WALK_ANIMATION_FRAMERATE, PLAYER_FIGHT_ANIMATION_FRAMERATE, PLAYER_HAND_ATTACK_RANGE, PLAYER_HAND_ATTACK_ANGLE, PLAYER_HAND_ATTACK_DAMAGE } from '../constants/PlayerConstants';\r\n\r\nexport default class Player extends Entity {\r\n  constructor( game, x, y, imageKey, frame, zombies ) {\r\n    super( game, x, y, imageKey, frame );\r\n\r\n    this.width = PLAYER_WIDTH;\r\n    this.height = PLAYER_HEIGHT;\r\n\r\n    this.zombies = zombies.children;\r\n\r\n    this.isSneaking = false;\r\n    this.isSprinting = false;\r\n\r\n    this.attackRange = PLAYER_HAND_ATTACK_RANGE;\r\n    this.dealingDamage = PLAYER_HAND_ATTACK_DAMAGE;\n\n    this.healthbar = this.game.add.graphics( 0, 0 );\r\n    this.healthbar.anchor.x = 1;\r\n    this.healthbar.anchor.y = 1;\r\n    this.healthbar.fixedToCamera = true;\r\n\r\n    this.cursors = {\r\n      up: this.game.input.keyboard.addKey( Phaser.Keyboard.W ),\r\n      down: this.game.input.keyboard.addKey( Phaser.Keyboard.S ),\r\n      left: this.game.input.keyboard.addKey( Phaser.Keyboard.A ),\r\n      right: this.game.input.keyboard.addKey( Phaser.Keyboard.D ),\r\n      sneak: this.game.input.keyboard.addKey( Phaser.Keyboard.ALT ),\r\n      sprint: this.game.input.keyboard.addKey( Phaser.Keyboard.SHIFT ),\r\n    };\r\n\r\n    this.animations.add( 'walk', [ 1, 2, 1, 0 ], 1 );\r\n    this.animations.add( 'fight', [ 3, 5, 4 ], 3 );\r\n\r\n    this.body.clearShapes();\r\n    this.body.addCircle( Math.max( PLAYER_WIDTH, PLAYER_HEIGHT ) );\r\n\r\n    this.drawHealthBar();\r\n  }\r\n\r\n  update() {\r\n    this.handleMovement();\r\n    this.handleAnimation();\r\n    this.lookAtMouse();\r\n    this.handleAttack();\r\n    // console.log( this.zombies.children );\r\n  }\r\n  handleMovement() {\r\n    this.resetVelocity();\r\n\r\n    if ( this.cursors.up.isDown ) {\r\n      this.body.velocity.y = -PLAYER_SPEED;\r\n    } else if ( this.cursors.down.isDown ) {\r\n      this.body.velocity.y = PLAYER_SPEED;\r\n    }\r\n\r\n    if ( this.cursors.left.isDown ) {\r\n      this.body.velocity.x = -PLAYER_SPEED;\r\n    } else if ( this.cursors.right.isDown ) {\r\n      this.body.velocity.x = PLAYER_SPEED;\r\n    }\r\n\r\n    this.handleMovementSpecialModes();\r\n\r\n    this.normalizeVelocity();\r\n  }\r\n  handleMovementSpecialModes() {\r\n    let specialEffectMultiplier = 1;\r\n\r\n    this.isSneaking = false;\r\n    this.isSprinting = false;\r\n\r\n    if ( this.cursors.sneak.isDown ) {\r\n      specialEffectMultiplier = PLAYER_SNEAK_MULTIPLIER;\r\n      this.isSneaking = true;\r\n    } else if ( this.cursors.sprint.isDown ) {\r\n      specialEffectMultiplier = PLAYER_SPRINT_MULTIPLIER;\r\n      this.isSprinting = true;\r\n    }\r\n\r\n    this.body.velocity.x *= specialEffectMultiplier;\r\n    this.body.velocity.y *= specialEffectMultiplier;\r\n  }\r\n  handleAnimation() {\r\n    if ( this.body.velocity.x !== 0 || this.body.velocity.y !== 0 ) {\r\n      this.animations.play( 'walk', PLAYER_WALK_ANIMATION_FRAMERATE, true );\r\n    } else {\r\n      this.animations.stop( 'walk', true );\r\n    }\r\n    if ( this.game.input.activePointer.leftButton.isDown ) {\r\n      this.animations.play( 'fight', PLAYER_FIGHT_ANIMATION_FRAMERATE, false );\r\n    }\r\n  }\r\n\r\n  lookAtMouse() {\r\n    const mouseX = this.game.input.mousePointer.worldX;\r\n    const mouseY = this.game.input.mousePointer.worldY;\r\n\r\n    this.lookAt( mouseX, mouseY );\r\n  }\r\n\r\n  handleAttack() {\r\n    if ( this.game.input.activePointer.leftButton.isDown ) {\r\n      this.zombies.forEach( ( v ) => {\r\n        if ( v.alive ) {\r\n          const distanceToZombie = this.game.physics.arcade.distanceBetween( this, v );\r\n          if ( distanceToZombie < this.attackRange && this.isInDegreeRange( this, v, PLAYER_HAND_ATTACK_ANGLE ) ) {\r\n            v.takeDamage( this.dealingDamage );\r\n          }\r\n        }\r\n      } );\r\n    }\r\n  }\r\n\r\n  takeDamage( damage ) {\r\n    this.damage( damage );\r\n    this.drawHealthBar();\r\n  }\n\n  drawHealthBar() {\n    const width = 300;\n    const height = 32;\n\n    this.healthbar.clear();\n    this.healthbar.beginFill( 0xFF0000, 0.85 );\r\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width * Math.max( this.health, 0 ), height );\r\n    this.healthbar.endFill();\r\n    this.healthbar.lineStyle( 2, 0x880000, 1 );\r\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width, height );\r\n    this.healthbar.lineStyle( 0 );\r\n  }\r\n}\n",
    "import { pixelsToTile } from '../utils/MapUtils.js';\r\n\r\nexport default class TileMap extends Phaser.Tilemap {\r\n  constructor( game, key, tileWidth, tileHeight ) {\r\n    super( game, key, tileWidth, tileHeight );\r\n\r\n    this.addTilesetImage( 'tilemap' );\r\n\r\n    this.ground = this.createLayer( 'background' );\r\n    this.walls = this.createLayer( 'walls' );\r\n\r\n    this.paths = [];\r\n\r\n    this.setCollisionByExclusion( [], true, this.walls );\r\n\r\n    this.ground.resizeWorld();\r\n\r\n    this.wallsBodiesArray = game.physics.p2.convertTilemap( this, this.walls );\r\n\r\n    this.wallsCollisionGroup = this.game.physics.p2.createCollisionGroup();\r\n\r\n    for ( const body of this.wallsBodiesArray ) {\r\n      body.setCollisionGroup( this.wallsCollisionGroup );\r\n    }\r\n\r\n    this.createPathPoints();\r\n  }\r\n  collides( collisionGroup, callback ) {\r\n    for ( const body of this.wallsBodiesArray ) {\r\n      body.collides( collisionGroup, callback );\r\n    }\r\n  }\r\n  createPathPoints() {\r\n    this.objects[ 'ZombiePaths' ].forEach( ( v ) => {\r\n      const props = v.properties;\r\n      if ( !this.paths[ props.PathId ] ) {\r\n        this.paths[ props.PathId ] = [];\r\n      }\r\n\r\n      this.paths[ props.PathId ][ props.PathIndex ] = pixelsToTile( { x: v.x, y: v.y } );\r\n    } );\r\n\r\n    this.normalizePaths();\r\n  }\r\n  normalizePaths() {\r\n    this.paths.forEach( ( pathArr ) => {\r\n      const tempArr = [];\r\n      pathArr.forEach( ( v ) => {\r\n        tempArr.push( v );\r\n      } );\r\n\r\n      pathArr = tempArr;\r\n    } );\r\n  }\r\n  getPath( i ) {\r\n    return this.paths[ i ];\r\n  }\r\n}\r\n",
    "import { willEntitiesBeOnTheSameTile, getFreeTileAroundEntityExcludingOtherEntity, getDirectionBetweenEntities } from '../utils/EntityManagerUtils';\r\nimport { pixelsToTile, getWallsPostions } from '../utils/MapUtils.js';\r\nimport BoidsManager from '../utils/BoidsManager.js';\r\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\r\n\r\nexport default class WalkingEntitiesManager extends Phaser.Group {\r\n  constructor( game, grid ) {\r\n    super( game );\r\n    this.mapGrid = getWallsPostions( grid );\r\n    this.allEntitiesInitialized = false;\r\n\r\n    this.boidsManager = new BoidsManager( this.game, this.children, this.mapGrid );\r\n  }\r\n  update() {\r\n    if ( this.allEntitiesInitialized || this.areAllEntitiesInitialized() ) {\r\n      this.manageMovingEntities();\r\n    }\r\n\r\n    Phaser.Group.prototype.update.call( this );\r\n\r\n    this.boidsManager.update();\r\n  }\r\n  manageMovingEntities() {\r\n    for ( const entityIndex1 in this.children ) {\r\n      for ( const entityIndex2 in this.children ) {\r\n        if ( entityIndex1 === entityIndex2 ) {\r\n          continue;\r\n        }\r\n        const currentHandledEntity = this.children[ Math.min( entityIndex1, entityIndex2 ) ];\r\n        const otherEntity = this.children[ Math.max( entityIndex1, entityIndex2 ) ];\r\n\r\n        if ( currentHandledEntity.canMove && otherEntity.canMove && willEntitiesBeOnTheSameTile( currentHandledEntity, otherEntity ) ) {\r\n          const freeTile = getFreeTileAroundEntityExcludingOtherEntity( currentHandledEntity, otherEntity, this.mapGrid );\r\n          const currentTarget = currentHandledEntity.pathsBetweenPathTargets[ currentHandledEntity.currentPathIndex ].target;\r\n\r\n          currentHandledEntity.changePathToTemporary( freeTile, currentTarget );\r\n        }\r\n      }\r\n    }\r\n  }\r\n  onCollisionWihOtherEntity( entity1, entity2 ) {\r\n    const freeTile1 = getFreeTileAroundEntityExcludingOtherEntity( entity1, entity2, this.mapGrid );\r\n    const freeTile2 = getFreeTileAroundEntityExcludingOtherEntity( entity2, entity1, this.mapGrid );\r\n\r\n    entity1.changePathToTemporary( freeTile1 );\r\n    entity1.changePathToTemporary( freeTile2 );\r\n  }\r\n  onCollisionWithWalls( entity, tileBody ) {\r\n    if ( entity.isChasing === false ) {\r\n      this.findAdjoiningFreeTileAndGoBackOnPath( entity, tileBody );\r\n    } else {\r\n      this.resetVelocityInCorrespondingDimension( entity, tileBody );\r\n    }\r\n  }\r\n  findAdjoiningFreeTileAndGoBackOnPath( entity, tileBody ) {\r\n    const entityTile = pixelsToTile( entity );\r\n    const tile = pixelsToTile( { x: tileBody.x + TILE_WIDTH / 2, y: tileBody.y + TILE_HEIGHT / 2 } );\r\n    let freeTile;\r\n\r\n    if ( entityTile.x > tile.x ) {\r\n      freeTile = { x: entityTile.x + 1, y: entityTile.y };\r\n    } else if ( entityTile.x < tile.x ) {\r\n      freeTile = { x: entityTile.x - 1, y: entityTile.y };\r\n    } else if ( entityTile.y < tile.y ) {\r\n      freeTile = { x: entityTile.x, y: entityTile.y - 1 };\r\n    } else if ( entityTile.y > tile.y ) {\r\n      freeTile = { x: entityTile.x, y: entityTile.y + 1 };\r\n    }\r\n\r\n    entity.changePathToTemporary( freeTile );\r\n  }\r\n  resetVelocityInCorrespondingDimension( entity, tileBody ) {\r\n    const direction = getDirectionBetweenEntities( entity, tileBody );\r\n    // direction is not always correct becuase of the cases when zombie is colliding with tile's corner\r\n    if ( direction === 'NORTH' || direction === 'SOUTH' ) {\r\n      entity.body.velocity.x = ( entity.body.velocity.x / Math.abs( entity.body.velocity.x ) ) * Math.sqrt( Math.pow( entity.body.velocity.x, 2 ) + Math.pow( entity.body.velocity.y, 2 ) );\r\n      entity.body.velocity.y = 0;\r\n    } else {\r\n      entity.body.velocity.y = ( entity.body.velocity.y / Math.abs( entity.body.velocity.y ) ) * Math.sqrt( Math.pow( entity.body.velocity.x, 2 ) + Math.pow( entity.body.velocity.y, 2 ) );\r\n      entity.body.velocity.x = 0;\r\n    }\r\n  }\r\n  areAllEntitiesInitialized() {\r\n    for ( const entity of this.children ) {\r\n      if ( !entity.isInitialized ) {\r\n        return false;\r\n      }\r\n    }\r\n    this.allEntitiesInitialized = true;\r\n    return true;\r\n  }\r\n}\r\n",
    "import EntityWalkingOnPath from './EntityWalkingOnPath';\r\nimport { ZOMBIE_SPEED, MIN_DISTANCE_TO_TARGET, ZOMBIE_SPEED_CHASING_MULTIPLIER, ZOMBIE_SIGHT_ANGLE, ZOMBIE_SIGHT_RANGE, ZOMBIE_HEARING_RANGE, ZOMBIE_DAMAGE_TAKEN, ZOMBIE_DAMAGE_COOLDOWN, ZOMBIE_DAMAGE_MULTIPLIER } from '../constants/ZombieConstants';\r\nimport { pixelsToTile } from '../utils/MapUtils.js';\r\n\r\nexport default class Zombie extends EntityWalkingOnPath {\r\n  constructor( game, imageKey, frame, targets, walls, player ) {\r\n    super( game, imageKey, frame, targets, walls );\r\n\r\n    this.player = player;\r\n    this.walls = walls;\r\n    this.playerSeekingRay = new Phaser.Line();\r\n    this.tileHits = [];\r\n    this.isChasing = false;\r\n    this.lastKnownPlayerPosition = { x: 1, y: 1 };\r\n    this.canDealDamage = true;\r\n\r\n    this.damageTaken = ZOMBIE_DAMAGE_TAKEN;\r\n  }\r\n  update() {\r\n    if ( this.canSeePlayer() ) {\r\n      this.isChasing = true;\r\n      this.lastKnownPlayerPosition = { x: this.player.x, y: this.player.y };\r\n      if ( this.alive ) {\r\n        this.dealDamage();\r\n      }\r\n    }\r\n\r\n    if ( !this.isChasing ) {\r\n      EntityWalkingOnPath.prototype.update.call( this );\r\n    } else {\r\n      this.chasePlayer();\r\n    }\r\n  }\r\n  canSeePlayer() {\r\n    /** Draw line between player and zombie and check if it can see him. If yes, chase him. */\r\n    this.playerSeekingRay.start.set( this.x, this.y );\r\n    this.playerSeekingRay.end.set( this.player.x, this.player.y );\r\n\r\n    this.tileHits = this.walls.getRayCastTiles( this.playerSeekingRay, 0, false, false );\r\n\r\n    if ( this.tileHits.length > 0 ) {\r\n      for ( let i = 0; i < this.tileHits.length; i++ ) {\r\n        if ( this.tileHits[ i ].index >= 0 ) {\r\n          return false;\r\n        }\r\n      }\r\n    }\r\n\r\n    return ( this.isInDegreeRange( this, this.player, ZOMBIE_SIGHT_ANGLE )\r\n    && ( this.isChasing || this.playerSeekingRay.length < ZOMBIE_SIGHT_RANGE ) )\r\n    || ( this.playerSeekingRay.length < ZOMBIE_HEARING_RANGE && !this.player.isSneaking && this.player.isMoving() );\r\n  }\r\n\r\n  chasePlayer() {\r\n    this.game.physics.arcade.moveToObject( this, this.lastKnownPlayerPosition, ZOMBIE_SPEED * ZOMBIE_SPEED_CHASING_MULTIPLIER );\r\n    this.lookAt( this.lastKnownPlayerPosition.x, this.lastKnownPlayerPosition.y );\r\n\r\n    const distanceToTarget = this.game.physics.arcade.distanceBetween( this, this.lastKnownPlayerPosition );\r\n    if ( !this.canSeePlayer() && ( distanceToTarget <= MIN_DISTANCE_TO_TARGET ) ) {\r\n      this.stopChasingPlayer();\r\n    }\r\n  }\r\n\r\n  dealDamage() {\r\n    if ( this.canDealDamage ) {\r\n      const distanceToPlayer = this.game.physics.arcade.distanceBetween( this, this.player );\r\n      if ( distanceToPlayer < 50 ) {\r\n        this.player.takeDamage( 0.1 );\r\n        this.canDealDamage = false;\r\n        this.game.time.events.add( Phaser.Timer.SECOND * ZOMBIE_DAMAGE_COOLDOWN, this.endCooldown, this );\r\n      }\r\n    }\r\n  }\r\n\r\n  takeDamage( damage ) {\r\n    this.damage( damage * ZOMBIE_DAMAGE_MULTIPLIER );\r\n  }\r\n\r\n  endCooldown() {\r\n    this.canDealDamage = true;\r\n  }\r\n\r\n  stopChasingPlayer() {\r\n    this.body.velocity.x = 0;\r\n    this.body.velocity.y = 0;\r\n    this.isChasing = false;\r\n    this.changePathToTemporary( pixelsToTile( this ) );\r\n  }\r\n\r\n}\r\n",
    "import WalkingEntitiesManager from '../objects/WalkingEntitiesManager';\r\n\r\nexport default class ZombieManager extends WalkingEntitiesManager {\r\n  constructor( game, grid ) {\r\n    super( game, grid );\r\n  }\r\n\r\n  update() {\r\n    WalkingEntitiesManager.prototype.update.call( this );\r\n  }\r\n\r\n}\r\n",
    "class Boot extends Phaser.State {\r\n  preload() {\r\n  }\r\n  create() {\r\n    // this.game.stage.disableVisibilityChange = true;\r\n\r\n    // this.game.scale.maxWidth = 800;\r\n    // this.game.scale.maxHeight = 600;\r\n\r\n    this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\r\n    this.game.scale.updateLayout();\r\n\r\n    this.game.physics.startSystem( Phaser.Physics.P2JS );\r\n    this.game.physics.p2.setImpactEvents( true );\r\n    this.state.start( 'Preload' );\r\n  }\r\n}\r\n\r\nexport default Boot;\r\n",
    "import Player from '../objects/Player';\r\nimport Zombie from '../objects/Zombie';\r\nimport TileMap from '../objects/TileMap';\r\nimport ZombiesManager from '../objects/ZombiesManager';\r\n\r\nimport { PLAYER_INITIAL_FRAME } from '../constants/PlayerConstants';\r\nimport { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\r\n\r\nexport default class Game extends Phaser.State {\r\n  create() {\r\n    this.map = new TileMap( this.game, 'map', TILE_WIDTH, TILE_HEIGHT );\r\n\r\n    this.zombies = new ZombiesManager( this.game, this.map.walls );\r\n\r\n    this.player = new Player( this.game, 10 * TILE_WIDTH + TILE_WIDTH / 2, 2 * TILE_HEIGHT + TILE_HEIGHT / 2, 'player', PLAYER_INITIAL_FRAME, this.zombies );\r\n    this.game.camera.follow( this.player );\r\n\r\n    this.playerCollisionGroup = this.game.physics.p2.createCollisionGroup( this.player );\r\n    this.zombiesCollisionGroup = this.game.physics.p2.createCollisionGroup();\r\n\r\n    for ( let i = 0; i < this.map.paths.length; i++ ) {\r\n      const newZombie = this.zombies.add( new Zombie( this.game, 'zombie', PLAYER_INITIAL_FRAME, this.map.getPath( i ), this.map.walls, this.player ) );\r\n\r\n      newZombie.body.setCollisionGroup( this.zombiesCollisionGroup );\r\n      newZombie.body.collides( this.zombiesCollisionGroup, ( body1, body2 ) => this.zombies.onCollisionWihOtherEntity( body1.sprite, body2.sprite ) );\r\n      newZombie.body.collides( this.map.wallsCollisionGroup, ( body, tileBody ) => this.zombies.onCollisionWithWalls( body.sprite, tileBody ) );\r\n      newZombie.body.collides( this.playerCollisionGroup );\r\n    }\r\n    this.player.body.collides( [ this.zombiesCollisionGroup, this.map.wallsCollisionGroup ] );\r\n\r\n    this.map.collides( [ this.zombiesCollisionGroup, this.playerCollisionGroup ] );\r\n  }\r\n  update() {\r\n  }\r\n}\r\n",
    "class Menu extends Phaser.State {\r\n  create() {\r\n    this.state.start( 'Game' );\r\n  }\r\n}\r\n\r\nexport default Menu;\r\n",
    "import { PLAYER_WIDTH, PLAYER_HEIGHT } from '../constants/PlayerConstants.js';\r\nimport { ZOMBIE_WIDTH, ZOMBIE_HEIGHT } from '../constants/ZombieConstants.js';\r\n\r\nclass Preload extends Phaser.State {\r\n  preload() {\r\n    this.load.tilemap( 'map', 'assets/tilemaps/maps/map.json', null, Phaser.Tilemap.TILED_JSON );\r\n    this.load.image( 'tilemap', 'assets/tilemaps/tiles/tilemap.png' );\r\n\r\n    this.game.load.spritesheet( 'player', './assets/images/player-sheet.png', PLAYER_WIDTH, PLAYER_HEIGHT );\r\n    this.game.load.spritesheet( 'zombie', './assets/images/zombie-sheet.png', ZOMBIE_WIDTH, ZOMBIE_HEIGHT );\r\n  }\r\n  create() {\r\n    this.state.start( 'Menu' );\r\n  }\r\n}\r\n\r\nexport default Preload;\r\n",
    "import { TILE_WIDTH, TILE_HEIGHT } from '../constants/TileMapConstants';\r\nimport { pixelsToTile, tileToPixels } from '../utils/MapUtils.js';\r\n\r\nexport default class BoidsManager {\r\n  constructor( game, entities, mapGrid, boidsDistance = Math.max( TILE_WIDTH, TILE_HEIGHT ), distanceBetweenBoidsAndWalls = boidsDistance ) {\r\n    this.entities = entities;\r\n    this.mapGrid = mapGrid;\r\n    this.boidsDistance = boidsDistance;\r\n    this.distanceBetweenBoidsAndWalls = distanceBetweenBoidsAndWalls;\r\n    this.game = game;\r\n  }\r\n  update() {\r\n    for ( const boid of this.entities ) {\r\n      if ( boid.isChasing === false ) {\r\n        continue;\r\n      }\r\n      const velocity1 = this.flyTowardsMassCenterRule( boid );\r\n      const velocity2 = this.keepSmallDistanceFromObstaclesRule( boid );\r\n      const velocity3 = this.tryMatchingOtherEnitiesVelocityRule( boid );\r\n\r\n      boid.body.velocity.x += velocity1.x + velocity2.x + velocity3.x;\r\n      boid.body.velocity.y += velocity1.y + velocity2.y + velocity3.y;\r\n    }\r\n  }\r\n  flyTowardsMassCenterRule( boid ) {\r\n    const velocity = { x: 0, y: 0 };\r\n\r\n    for ( const entity of this.entities ) {\r\n      if ( entity === boid ) {\r\n        continue;\r\n      }\r\n      velocity.x += entity.body.x;\r\n      velocity.y += entity.body.y;\r\n    }\r\n\r\n    velocity.x = ( velocity.x / ( this.entities.length - 1 ) ) / 100;\r\n    velocity.y = ( velocity.y / ( this.entities.length - 1 ) ) / 100;\r\n\r\n    return velocity;\r\n  }\r\n  keepSmallDistanceFromObstaclesRule( boid ) {\r\n    const velocity = { x: 0, y: 0 };\r\n\r\n    for ( const otherBoid of this.entities ) {\r\n      if ( otherBoid === boid ) {\r\n        continue;\r\n      }\r\n      if ( this.game.physics.arcade.distanceBetween( otherBoid, boid ) <= this.boidsDistance ) {\r\n        velocity.x -= otherBoid.body.x - boid.body.x;\r\n        velocity.y -= otherBoid.body.y - boid.body.y;\r\n      }\r\n    }\r\n\r\n    const wallBodies = this.getAdjoiningWallBodies( boid );\r\n    for ( const wallBody of wallBodies ) {\r\n      if ( this.game.physics.arcade.distanceBetween( wallBody, boid ) <= this.distanceBetweenBoidsAndWalls ) {\r\n        velocity.x -= wallBody.x - boid.body.x;\r\n        velocity.y -= wallBody.y - boid.body.y;\r\n      }\r\n    }\r\n\r\n    return velocity;\r\n  }\r\n  getAdjoiningWallBodies( entity ) {\r\n    const entityTile = pixelsToTile( entity );\r\n    const adjoiningTiles = [\r\n      { x: entityTile.x - 1, y: entityTile.y - 1 },\r\n      { x: entityTile.x - 1, y: entityTile.y },\r\n      { x: entityTile.x - 1, y: entityTile.y + 1 },\r\n      { x: entityTile.x, y: entityTile.y - 1 },\r\n      { x: entityTile.x, y: entityTile.y + 1 },\r\n      { x: entityTile.x + 1, y: entityTile.y - 1 },\r\n      { x: entityTile.x + 1, y: entityTile.y },\r\n      { x: entityTile.x + 1, y: entityTile.y + 1 },\r\n    ];\r\n\r\n    const adjoiningWallTiles = adjoiningTiles.filter( ( tile ) => this.mapGrid[ tile.y ][ tile.x ] === 1 );\r\n    return adjoiningWallTiles.map( tileToPixels );\r\n  }\r\n  tryMatchingOtherEnitiesVelocityRule() {\r\n    return { x: 0, y: 0 };\r\n  }\r\n}\r\n",
    "import { pixelsToTile } from '../utils/MapUtils';\r\n\r\nexport const getEntityNextTile = ( entity ) => {\r\n  if ( entity.isOnStandardPath ) {\r\n    let pathIndex = entity.currentPathIndex;\r\n    let stepIndex = entity.currentStepIndex;\r\n\r\n    if ( entity.pathsBetweenPathTargets[ pathIndex ].path.length === stepIndex + 1 ) {\r\n      stepIndex = 0;\r\n\r\n      if ( entity.pathsBetweenPathTargets.length === pathIndex + 1 ) {\r\n        pathIndex = 0;\r\n      } else {\r\n        pathIndex++;\r\n      }\r\n    } else {\r\n      stepIndex++;\r\n    }\r\n    if ( entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ] == undefined ) {\r\n      throw new Error( `Wrong path data: pathIndex: ${pathIndex}, stepIndex: ${stepIndex}, entity: ${entity}` );\r\n    }\r\n    return entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ];\r\n  } else {\r\n    let stepIndex = entity.temporaryStepIndex;\r\n    if ( stepIndex + 1 === entity.temporaryPath.length ) {\r\n      stepIndex = 0;\r\n      let pathIndex = ( entity.currentPathIndex + 1 === entity.pathsBetweenPathTargets.length ) ? 0 : entity.currentPathIndex + 1;\r\n      if ( entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ] == undefined ) {\r\n        throw new Error( `Wrong path data: pathIndex: ${pathIndex}, stepIndex: ${stepIndex}, entity: ${entity}` );\r\n      }\r\n      return entity.pathsBetweenPathTargets[ pathIndex ].path[ stepIndex ];\r\n    } else {\r\n      if ( entity.temporaryPath[ stepIndex ] == undefined ) {\r\n        throw new Error( `Wrong temporary path data: stepIndex: ${stepIndex}` );\r\n      }\r\n      return entity.temporaryPath[ stepIndex ];\r\n    }\r\n  }\r\n};\r\n\r\nconst areTilesTheSame = ( tile1, tile2 ) => tile1.x === tile2.x && tile1.y === tile2.y;\r\n\r\nexport const getEntityCurrentStepTarget = ( entity ) => ( entity.isOnStandardPath ) ? entity.pathsBetweenPathTargets[ entity.currentPathIndex ].path[ entity.currentStepIndex ] : entity.temporaryPath[ entity.temporaryStepIndex ];\r\n\r\nexport const willEntitiesBeOnTheSameTile = ( entity1, entity2 ) => {\r\n  const entityNextTarget1 = getEntityNextTile( entity1 );\r\n  const entityNextTarget2 = getEntityNextTile( entity2 );\r\n  const entityCurrentTarget1 = getEntityCurrentStepTarget( entity1 );\r\n  const entityCurrentTarget2 = getEntityCurrentStepTarget( entity2 );\r\n\r\n  return areTilesTheSame( entityNextTarget1, entityNextTarget2 )\r\n  || areTilesTheSame( entityNextTarget1, entityCurrentTarget2 )\r\n   || areTilesTheSame( entityCurrentTarget1, entityCurrentTarget2 );\r\n};\r\n\r\nconst getDirectionBetweenTiles = ( tile1, tile2 ) => {\r\n  if ( tile1.y === tile2.y ) {\r\n    if ( tile1.x > tile2.x ) {\r\n      return 'WEST';\r\n    } else if ( tile1.x < tile2.x ) {\r\n      return 'EAST';\r\n    } else {\r\n      throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\r\n    }\r\n  } else if ( tile1.x === tile2.x ) {\r\n    if ( tile1.y > tile2.y ) {\r\n      return 'NORTH';\r\n    } else if ( tile1.y < tile2.y ) {\r\n      return 'SOUTH';\r\n    } else {\r\n      throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\r\n    }\r\n  } else {\r\n    if ( tile1.y < tile2.y && tile1.x < tile2.x ) {\r\n      return ( Math.random() > 0.5 ) ? 'SOUTH' : 'EAST';\r\n    } else if ( tile1.y > tile2.y && tile1.x < tile2.x ) {\r\n      return ( Math.random() > 0.5 ) ? 'NORTH' : 'EAST';\r\n    } else if ( tile1.y < tile2.y && tile1.x > tile2.x ) {\r\n      return ( Math.random() > 0.5 ) ? 'NORTH' : 'WEST';\r\n    } else if ( tile1.y > tile2.y && tile1.x > tile2.x ) {\r\n      return ( Math.random() > 0.5 ) ? 'SOUTH' : 'WEST';\r\n    }\r\n  }\r\n  throw new Error( `Uncorrect tiles coordinates! tile1.x: ${ tile1.x }, tile1.y: ${ tile1.y } | tile2.x: ${ tile2.x } tile2.y: ${ tile2.y }` );\r\n};\r\n\r\nexport const getDirectionBetweenEntities = ( entity1, entity2 ) => {\r\n  const entityTile1 = pixelsToTile( entity1 );\r\n  const entityTile2 = pixelsToTile( entity2 );\r\n\r\n  if ( areTilesTheSame( entityTile1, entityTile2 ) ) {\r\n    // this case maybe can be handled better\r\n    return getDirectionBetweenTiles( entity1, entity2 );\r\n  } else {\r\n    return getDirectionBetweenTiles( entityTile1, entityTile2 );\r\n  }\r\n};\r\n\r\nexport const getFreeTileAroundEntityExcludingOtherEntity = ( entity, entityToExclude, mapGrid ) => {\r\n  const entityTile = pixelsToTile( entity );\r\n  const tileToExclude = getEntityNextTile( entityToExclude );\r\n\r\n  let directionToExclude;\r\n\r\n  if ( ( entityTile.x === tileToExclude.x && entityTile.y === tileToExclude.y ) || ( entityTile.x !== tileToExclude.x && entityTile.y !== tileToExclude.y ) ) {\r\n    directionToExclude = getDirectionBetweenEntities( entity, entityToExclude );\r\n  } else {\r\n    directionToExclude = getDirectionBetweenTiles( entityTile, tileToExclude );\r\n  }\r\n\r\n  switch ( directionToExclude ) {\r\n  case 'NORTH':\r\n    return getFreeTileExcludingNorth( entityTile, mapGrid );\r\n  case 'SOUTH':\r\n    return getFreeTileExcludingSouth( entityTile, mapGrid );\r\n  case 'WEST':\r\n    return getFreeTileExcludingWest( entityTile, mapGrid );\r\n  case 'EAST':\r\n    return getFreeTileExcludingEast( entityTile, mapGrid );\r\n  }\r\n\r\n  throw new Error( `Couldn't find free tile entityTile: ${entityTile}, directionToExclude: ${directionToExclude}` );\r\n};\r\n\r\nfunction getFreeTileExcludingNorth( entityTile, mapGrid ) {\r\n  let freeTile = { x: -1, y: entityTile.y };\r\n  if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 && mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\r\n    freeTile.x = ( Math.random() > 0.5 ) ? entityTile.x - 1 : entityTile.x + 1;\r\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\r\n    freeTile.x = entityTile.x - 1;\r\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\r\n    freeTile.x = entityTile.x + 1;\r\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\r\n    freeTile = { x: entityTile.x, y: entityTile.y + 1 };\r\n  }\r\n  return freeTile;\r\n}\r\nfunction getFreeTileExcludingSouth( entityTile, mapGrid ) {\r\n  let freeTile = { x: -1, y: entityTile.y };\r\n  if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 && mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\r\n    freeTile.x = ( Math.random() > 0.5 ) ? entityTile.x - 1 : entityTile.x + 1;\r\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\r\n    freeTile.x = entityTile.x - 1;\r\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\r\n    freeTile.x = entityTile.x + 1;\r\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\r\n    freeTile = { x: entityTile.x, y: entityTile.y - 1 };\r\n  }\r\n  return freeTile;\r\n}\r\nfunction getFreeTileExcludingWest( entityTile, mapGrid ) {\r\n  let freeTile = { x: entityTile.x, y: -1 };\r\n  if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 && mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\r\n    freeTile.y = ( Math.random() > 0.5 ) ? entityTile.y - 1 : entityTile.y + 1;\r\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\r\n    freeTile.y = entityTile.y - 1;\r\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\r\n    freeTile.y = entityTile.y + 1;\r\n  } else if ( mapGrid[ entityTile.x + 1 ][ entityTile.y ] === 0 ) {\r\n    freeTile = { x: entityTile.x + 1, y: entityTile.y };\r\n  }\r\n  return freeTile;\r\n}\r\nfunction getFreeTileExcludingEast( entityTile, mapGrid ) {\r\n  let freeTile = { x: entityTile.x, y: -1 };\r\n  if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 && mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\r\n    freeTile.y = ( Math.random() > 0.5 ) ? entityTile.y - 1 : entityTile.y + 1;\r\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y - 1 ] === 0 ) {\r\n    freeTile.y = entityTile.y - 1;\r\n  } else if ( mapGrid[ entityTile.x ][ entityTile.y + 1 ] === 0 ) {\r\n    freeTile.y = entityTile.y + 1;\r\n  } else if ( mapGrid[ entityTile.x - 1 ][ entityTile.y ] === 0 ) {\r\n    freeTile = { x: entityTile.x - 1, y: entityTile.y };\r\n  }\r\n  return freeTile;\r\n}\r\n",
    "import { TILE_WIDTH, TILE_HEIGHT, MAP_WIDTH } from '../constants/TileMapConstants';\r\n\r\nexport const pixelsToTileX = ( coord ) => Math.floor( coord / TILE_WIDTH );\r\nexport const pixelsToTileY = ( coord ) => Math.floor( coord / TILE_HEIGHT );\r\n\r\nexport const tileToPixels = ( tile ) => ( {\r\n  x: ( tile.x * TILE_WIDTH ) + TILE_WIDTH / 2,\r\n  y: ( tile.y * TILE_HEIGHT ) + TILE_HEIGHT / 2,\r\n} );\r\n\r\nexport const pixelsToTile = ( coords ) => ( {\r\n  x: Math.floor( coords.x / TILE_WIDTH ),\r\n  y: Math.floor( coords.y / TILE_HEIGHT ),\r\n} );\r\n\r\nexport const getWallsPostions = ( layer ) => {\r\n  const walls = layer.getTiles( 0, 0, 2048, 2048 );\r\n  const wallsArr = [];\r\n\r\n  let currentY = [];\r\n\r\n  walls.forEach( ( v, i ) => {\r\n    if ( v.index !== -1 ) {\r\n      currentY.push( 1 );\r\n    } else {\r\n      currentY.push( 0 );\r\n    }\r\n\r\n    if ( i % MAP_WIDTH === ( MAP_WIDTH - 1 ) ) {\r\n      wallsArr.push( currentY );\r\n      currentY = [];\r\n    }\r\n  } );\r\n\r\n  return wallsArr;\r\n};\r\n"
  ]
}