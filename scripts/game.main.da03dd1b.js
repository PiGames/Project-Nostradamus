webpackJsonp([0],[function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (immutable) */ __webpack_exports__["c"] = isTileBlocking;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__ = __webpack_require__(2);\n\n\nconst areTilesTheSame = ( tile1, tile2 ) => tile1.x === tile2.x && tile1.y === tile2.y;\n/* harmony export (immutable) */ __webpack_exports__["a"] = areTilesTheSame;\n\n\nconst pixelsToTileX = ( coord ) => Math.floor( coord / __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */] );\n/* unused harmony export pixelsToTileX */\n\nconst pixelsToTileY = ( coord ) => Math.floor( coord / __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */] );\n/* unused harmony export pixelsToTileY */\n\n\nconst tileToPixels = ( tile ) => ( {\n  x: ( tile.x * __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */] ) + __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */] / 2,\n  y: ( tile.y * __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */] ) + __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */] / 2,\n} );\n/* harmony export (immutable) */ __webpack_exports__["e"] = tileToPixels;\n\n\nconst pixelsToTile = ( coords ) => ( {\n  x: Math.floor( coords.x / __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */] ),\n  y: Math.floor( coords.y / __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */] ),\n} );\n/* harmony export (immutable) */ __webpack_exports__["d"] = pixelsToTile;\n\n\nconst getWallsPositions = ( layer ) => {\n  const walls = layer.getTiles( 0, 0, 2048, 2048 );\n  const wallsArr = [];\n\n  let currentY = [];\n\n  walls.forEach( ( v, i ) => {\n    if ( v.index !== -1 ) {\n      currentY.push( 1 );\n    } else {\n      currentY.push( 0 );\n    }\n\n    if ( i % __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["a" /* MAP_WIDTH */] === ( __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["a" /* MAP_WIDTH */] - 1 ) ) {\n      wallsArr.push( currentY );\n      currentY = [];\n    }\n  } );\n\n  return wallsArr;\n};\n/* harmony export (immutable) */ __webpack_exports__["b"] = getWallsPositions;\n\n\nfunction isTileBlocking( begin, end, walls ) {\n  const ray = new Phaser.Line();\n  ray.start.set( begin.x, begin.y );\n  ray.end.set( end.x, end.y );\n\n  const tileHits = walls.getRayCastTiles( ray, 0, false, false );\n\n  for ( let i = 0; i < tileHits.length; i++ ) {\n    if ( tileHits[ i ].index >= 0 ) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/MapUtils.js\n// module id = 0\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/utils/MapUtils.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const ZOMBIE_WIDTH = 40;\n/* harmony export (immutable) */ __webpack_exports__["o"] = ZOMBIE_WIDTH;\n\nconst ZOMBIE_HEIGHT = 31;\n/* harmony export (immutable) */ __webpack_exports__["g"] = ZOMBIE_HEIGHT;\n\nconst ZOMBIE_INITIAL_FRAME = 1;\n/* unused harmony export ZOMBIE_INITIAL_FRAME */\n\nconst ZOMBIE_SPEED = 50;\n/* harmony export (immutable) */ __webpack_exports__["l"] = ZOMBIE_SPEED;\n\nconst ZOMBIE_SPEED_CHASING_MULTIPLIER = 2;\n/* harmony export (immutable) */ __webpack_exports__["m"] = ZOMBIE_SPEED_CHASING_MULTIPLIER;\n\nconst ZOMBIE_LOOKING_OFFSET = 10;\n/* unused harmony export ZOMBIE_LOOKING_OFFSET */\n\nconst ZOMBIE_WALK_ANIMATION_FRAMERATE = 6;\n/* harmony export (immutable) */ __webpack_exports__["n"] = ZOMBIE_WALK_ANIMATION_FRAMERATE;\n\nconst ZOMBIE_FIGHT_ANIMATION_FRAMERATE = 10;\n/* harmony export (immutable) */ __webpack_exports__["e"] = ZOMBIE_FIGHT_ANIMATION_FRAMERATE;\n\nconst MIN_DISTANCE_TO_TARGET = 10;\n/* harmony export (immutable) */ __webpack_exports__["a"] = MIN_DISTANCE_TO_TARGET;\n\nconst ZOMBIE_SIGHT_ANGLE = 45;\n/* harmony export (immutable) */ __webpack_exports__["j"] = ZOMBIE_SIGHT_ANGLE;\n\nconst ZOMBIE_SIGHT_RANGE = 400;\n/* harmony export (immutable) */ __webpack_exports__["k"] = ZOMBIE_SIGHT_RANGE;\n\nconst ZOMBIE_HEARING_RANGE = 100;\n/* harmony export (immutable) */ __webpack_exports__["f"] = ZOMBIE_HEARING_RANGE;\n\nconst ZOMBIE_ATTACK_RANGE = 50;\n/* harmony export (immutable) */ __webpack_exports__["b"] = ZOMBIE_ATTACK_RANGE;\n\nconst ZOMBIE_ROTATING_SPEED = 50;\n/* harmony export (immutable) */ __webpack_exports__["i"] = ZOMBIE_ROTATING_SPEED;\n\nconst ZOMBIE_DAMAGE_MULTIPLIER = 1;\n/* unused harmony export ZOMBIE_DAMAGE_MULTIPLIER */\n\nconst ZOMBIE_DAMAGE_COOLDOWN = 0.2;\n/* harmony export (immutable) */ __webpack_exports__["c"] = ZOMBIE_DAMAGE_COOLDOWN;\n\nconst ZOMBIE_DAMAGE_VALUE = 0.1;\n/* harmony export (immutable) */ __webpack_exports__["d"] = ZOMBIE_DAMAGE_VALUE;\n\nconst ZOMBIE_NOTIFY_RANGE = 500;\n/* harmony export (immutable) */ __webpack_exports__["h"] = ZOMBIE_NOTIFY_RANGE;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants/ZombieConstants.js\n// module id = 1\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/constants/ZombieConstants.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const TILE_WIDTH = 64;\n/* harmony export (immutable) */ __webpack_exports__["c"] = TILE_WIDTH;\n\nconst TILE_HEIGHT = 64;\n/* harmony export (immutable) */ __webpack_exports__["b"] = TILE_HEIGHT;\n\nconst MAP_WIDTH = 32;\n/* harmony export (immutable) */ __webpack_exports__["a"] = MAP_WIDTH;\n\nconst MAP_HEIGHT = 32;\n/* unused harmony export MAP_HEIGHT */\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants/TileMapConstants.js\n// module id = 2\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/constants/TileMapConstants.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("class EventsManager {\n  constructor() {\n    this.signals = {};\n    this.debug = true;\n  }\n\n  isNameUsed( name ) {\n    const keys = Object.keys( this.signals );\n    return keys.indexOf( name ) >= 0;\n  }\n\n  checkForExistance( name, cb ) {\n    if ( this.isNameUsed( name ) ) {\n      cb();\n    } else {\n      throw new Error( `Event with this name does not exist [${name}]` );\n    }\n  }\n\n  create( name, ...args ) {\n    if ( !this.isNameUsed( name ) ) {\n      const newSignal = new Phaser.Signal( ...args );\n      this.signals[ name ] = newSignal;\n\n      if ( this.debug ) {\n        this.on( name, () => {\n          console.log( `Dispatched [%c${name}%c]`, 'font-weight: bold; color: #da0', 'font-weight: normal; color: #000' );\n        } );\n      }\n\n      return newSignal;\n    } else {\n      throw new Error( `Event with this name has already been created [${name}]` );\n    }\n  }\n\n  get( name ) {\n    this.checkForExistance( name, () => {\n      return this.signals[ name ];\n    } );\n  }\n\n  /*\n    * @url https://phaser.io/docs/2.6.2/Phaser.Signal.html#add\n  */\n  on( name, ...args ) {\n    this.checkForExistance( name, () => {\n      this.signals[ name ].add( ...args );\n    } );\n  }\n\n  /*\n    * @url https://phaser.io/docs/2.6.2/Phaser.Signal.html#addOnce\n  */\n  onOnce( name, ...args ) {\n    this.checkForExistance( name, () => {\n      this.signals[ name ].addOnce( ...args );\n    } );\n  }\n\n  /*\n    * @url https://phaser.io/docs/2.6.2/Phaser.Signal.html#remove\n  */\n  off( name, ...args ) {\n    this.checkForExistance( name, () => {\n      this.signals[ name ].remove( ...args );\n    } );\n  }\n\n  /*\n    * @url https://phaser.io/docs/2.6.2/Phaser.Signal.html#removeAll\n  */\n  offAll() {\n    this.checkForExistance( name, () => {\n      this.signals[ name ].removeAll();\n    } );\n  }\n\n  /*\n    * @url https://phaser.io/docs/2.6.2/Phaser.Signal.html#dispatch\n  */\n  dispatch( name, ...args ) {\n    this.checkForExistance( name, () => {\n      this.signals[ name ].dispatch( ...args );\n    } );\n  }\n}\n\nconst eventsManager = new EventsManager();\n/* harmony default export */ __webpack_exports__[\"a\"] = (eventsManager);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/EventsManager.js\n// module id = 3\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/EventsManager.js?")},function(module,exports){eval('var g;\r\n\r\n// This works in non-strict mode\r\ng = (function() {\r\n\treturn this;\r\n})();\r\n\r\ntry {\r\n\t// This works if eval is allowed (see CSP)\r\n\tg = g || Function("return this")() || (1,eval)("this");\r\n} catch(e) {\r\n\t// This works if the window reference is available\r\n\tif(typeof window === "object")\r\n\t\tg = window;\r\n}\r\n\r\n// g can still be undefined, but nothing to do about it...\r\n// We return undefined, instead of nothing here, so it\'s\r\n// easier to handle this case. if(!global) { ...}\r\n\r\nmodule.exports = g;\r\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/global.js\n// module id = 4\n// module chunks = 0\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const PLAYER_WIDTH = 29;\n/* harmony export (immutable) */ __webpack_exports__["l"] = PLAYER_WIDTH;\n\nconst PLAYER_HEIGHT = 31;\n/* harmony export (immutable) */ __webpack_exports__["f"] = PLAYER_HEIGHT;\n\nconst PLAYER_INITIAL_FRAME = 1;\n/* harmony export (immutable) */ __webpack_exports__["g"] = PLAYER_INITIAL_FRAME;\n\nconst PLAYER_SPEED = 120;\n/* harmony export (immutable) */ __webpack_exports__["i"] = PLAYER_SPEED;\n\nconst PLAYER_SNEAK_MULTIPLIER = 0.75;\n/* harmony export (immutable) */ __webpack_exports__["h"] = PLAYER_SNEAK_MULTIPLIER;\n\nconst PLAYER_SPRINT_MULTIPLIER = 1.5;\n/* harmony export (immutable) */ __webpack_exports__["j"] = PLAYER_SPRINT_MULTIPLIER;\n\nconst PLAYER_WALK_ANIMATION_FRAMERATE = 7;\n/* harmony export (immutable) */ __webpack_exports__["k"] = PLAYER_WALK_ANIMATION_FRAMERATE;\n\nconst PLAYER_FIGHT_ANIMATION_FRAMERATE = 10;\n/* harmony export (immutable) */ __webpack_exports__["b"] = PLAYER_FIGHT_ANIMATION_FRAMERATE;\n\nconst PLAYER_HAND_ATTACK_RANGE = 60;\n/* harmony export (immutable) */ __webpack_exports__["e"] = PLAYER_HAND_ATTACK_RANGE;\n\nconst PLAYER_HAND_ATTACK_ANGLE = 60;\n/* harmony export (immutable) */ __webpack_exports__["c"] = PLAYER_HAND_ATTACK_ANGLE;\n\nconst PLAYER_HAND_ATTACK_DAMAGE = 0.2;\n/* harmony export (immutable) */ __webpack_exports__["d"] = PLAYER_HAND_ATTACK_DAMAGE;\n\nconst PLAYER_DAMAGE_COOLDOWN = 0.1;\n/* harmony export (immutable) */ __webpack_exports__["a"] = PLAYER_DAMAGE_COOLDOWN;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants/PlayerConstants.js\n// module id = 5\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/constants/PlayerConstants.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('let ID_COUNTER = 0;\n\n// sort of a interface\nclass Lightable {\n  constructor( isStatic = true ) {\n    this.id = ID_COUNTER++;\n    this.isStatic = isStatic;\n  }\n  getLightShapePoints() {\n    // virtual method\n    // it means it should by overwritten in derived class\n    return [];\n  }\n  getFillStyle() {\n    // virtual method\n    return 0xffffff;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = Lightable;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/LightsComponents/Lightable.js\n// module id = 6\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/LightsComponents/Lightable.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const COMPUTER_WIDTH = 32;\n/* harmony export (immutable) */ __webpack_exports__["b"] = COMPUTER_WIDTH;\n\nconst COMPUTER_HEIGHT = 39;\n/* harmony export (immutable) */ __webpack_exports__["a"] = COMPUTER_HEIGHT;\n\nconst JOURNAL_TEXT_FIELD_WIDTH = 544;\n/* harmony export (immutable) */ __webpack_exports__["f"] = JOURNAL_TEXT_FIELD_WIDTH;\n\nconst JOURNAL_TEXT_FIELD_HEIGHT = 350;\n/* harmony export (immutable) */ __webpack_exports__["e"] = JOURNAL_TEXT_FIELD_HEIGHT;\n\nconst JOURNAL_TEXT_SCROLL_STEP = 32;\n/* harmony export (immutable) */ __webpack_exports__["h"] = JOURNAL_TEXT_SCROLL_STEP;\n\nconst JOURNAL_TEXT_FONT_SIZE = 16;\n/* harmony export (immutable) */ __webpack_exports__["g"] = JOURNAL_TEXT_FONT_SIZE;\n\nconst JOURNAL_SCROLL_BAR_WIDTH = 8;\n/* harmony export (immutable) */ __webpack_exports__["d"] = JOURNAL_SCROLL_BAR_WIDTH;\n\nconst MAGIC_OFFSET_FIXING_VALUE = 7;\n/* harmony export (immutable) */ __webpack_exports__["i"] = MAGIC_OFFSET_FIXING_VALUE;\n\nconst NUMBER_OF_RAYS = 25;\n/* unused harmony export NUMBER_OF_RAYS */\n\nconst RAY_LENGTH = 25;\n/* harmony export (immutable) */ __webpack_exports__["j"] = RAY_LENGTH;\n\nconst FLICKERING_POWER = 0.03;\n/* harmony export (immutable) */ __webpack_exports__["c"] = FLICKERING_POWER;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants/ItemConstants.js\n// module id = 7\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/constants/ItemConstants.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('Object.defineProperty(__webpack_exports__, "__esModule", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_p2__ = __webpack_require__(18);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_p2___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_p2__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_pixi__ = __webpack_require__(20);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_pixi___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_pixi__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_phaser__ = __webpack_require__(22);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_phaser___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_phaser__);\n\n\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/phaser.js\n// module id = 8\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/phaser.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__objects_Player__ = __webpack_require__(41);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__objects_Zombie__ = __webpack_require__(44);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__objects_TileMap__ = __webpack_require__(58);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__objects_JournalsManager__ = __webpack_require__(59);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__objects_Journal__ = __webpack_require__(60);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__objects_BoidsManager__ = __webpack_require__(62);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__UI_GameOverUI__ = __webpack_require__(63);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__UI_PlayerUI__ = __webpack_require__(65);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__objects_LightsComponents_LightsManager__ = __webpack_require__(66);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__objects_LightsComponents_TorchLight__ = __webpack_require__(67);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__objects_EventsManager__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_11__constants_PlayerConstants__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_12__constants_TileMapConstants__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_13__utils_MapUtils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_14__utils_IdCreator__ = __webpack_require__(69);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Game extends Phaser.State {\n  create() {\n    this.map = new __WEBPACK_IMPORTED_MODULE_2__objects_TileMap__["a" /* default */]( this.game, \'map\', __WEBPACK_IMPORTED_MODULE_12__constants_TileMapConstants__["c" /* TILE_WIDTH */], __WEBPACK_IMPORTED_MODULE_12__constants_TileMapConstants__["b" /* TILE_HEIGHT */] );\n    this.zombies = [];\n\n    this.initPlayer();\n    this.initCollisionGroups();\n    this.initZombies();\n    this.initJournals();\n    this.setCollisionRelations();\n    this.initFlashlight();\n    this.initPlayerUI();\n    this.initGameOverUI();\n\n    __WEBPACK_IMPORTED_MODULE_10__objects_EventsManager__["a" /* default */].on( \'playerDeath\', () => this.handleGameEnd() );\n  }\n  initCollisionGroups() {\n    this.playerCollisionGroup = this.game.physics.p2.createCollisionGroup( this.player );\n    this.zombiesCollisionGroup = this.game.physics.p2.createCollisionGroup();\n    this.journalsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n  }\n  initPlayer() {\n    const playerPos = this.map.getPlayerInitialPosition();\n\n    this.player = new __WEBPACK_IMPORTED_MODULE_0__objects_Player__["a" /* default */]( this.game, playerPos.x, playerPos.y, \'player\', __WEBPACK_IMPORTED_MODULE_11__constants_PlayerConstants__["g" /* PLAYER_INITIAL_FRAME */], this.zombies );\n    this.game.camera.follow( this.player );\n  }\n  initZombies() {\n    const wallsPositions = Object(__WEBPACK_IMPORTED_MODULE_13__utils_MapUtils__["b" /* getWallsPositions */])( this.map.walls );\n    this.zombies = new __WEBPACK_IMPORTED_MODULE_5__objects_BoidsManager__["a" /* default */]( this.game, wallsPositions );\n\n    const createNewId = Object(__WEBPACK_IMPORTED_MODULE_14__utils_IdCreator__["a" /* IdCreator */])();\n\n    for ( let i = 0; i < this.map.paths.length; i++ ) {\n      const newZombie = new __WEBPACK_IMPORTED_MODULE_1__objects_Zombie__["a" /* default */]( this.game, \'zombie\', createNewId() );\n\n      newZombie.setTilePosition( this.map.paths[ i ][ 0 ] );\n      newZombie.initializeChasingSystem( this.player, this.map.walls );\n      newZombie.body.setCollisionGroup( this.zombiesCollisionGroup );\n      newZombie.initializePathSystem( this.map.getPath( i ), wallsPositions );\n      newZombie.startPathSystem();\n\n      __WEBPACK_IMPORTED_MODULE_10__objects_EventsManager__["a" /* default */].on( \'playerDeath\', () => newZombie.onPlayerDeath() );\n\n      this.zombies.add( newZombie );\n    }\n  }\n  initJournals() {\n    this.journals = new __WEBPACK_IMPORTED_MODULE_3__objects_JournalsManager__["a" /* default */]( this.game, this.player );\n\n    const journalsData = this.map.getJournals();\n    const journalsContent = this.game.cache.getJSON( \'journals\' );\n\n    this.game.input.mouse.mouseWheelCallback = () => this.journals.onMouseWheel();\n\n    for ( let i = 0; i < journalsData.length; i++ ) {\n      const content = journalsContent[ journalsData[ i ].name ];\n      const newJournal = new __WEBPACK_IMPORTED_MODULE_4__objects_Journal__["a" /* default */]( this.game, content, \'computer\' );\n      newJournal.setCorner( journalsData[ i ].cornerX, journalsData[ i ].cornerY );\n      newJournal.setPosition( journalsData[ i ].x, journalsData[ i ].y );\n      newJournal.enableJournal();\n\n      newJournal.body.setCollisionGroup( this.journalsCollisionGroup );\n\n      this.journals.add( newJournal );\n    }\n\n    this.player.body.onBeginContact.add( ( ...args ) => this.journals.onCollisionEnter( ...args ) );\n    this.player.body.onEndContact.add( ( ...args ) => this.journals.onCollisionLeave( ...args ) );\n  }\n  setCollisionRelations() {\n    this.map.collides( [ this.playerCollisionGroup, this.zombiesCollisionGroup ] );\n    this.player.body.collides( [ this.map.wallsCollisionGroup, this.zombiesCollisionGroup, this.journalsCollisionGroup ] );\n\n    this.zombies.forEach( zombie => {\n      zombie.body.collides( [ this.playerCollisionGroup, this.map.wallsCollisionGroup, this.journalsCollisionGroup, this.zombiesCollisionGroup ] );\n    } );\n\n    this.journals.forEach( journal => {\n      journal.body.collides( [ this.playerCollisionGroup, this.zombiesCollisionGroup ] );\n    } );\n  }\n  initFlashlight() {\n    this.lightsManager = new __WEBPACK_IMPORTED_MODULE_8__objects_LightsComponents_LightsManager__["a" /* default */]( this.game, this.map.walls );\n    this.player.setUpFlashlight( this.map.walls );\n    this.lightsManager.add( this.player.flashlight );\n\n    this.journals.forEach( journal => {\n      this.lightsManager.add( journal.light );\n    } );\n\n    this.lightsManager.add( new __WEBPACK_IMPORTED_MODULE_9__objects_LightsComponents_TorchLight__["a" /* default */]( { x: 64 + 32, y: 6 * 64 + 32 } ) );\n\n  }\n  initPlayerUI() {\n    this.playerUI = new __WEBPACK_IMPORTED_MODULE_7__UI_PlayerUI__["a" /* default */]( this.game );\n    this.playerUI.setPlayerHealth( this.player.health );\n    __WEBPACK_IMPORTED_MODULE_10__objects_EventsManager__["a" /* default */].on( \'healthUpdate\', this.playerUI.setPlayerHealth.bind( this.playerUI ) );\n    __WEBPACK_IMPORTED_MODULE_10__objects_EventsManager__["a" /* default */].on( \'movementModeUpdate\', this.playerUI.setPlayerMovementInfo.bind( this.playerUI ) );\n  }\n  initGameOverUI() {\n    const mainMenuCallback = () => this.state.start( \'Menu\' );\n    const restartCallback = () => this.state.restart();\n    this.gameOverUI = new __WEBPACK_IMPORTED_MODULE_6__UI_GameOverUI__["a" /* default */]( this.game, mainMenuCallback, restartCallback );\n  }\n  handleGameEnd() {\n    this.clearScreen();\n    this.gameOverUI.start();\n  }\n  clearScreen() {\n    this.journals.clearUI();\n    this.playerUI.destroy();\n  }\n  update() {\n    if ( this.lightsManager ) {\n      this.lightsManager.update();\n    }\n  }\n  render() {\n    this.playerUI.render();\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = Game;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/states/Game.js\n// module id = 9\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/states/Game.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('class Entity extends Phaser.Sprite {\n  constructor( game, x, y, imageKey, frame ) {\n    super( game, x, y, imageKey, frame );\n\n    this.anchor.setTo( 0.5, 0.5 );\n\n    this.game.physics.p2.enable( this );\n    this.body.collideWorldBounds = true;\n\n    this.game.world.add( this );\n  }\n  lookAt( targetX, targetY ) {\n    const targetPoint = new Phaser.Point( targetX, targetY );\n    const entityCenter = new Phaser.Point( this.body.x + this.width / 2, this.body.y + this.height / 2 );\n\n    let targetAngle = Phaser.Math.radToDeg( Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) ) - 90;\n\n    if ( targetAngle < 0 ) {\n      targetAngle += 360;\n    }\n\n    this.body.angle = targetAngle;\n  }\n  normalizeVelocity() {\n    if ( this.body.velocity.x !== 0 && this.body.velocity.y !== 0 ) {\n      this.body.velocity.x = this.body.velocity.x * Math.sqrt( 2 ) * 1 / 2;\n      this.body.velocity.y = this.body.velocity.y * Math.sqrt( 2 ) * 1 / 2;\n    }\n  }\n  resetVelocity() {\n    this.body.velocity.x = 0;\n    this.body.velocity.y = 0;\n  }\n  isMoving() {\n    return this.body.velocity.x !== 0 || this.body.velocity.y !== 0;\n  }\n  isInDegreeRange( entity, target, sightAngle ) {\n    const angleDelta = Math.abs( Phaser.Math.radToDeg( Phaser.Math.angleBetween( entity.x, entity.y, target.x, target.y ) ) + 90 - entity.angle );\n\n    return angleDelta <= sightAngle || angleDelta >= ( 360 - sightAngle );\n  }\n  takeDamage( damage ) {\n    this.damage( damage );\n    this.health = Math.floor( this.health * 100 ) / 100;\n  }\n}\n\n/* harmony default export */ __webpack_exports__["a"] = (Entity);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/Entity.js\n// module id = 10\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/Entity.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const optimizeShape = shape => shape.filter( ( point, index ) => {\n  if ( index === 0 || index === shape.length - 1 ) {\n    return true;\n  }\n  if ( ( point.x === shape[ index - 1 ].x && point.x === shape[ index + 1 ].x )\n   || ( point.y === shape[ index - 1 ].y && point.y === shape[ index + 1 ].y ) ) {\n    return false;\n  }\n  return true;\n}\n);\n/* harmony export (immutable) */ __webpack_exports__["a"] = optimizeShape;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/LightUtils.js\n// module id = 11\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/utils/LightUtils.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__PathFinder__ = __webpack_require__(45);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_DeterminePathCollisionUtils__ = __webpack_require__(51);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_HandlePathCollisionUtils__ = __webpack_require__(52);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_MapUtils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__constants_ZombieConstants__ = __webpack_require__(1);\n\n\n\n\n\n\nconst STATES = {\n  NOT_STARTED: 0,\n  ON_STANDARD_PATH: 1,\n  ON_TEMPORARY_PATH: 2,\n  CALCULATING_PATH: 3,\n};\n/* harmony export (immutable) */ __webpack_exports__["a"] = STATES;\n\n\nclass ZombiePathManager {\n  constructor( zombie, targets, walls ) {\n    this.zombie = zombie;\n    this.targets = targets;\n    this.walls = walls;\n\n    this.pathFinder = new __WEBPACK_IMPORTED_MODULE_0__PathFinder__["a" /* default */]();\n    this.pathFinder.setGrid( walls );\n\n    this.pathsBetweenTargets = [];\n\n    this.currentPathIndex = 0;\n    this.currentStepIndex = 0;\n\n    this.temporaryPath = [];\n    this.temporaryStepIndex = 0;\n\n    this.state = STATES.NOT_STARTED;\n  }\n  start( callback ) {\n    // for now it assumes that zombie is placed on first path target\n    this.calculatePathsBetweenTargets( () => {\n      this.state = STATES.ON_STANDARD_PATH;\n      callback();\n    } );\n  }\n  // Recursive function that calculates standard paths and save them into pathsBetweenPathTargets container.\n  // Recurse approach is used to handle asynchronous nature of findPath method.\n  calculatePathsBetweenTargets( doneCallback, index = 0 ) {\n    if ( this.pathsBetweenTargets.length === this.targets.length ) {\n      doneCallback();\n      return;\n    }\n\n    const start = this.targets[ index ];\n    const target = ( index === this.targets.length - 1 ) ? this.targets[ 0 ] : this.targets[ index + 1 ];\n\n    this.pathFinder.findPath( start.x, start.y, target.x, target.y, ( path ) => {\n      this.pathsBetweenTargets.push( { path, start, target } );\n      this.calculatePathsBetweenTargets( doneCallback, index + 1 );\n    } );\n  }\n  update() {\n    switch ( this.state ) {\n    case STATES.ON_STANDARD_PATH:\n      this.moveOnStandardPath();\n      break;\n    case STATES.ON_TEMPORARY_PATH:\n      this.moveOnTemporaryPath();\n      break;\n    case STATES.CALCULATING_PATH:\n      this.zombie.body.velocity.x = 0;\n      this.zombie.body.velocity.y = 0;\n      break;\n    }\n  }\n  moveOnStandardPath() {\n    const stepTarget = this.getCurrentStepTarget();\n\n    if ( this.isReached( stepTarget ) ) {\n      this.onStepTargetReach();\n    }\n    this.zombie.game.physics.arcade.moveToObject( this.zombie, Object(__WEBPACK_IMPORTED_MODULE_3__utils_MapUtils__["e" /* tileToPixels */])( stepTarget ) );\n  }\n  isReached( target ) {\n    const distanceToTarget = this.zombie.game.physics.arcade.distanceBetween( this.zombie, Object(__WEBPACK_IMPORTED_MODULE_3__utils_MapUtils__["e" /* tileToPixels */])( target ) );\n    return distanceToTarget <= __WEBPACK_IMPORTED_MODULE_4__constants_ZombieConstants__["a" /* MIN_DISTANCE_TO_TARGET */];\n  }\n  onStepTargetReach() {\n    this.currentStepIndex++;\n\n    if ( this.currentStepIndex === this.pathsBetweenTargets[ this.currentPathIndex ].path.length ) {\n      this.currentStepIndex = 0;\n      this.currentPathIndex++;\n\n      if ( this.currentPathIndex === this.pathsBetweenTargets.length ) {\n        this.currentPathIndex = 0;\n      }\n    }\n  }\n  getCurrentStepTarget() {\n    return this.pathsBetweenTargets[ this.currentPathIndex ].path[ this.currentStepIndex ];\n  }\n  changePathToTemporary( startTile ) {\n    this.state = STATES.CALCULATING_PATH;\n\n    const currentTarget = this.pathsBetweenTargets[ this.currentPathIndex ].target;\n\n    this.pathFinder.findPath( startTile.x, startTile.y, currentTarget.x, currentTarget.y, ( path ) => {\n      if ( path.length === 0 ) {\n        this.changePathToStandard();\n        return;\n      }\n      this.temporaryPath = path;\n      this.temporaryStepIndex = 0;\n\n      this.state = STATES.ON_TEMPORARY_PATH;\n    } );\n  }\n  getTemporaryStepTarget() {\n    return this.temporaryPath[ this.temporaryStepIndex ];\n  }\n  changePathToStandard() {\n    this.currentPathIndex = ( this.currentPathIndex + 1 === this.pathsBetweenTargets.length ) ? 0 : this.currentPathIndex + 1;\n    this.currentStepIndex = 0;\n    this.state = STATES.ON_STANDARD_PATH;\n  }\n  moveOnTemporaryPath() {\n    const temporaryStepTarget = this.getTemporaryStepTarget();\n    if ( this.isReached( temporaryStepTarget ) ) {\n      this.onTemporaryStepTargetReach();\n    }\n    this.zombie.game.physics.arcade.moveToObject( this.zombie, Object(__WEBPACK_IMPORTED_MODULE_3__utils_MapUtils__["e" /* tileToPixels */])( temporaryStepTarget ) );\n  }\n  onTemporaryStepTargetReach() {\n    this.temporaryStepIndex++;\n    if ( this.temporaryStepIndex === this.temporaryPath.length ) {\n      this.changePathToStandard();\n    }\n  }\n  onCollisionEnter( bodyA ) {\n    if ( bodyA == null || bodyA.sprite == null ) {\n      return;\n    }\n\n    if ( bodyA.sprite.key === \'zombie\' ) {\n      this.checkForCollisionPossibility( bodyA.sprite );\n    }\n  }\n  checkForCollisionPossibility( zombieToCollideWith ) {\n    if ( Object(__WEBPACK_IMPORTED_MODULE_1__utils_DeterminePathCollisionUtils__["a" /* willZombiesPathsInterfere */])( this, zombieToCollideWith.walkingOnPathManager ) ) {\n      const newTemporaryTarget = Object(__WEBPACK_IMPORTED_MODULE_2__utils_HandlePathCollisionUtils__["a" /* getFreeTileAroundZombieExcludingOtherZombie */])( this.zombie, zombieToCollideWith, this.walls );\n      this.changePathToTemporary( newTemporaryTarget );\n    }\n  }\n  getCurrentTileTarget() {\n    if ( this.state === STATES.ON_STANDARD_PATH ) {\n      return this.getCurrentStepTarget();\n    } else if ( this.state === STATES.ON_TEMPORARY_PATH ) {\n      return this.getTemporaryStepTarget();\n    }\n    return Object(__WEBPACK_IMPORTED_MODULE_3__utils_MapUtils__["d" /* pixelsToTile */])( this.zombie );\n  }\n  getBackOnPath() {\n    const zombieTile = Object(__WEBPACK_IMPORTED_MODULE_3__utils_MapUtils__["d" /* pixelsToTile */])( this.zombie );\n    this.changePathToTemporary( zombieTile );\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["b"] = ZombiePathManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/ZombieComponents/ZombiePathManager.js\n// module id = 12\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/ZombieComponents/ZombiePathManager.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (immutable) */ __webpack_exports__["b"] = showBackgroundLayer;\nconst getScreenCenter = ( game ) => ( {\n  x: game.camera.x + game.camera.width / 2,\n  y: game.camera.y + game.camera.height / 2,\n} );\n/* harmony export (immutable) */ __webpack_exports__["a"] = getScreenCenter;\n\n\nfunction showBackgroundLayer( game ) {\n  const screenCenter = getScreenCenter( game );\n\n  const backgroundLayer = game.add.sprite( screenCenter.x, screenCenter.y, \'layer-background\' );\n  backgroundLayer.width = game.width + 100;\n  backgroundLayer.height = game.height + 100;\n  backgroundLayer.anchor.setTo( 0.5 );\n  backgroundLayer.alpha = 0.2;\n\n  return backgroundLayer;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/UserInterfaceUtils.js\n// module id = 13\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/utils/UserInterfaceUtils.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Lightable__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_MapUtils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_LightUtils__ = __webpack_require__(11);\n\n\n\n\nconst NUMBER_OF_RAYS = 80;\n\nclass JournalLight extends __WEBPACK_IMPORTED_MODULE_0__Lightable__["a" /* default */] {\n  constructor( { x, y }, rayLength ) {\n    super( true );\n    this.x = x;\n    this.y = y;\n    this.rayLength = rayLength;\n  }\n  getLightShapePoints( walls ) {\n    const shapePoints = [];\n\n    shapePoints.push( { x: this.x, y: this.y } );\n\n    for ( let i = 0; i <= NUMBER_OF_RAYS; i++ ) {\n      const rayAngle = ( Math.PI * 2 / NUMBER_OF_RAYS ) * i;\n      let lastX = this.x;\n      let lastY = this.y;\n      for ( let j = 1; j <= this.rayLength; j++ ) {\n        const begin = { x: this.x, y: this.y };\n        const end = {\n          x: Math.round( this.x - ( 2 * j ) * Math.cos( rayAngle ) ),\n          y: Math.round( this.y - ( 2 * j ) * Math.sin( rayAngle ) ),\n        };\n\n        if ( !Object(__WEBPACK_IMPORTED_MODULE_1__utils_MapUtils__["c" /* isTileBlocking */])( begin, end, walls ) ) {\n          lastX = end.x;\n          lastY = end.y;\n        } else {\n          break;\n        }\n      }\n\n      shapePoints.push( { x: lastX, y: lastY } );\n    }\n    shapePoints.push( { x: this.x, y: this.y } );\n\n    return Object(__WEBPACK_IMPORTED_MODULE_2__utils_LightUtils__["a" /* optimizeShape */])( shapePoints );\n  }\n  getFillStyle() {\n    return \'0xffffff\';\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = JournalLight;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/LightsComponents/RoundLight.js\n// module id = 14\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/LightsComponents/RoundLight.js?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/f9c7417fb812615f55d09b46dbf4eb20.json";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/levels/level1/journals.json\n// module id = 15\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/levels/level1/journals.json?')},function(module,exports,__webpack_require__){eval("__webpack_require__(17);\nmodule.exports = __webpack_require__(8);\n\n\n//////////////////\n// WEBPACK FOOTER\n// multi ./src/index.js ./src/phaser.js\n// module id = 16\n// module chunks = 0\n\n//# sourceURL=webpack:///multi_./src/index.js_./src/phaser.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("Object.defineProperty(__webpack_exports__, \"__esModule\", { value: true });\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__phaser_js__ = __webpack_require__(8);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_styles_main_css__ = __webpack_require__(25);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_styles_main_css___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_styles_main_css__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ProjectNostradamus__ = __webpack_require__(26);\n\n\n\n\n\nnew __WEBPACK_IMPORTED_MODULE_2__ProjectNostradamus__[\"a\" /* default */]( '100%', '100%', Phaser.AUTO, 'content' );\n\n/*\n!!! This is protection against leaving page while still in game. It is commented out since it was driving me crazy that i had to confirm leavinmg every time browsersync fired. !!!\nwindow.onbeforeunload = (e) => {\n  return 'Really want to quit the game?';\n};\n\ndocument.onkeydown = ( e ) => {\n  e = e || window.event;\n  if ( e.ctrlKey ) {\n    const c = e.which || e.keyCode;\n    switch ( c ) {\n    case 83:\n    case 87:\n      e.preventDefault();\n      e.stopPropagation();\n      break;\n    }\n  }\n};\n*/\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/index.js\n// module id = 17\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/index.js?")},,,,,,,function(module,exports){eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/process/browser.js\n// module id = 24\n// module chunks = 0\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?")},function(module,exports){eval("// removed by extract-text-webpack-plugin\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/styles/main.css\n// module id = 25\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/styles/main.css?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__filters_js__ = __webpack_require__(27);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__filters_js___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__filters_js__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__states_Boot__ = __webpack_require__(28);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__states_Preload__ = __webpack_require__(29);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__states_Menu__ = __webpack_require__(39);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__levels_Level1__ = __webpack_require__(40);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__levels_Level2__ = __webpack_require__(71);\n\n\n\n\n\n\n\nclass ProjectNostradamus extends Phaser.Game {\n  constructor( width, height, renderer, parent ) {\n    super( width, height, renderer, parent );\n    this.state.add( 'Preload', __WEBPACK_IMPORTED_MODULE_2__states_Preload__[\"a\" /* default */] );\n    this.state.add( 'Boot', __WEBPACK_IMPORTED_MODULE_1__states_Boot__[\"a\" /* default */] );\n    this.state.add( 'Preload', __WEBPACK_IMPORTED_MODULE_2__states_Preload__[\"a\" /* default */] );\n    this.state.add( 'Menu', __WEBPACK_IMPORTED_MODULE_3__states_Menu__[\"a\" /* default */] );\n\n    this.state.add( 'Level1', __WEBPACK_IMPORTED_MODULE_4__levels_Level1__[\"a\" /* default */] );\n    this.state.add( 'Level2', __WEBPACK_IMPORTED_MODULE_5__levels_Level2__[\"a\" /* default */] );\n\n    this.state.start( 'Boot' );\n  }\n}\n/* harmony default export */ __webpack_exports__[\"a\"] = (ProjectNostradamus);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/ProjectNostradamus.js\n// module id = 26\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/ProjectNostradamus.js?")},function(module,exports){eval("Phaser.Filter.Glow = function( game ) {\n  'use strict';\n  Phaser.Filter.call( this, game );\n  this.uniforms.alpha = { type: '1f', value: 1.0 };\n    //the shader, remove cosine/sine to make it a static glow\n  this.fragmentSrc = [\n    'precision lowp float;',\n    'varying vec2 vTextureCoord;',\n    'varying vec4 vColor;',\n    'uniform sampler2D uSampler;',\n    'uniform float alpha;',\n    'uniform float time;',\n    'void main() {',\n    'vec4 sum = vec4(0);',\n    'vec2 texcoord = vTextureCoord;',\n    'for(int xx = -4; xx <= 4; xx++) {',\n    'for(int yy = -4; yy <= 4; yy++) {',\n    'float dist = sqrt(float(xx*xx) + float(yy*yy));',\n    'float factor = 0.0;',\n    'if (dist == 0.0) {',\n    'factor = 2.0;',\n    '} else {',\n    'factor = 2.0/abs(float(dist));',\n    '}',\n    'sum += texture2D(uSampler, texcoord + vec2(xx, yy) * 0.002) * (0.66);',\n    '}',\n    '}',\n    'gl_FragColor = sum * 0.025 + texture2D(uSampler, texcoord)*alpha;',\n    '}',\n  ];\n};\n\nPhaser.Filter.Glow.prototype = Object.create( Phaser.Filter.prototype );\nPhaser.Filter.Glow.prototype.constructor = Phaser.Filter.Glow;\nObject.defineProperty( Phaser.Filter.Glow.prototype, 'alpha', {\n\n  get: function() {\n    return this.uniforms.alpha.value;\n  },\n\n  set: function( value ) {\n    this.uniforms.alpha.value = value;\n  },\n\n} );\n\n\nPhaser.Filter.Glow.prototype = Object.create( Phaser.Filter.prototype );\nPhaser.Filter.Glow.prototype.constructor = Phaser.Filter.Glow;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/filters.js\n// module id = 27\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/filters.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("class Boot extends Phaser.State {\n  preload() {\n  }\n  create() {\n    // this.game.stage.disableVisibilityChange = true;\n\n    // this.game.scale.maxWidth = 800;\n    // this.game.scale.maxHeight = 600;\n\n    this.game.scale.scaleMode = Phaser.ScaleManager.SHOW_ALL;\n    this.game.scale.updateLayout();\n\n    this.game.physics.startSystem( Phaser.Physics.P2JS );\n    this.game.physics.p2.setImpactEvents( true );\n    this.state.start( 'Preload' );\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Boot);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/states/Boot.js\n// module id = 28\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/states/Boot.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assets_tilemaps_tilemap_floor_png__ = __webpack_require__(30);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_assets_tilemaps_tilemap_floor_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_assets_tilemaps_tilemap_floor_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assets_tilemaps_tilemap_walls_png__ = __webpack_require__(31);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assets_tilemaps_tilemap_walls_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assets_tilemaps_tilemap_walls_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assets_images_player_sheet_png__ = __webpack_require__(32);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assets_images_player_sheet_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assets_images_player_sheet_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assets_images_zombie_sheet_png__ = __webpack_require__(33);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3_assets_images_zombie_sheet_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3_assets_images_zombie_sheet_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_assets_images_computer_png__ = __webpack_require__(34);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4_assets_images_computer_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4_assets_images_computer_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_assets_images_bg_color_png__ = __webpack_require__(35);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5_assets_images_bg_color_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5_assets_images_bg_color_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_assets_images_journal_ui_png__ = __webpack_require__(36);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6_assets_images_journal_ui_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6_assets_images_journal_ui_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_assets_images_main_menu_btn_png__ = __webpack_require__(37);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7_assets_images_main_menu_btn_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_7_assets_images_main_menu_btn_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_assets_images_restart_btn_png__ = __webpack_require__(38);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8_assets_images_restart_btn_png___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_8_assets_images_restart_btn_png__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_9__constants_PlayerConstants_js__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_10__constants_ZombieConstants_js__ = __webpack_require__(1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nclass Preload extends Phaser.State {\n  preload() {\n    this.load.image( 'tilemap_floor', __WEBPACK_IMPORTED_MODULE_0_assets_tilemaps_tilemap_floor_png___default.a );\n    this.load.image( 'tilemap_walls', __WEBPACK_IMPORTED_MODULE_1_assets_tilemaps_tilemap_walls_png___default.a );\n\n    this.game.load.spritesheet( 'player', __WEBPACK_IMPORTED_MODULE_2_assets_images_player_sheet_png___default.a, __WEBPACK_IMPORTED_MODULE_9__constants_PlayerConstants_js__[\"l\" /* PLAYER_WIDTH */], __WEBPACK_IMPORTED_MODULE_9__constants_PlayerConstants_js__[\"f\" /* PLAYER_HEIGHT */] );\n    this.game.load.spritesheet( 'zombie', __WEBPACK_IMPORTED_MODULE_3_assets_images_zombie_sheet_png___default.a, __WEBPACK_IMPORTED_MODULE_10__constants_ZombieConstants_js__[\"o\" /* ZOMBIE_WIDTH */], __WEBPACK_IMPORTED_MODULE_10__constants_ZombieConstants_js__[\"g\" /* ZOMBIE_HEIGHT */] );\n\n    this.game.load.image( 'computer', __WEBPACK_IMPORTED_MODULE_4_assets_images_computer_png___default.a );\n    this.game.load.image( 'layer-background', __WEBPACK_IMPORTED_MODULE_5_assets_images_bg_color_png___default.a );\n    this.game.load.image( 'journal-ui', __WEBPACK_IMPORTED_MODULE_6_assets_images_journal_ui_png___default.a );\n\n    this.game.load.image( 'main-menu-btn', __WEBPACK_IMPORTED_MODULE_7_assets_images_main_menu_btn_png___default.a );\n    this.game.load.image( 'restart-btn', __WEBPACK_IMPORTED_MODULE_8_assets_images_restart_btn_png___default.a );\n  }\n  create() {\n    this.state.start( 'Menu' );\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Preload);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/states/Preload.js\n// module id = 29\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/states/Preload.js?")},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/83b2af7d6e9c0358741f9fabe19a0c5e.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/tilemaps/tilemap_floor.png\n// module id = 30\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/tilemaps/tilemap_floor.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/3aeebbbc516acd88554833b3fa26e4ac.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/tilemaps/tilemap_walls.png\n// module id = 31\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/tilemaps/tilemap_walls.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/f3001dfd34337d303a76f1178d94edf9.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/images/player-sheet.png\n// module id = 32\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/images/player-sheet.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/b2dcf3a06e860083926a5b581c5a4db6.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/images/zombie-sheet.png\n// module id = 33\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/images/zombie-sheet.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/327c84c9f8598a5b48c97d02d12fbfb0.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/images/computer.png\n// module id = 34\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/images/computer.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/85f41aa4d381690910ca1bf1b8f02f0d.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/images/bg-color.png\n// module id = 35\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/images/bg-color.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/b443a89ca00c9a178ad2511e4c81dd66.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/images/journal-ui.png\n// module id = 36\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/images/journal-ui.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/727dcc2b01b49d2166976d799ed48688.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/images/main-menu-btn.png\n// module id = 37\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/images/main-menu-btn.png?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/e2bb80fc75a17c55ec727b3a1839cd24.png";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/images/restart-btn.png\n// module id = 38\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/images/restart-btn.png?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("class Menu extends Phaser.State {\n  constructor() {\n    super();\n\n    this.levels = [\n      'Level1',\n      'Level2',\n    ];\n  }\n\n  create() {\n    this.state.start( this.levels[ 0 ] );\n\n    window.goToLevel = ( n ) => {\n      if ( this.levels[ n - 1 ] ) {\n        this.state.start( this.levels[ n - 1 ] );\n      } else {\n        return 'Level not found!';\n      }\n    };\n  }\n}\n\n/* harmony default export */ __webpack_exports__[\"a\"] = (Menu);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/states/Menu.js\n// module id = 39\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/states/Menu.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__states_Game_js__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assets_levels_level1_map_json__ = __webpack_require__(70);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assets_levels_level1_map_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assets_levels_level1_map_json__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assets_levels_level1_journals_json__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assets_levels_level1_journals_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assets_levels_level1_journals_json__);\n\n\n\n\n\nclass Level1 extends __WEBPACK_IMPORTED_MODULE_0__states_Game_js__["a" /* default */] {\n  preload() {\n    __WEBPACK_IMPORTED_MODULE_0__states_Game_js__["a" /* default */].prototype.preload.call( this );\n\n    this.load.tilemap( \'map\', __WEBPACK_IMPORTED_MODULE_1_assets_levels_level1_map_json___default.a, null, Phaser.Tilemap.TILED_JSON );\n    this.load.json( \'journals\', __WEBPACK_IMPORTED_MODULE_2_assets_levels_level1_journals_json___default.a );\n  }\n  create() {\n    __WEBPACK_IMPORTED_MODULE_0__states_Game_js__["a" /* default */].prototype.create.call( this );\n    console.log( \'level1 loaded\' );\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = Level1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/levels/Level1.js\n// module id = 40\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/levels/Level1.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Entity__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__ = __webpack_require__(5);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__constants_TileMapConstants__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__LightsComponents_Flashlight__ = __webpack_require__(42);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__EventsManager__ = __webpack_require__(3);\n\n\n\n\n\n\nclass Player extends __WEBPACK_IMPORTED_MODULE_0__Entity__["a" /* default */] {\n  constructor( game, x, y, imageKey, frame, zombies ) {\n    super( game, x + __WEBPACK_IMPORTED_MODULE_2__constants_TileMapConstants__["c" /* TILE_WIDTH */] / 2, y + __WEBPACK_IMPORTED_MODULE_2__constants_TileMapConstants__["b" /* TILE_HEIGHT */] / 2, imageKey, frame );\n\n    this.width = __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["l" /* PLAYER_WIDTH */];\n    this.height = __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["f" /* PLAYER_HEIGHT */];\n\n    this.zombies = zombies.children;\n\n    this.godMode = false;\n\n    this.isSneaking = false;\n    this.isSprinting = false;\n\n    this.attackRange = __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["e" /* PLAYER_HAND_ATTACK_RANGE */];\n    this.dealingDamage = __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["d" /* PLAYER_HAND_ATTACK_DAMAGE */];\n\n    this.canDealDamage = true;\n\n    this.zombiesInAttackRange = [];\n\n    this.attackSensor = this.body.addCircle( __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["e" /* PLAYER_HAND_ATTACK_RANGE */] );\n    this.attackSensor.sensor = true;\n    this.attackSensor.sensorType = \'attack\';\n\n    this.cursors = {\n      up: this.game.input.keyboard.addKey( Phaser.Keyboard.W ),\n      down: this.game.input.keyboard.addKey( Phaser.Keyboard.S ),\n      left: this.game.input.keyboard.addKey( Phaser.Keyboard.A ),\n      right: this.game.input.keyboard.addKey( Phaser.Keyboard.D ),\n      sneakToggle: this.game.input.keyboard.addKey( Phaser.Keyboard.CAPS_LOCK ),\n      sneak: this.game.input.keyboard.addKey( Phaser.Keyboard.ALT ),\n      sprint: this.game.input.keyboard.addKey( Phaser.Keyboard.SHIFT ),\n    };\n\n    this.isSneakPressed = false;\n\n    this.animations.add( \'walk\', [ 0, 1, 2, 3, 4, 5 ] );\n    this.animations.add( \'fight\', [ 6, 7, 8, 9, 0 ] );\n\n    this.body.clearShapes();\n    this.body.addCircle( Math.min( __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["l" /* PLAYER_WIDTH */], __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["f" /* PLAYER_HEIGHT */] ) );\n\n    __WEBPACK_IMPORTED_MODULE_4__EventsManager__["a" /* default */].create( \'playerDeath\' );\n    __WEBPACK_IMPORTED_MODULE_4__EventsManager__["a" /* default */].create( \'movementModeUpdate\' );\n    __WEBPACK_IMPORTED_MODULE_4__EventsManager__["a" /* default */].create( \'healthUpdate\' );\n\n    this.body.onBeginContact.add( this.onCollisionEnter, this );\n    this.body.onEndContact.add( this.onCollisionLeave, this );\n\n    this.flashlight = null;\n  }\n\n  setUpFlashlight( walls ) {\n    this.flashlight = new __WEBPACK_IMPORTED_MODULE_3__LightsComponents_Flashlight__["a" /* default */]( this, walls );\n  }\n\n  update() {\n    this.handleMovement();\n    this.handleAnimation();\n    this.lookAtMouse();\n    this.handleAttack();\n  }\n\n  handleMovement() {\n    this.resetVelocity();\n\n    if ( this.cursors.up.isDown ) {\n      this.body.velocity.y = -__WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["i" /* PLAYER_SPEED */];\n    } else if ( this.cursors.down.isDown ) {\n      this.body.velocity.y = __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["i" /* PLAYER_SPEED */];\n    }\n\n    if ( this.cursors.left.isDown ) {\n      this.body.velocity.x = -__WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["i" /* PLAYER_SPEED */];\n    } else if ( this.cursors.right.isDown ) {\n      this.body.velocity.x = __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["i" /* PLAYER_SPEED */];\n    }\n\n    const wasKeyPressed = Object.keys( this.cursors ).find( key => this.cursors[ key ].isDown );\n\n    if ( wasKeyPressed !== undefined ) {\n      this.handleMovementSpecialModes();\n    }\n\n    this.normalizeVelocity();\n  }\n\n  handleMovementSpecialModes() {\n    let specialEffectMultiplier = 1;\n\n    this.isSprinting = false;\n    this.isSneaking = false;\n\n    if ( this.cursors.sprint.isDown ) {\n      this.isSprinting = true;\n      this.isSneaking = false;\n      specialEffectMultiplier = __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["j" /* PLAYER_SPRINT_MULTIPLIER */];\n    }\n\n    if ( this.cursors.sneak.isDown || this.cursors.sneakToggle.isDown ) {\n      specialEffectMultiplier = __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["h" /* PLAYER_SNEAK_MULTIPLIER */];\n      this.isSneaking = true;\n    }\n\n    __WEBPACK_IMPORTED_MODULE_4__EventsManager__["a" /* default */].dispatch( \'movementModeUpdate\', this.isSneaking, this.isSprinting );\n\n    this.body.velocity.x *= specialEffectMultiplier;\n    this.body.velocity.y *= specialEffectMultiplier;\n  }\n\n  onCollisionEnter( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      if ( shapeB.sensorType === \'attack\' && bodyA.sprite.key === \'zombie\' ) {\n        this.zombiesInAttackRange.push( bodyA.sprite );\n      }\n    }\n  }\n\n  onCollisionLeave( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      if ( shapeB.sensorType === \'attack\' && bodyA.sprite.key === \'zombie\' ) {\n        this.zombiesInAttackRange = this.zombiesInAttackRange.filter( ( v ) => {\n          return ( v !== bodyA.sprite );\n        } );\n      }\n    }\n  }\n\n  isItSensorArea( body, shape ) {\n    if ( body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n\n    return shape.sensor;\n  }\n\n  handleAnimation() {\n    if ( this.game.input.activePointer.leftButton.isDown ) {\n      this.animations.play( \'fight\', __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["b" /* PLAYER_FIGHT_ANIMATION_FRAMERATE */], false );\n    }\n    if ( ( this.body.velocity.x !== 0 || this.body.velocity.y !== 0 ) && !this.animations.getAnimation( \'fight\' ).isPlaying ) {\n      this.animations.play( \'walk\', __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["k" /* PLAYER_WALK_ANIMATION_FRAMERATE */], true );\n    } else {\n      this.animations.stop( \'walk\', true );\n    }\n  }\n\n  endCooldown() {\n    this.canDealDamage = true;\n    // this.animations.play( \'walk\', ZOMBIE_WALK_ANIMATION_FRAMERATE, true );\n  }\n\n  lookAtMouse() {\n    const mouseX = this.game.input.mousePointer.worldX;\n    const mouseY = this.game.input.mousePointer.worldY;\n\n    this.lookAt( mouseX, mouseY );\n  }\n\n  handleAttack() {\n    let didDealDamage = false;\n    if ( this.game.input.activePointer.leftButton.isDown && this.canDealDamage ) {\n      this.zombiesInAttackRange.forEach( ( v ) => {\n        if ( v.alive ) {\n          if ( this.isInDegreeRange( this, v, __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["c" /* PLAYER_HAND_ATTACK_ANGLE */] ) ) {\n            v.takeDamage( this.dealingDamage );\n            didDealDamage = true;\n          }\n        }\n      } );\n\n      if ( didDealDamage ) {\n        this.canDealDamage = false;\n        this.game.time.events.add( Phaser.Timer.SECOND * __WEBPACK_IMPORTED_MODULE_1__constants_PlayerConstants__["a" /* PLAYER_DAMAGE_COOLDOWN */], this.endCooldown, this );\n      }\n    }\n  }\n\n  takeDamage( damage ) {\n    if ( !this.godMode ) {\n      __WEBPACK_IMPORTED_MODULE_0__Entity__["a" /* default */].prototype.takeDamage.call( this, [ damage ] );\n    }\n\n    __WEBPACK_IMPORTED_MODULE_4__EventsManager__["a" /* default */].dispatch( \'healthUpdate\', this.health );\n\n    if ( this.health <= 0 ) {\n      this.handleDeath();\n    }\n  }\n\n  handleDeath() {\n    __WEBPACK_IMPORTED_MODULE_4__EventsManager__["a" /* default */].dispatch( \'playerDeath\' );\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = Player;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/Player.js\n// module id = 41\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/Player.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__ = __webpack_require__(43);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Lightable__ = __webpack_require__(6);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__utils_MapUtils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__utils_LightUtils__ = __webpack_require__(11);\n\n\n\n\n\n\nclass Flashlight extends __WEBPACK_IMPORTED_MODULE_1__Lightable__["a" /* default */] {\n  constructor( player, walls ) {\n    super( false );\n    this.player = player;\n    this.walls = walls;\n  }\n  getLightShapePoints() {\n    const shapePoints = [];\n\n    const mouseX = this.player.game.input.mousePointer.worldX;\n    const mouseY = this.player.game.input.mousePointer.worldY;\n    const mouseAngle = Math.atan2( this.player.y - mouseY, this.player.x - mouseX );\n\n    const flashlightLength = 8;\n\n    const minAngle = mouseAngle - ( __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["b" /* LIGHT_ANGLE */] / 2 );\n    const flashlightStartPoint = {\n      x: Math.round( this.player.x - ( 2 * flashlightLength ) * Math.cos( minAngle ) ),\n      y: Math.round( this.player.y - ( 2 * flashlightLength ) * Math.sin( minAngle ) ),\n    };\n    shapePoints.push( flashlightStartPoint );\n\n    for ( let i = 0; i < __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["c" /* NUMBER_OF_RAYS */]; i++ ) {\n      const rayAngle = mouseAngle - ( __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["b" /* LIGHT_ANGLE */] / 2 ) + ( __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["b" /* LIGHT_ANGLE */] / __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["c" /* NUMBER_OF_RAYS */] ) * i;\n      let lastX = this.player.x;\n      let lastY = this.player.y;\n      for ( let j = 1; j <= __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["d" /* RAY_LENGTH */]; j++ ) {\n        const begin = this.player.position;\n        const end = {\n          x: Math.round( this.player.x - ( 2 * j ) * Math.cos( rayAngle ) ),\n          y: Math.round( this.player.y - ( 2 * j ) * Math.sin( rayAngle ) ),\n        };\n\n        if ( !Object(__WEBPACK_IMPORTED_MODULE_2__utils_MapUtils__["c" /* isTileBlocking */])( begin, end, this.walls ) ) {\n          lastX = end.x;\n          lastY = end.y;\n        } else {\n          break;\n        }\n      }\n\n      shapePoints.push( { x: lastX, y: lastY } );\n    }\n\n    const maxAngle = mouseAngle + ( __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["b" /* LIGHT_ANGLE */] / 2 );\n    const flashlightEndPoint = {\n      x: Math.round( this.player.x - ( 2 * flashlightLength ) * Math.cos( maxAngle ) ),\n      y: Math.round( this.player.y - ( 2 * flashlightLength ) * Math.sin( maxAngle ) ),\n    };\n    shapePoints.push( flashlightEndPoint );\n\n    return Object(__WEBPACK_IMPORTED_MODULE_3__utils_LightUtils__["a" /* optimizeShape */])( shapePoints );\n  }\n  getFillStyle( ctx, offset ) {\n    const rayLength = __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["d" /* RAY_LENGTH */] * ( 1 + Math.random() * __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["a" /* FLICKERING_POWER */] );\n    const gradient = ctx.createRadialGradient(\n        this.player.x - offset.x, this.player.y - offset.y, __WEBPACK_IMPORTED_MODULE_0__constants_FlashlightConstants__["d" /* RAY_LENGTH */] * 0.75 * 2,\n        this.player.x - offset.x, this.player.y - offset.y, rayLength * 2 );\n    gradient.addColorStop( 0, \'rgba(255, 255, 255, 1.0)\' );\n    gradient.addColorStop( 1, \'rgba(255, 255, 255, 0.0)\' );\n\n    return gradient;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = Flashlight;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/LightsComponents/Flashlight.js\n// module id = 42\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/LightsComponents/Flashlight.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const LIGHT_ANGLE = Math.PI / 3;\n/* harmony export (immutable) */ __webpack_exports__["b"] = LIGHT_ANGLE;\n\nconst NUMBER_OF_RAYS = 30;\n/* harmony export (immutable) */ __webpack_exports__["c"] = NUMBER_OF_RAYS;\n\nconst RAY_LENGTH = 75;\n/* harmony export (immutable) */ __webpack_exports__["d"] = RAY_LENGTH;\n\nconst WORLD_SHADOW_ALPHA = 0.38;\n/* unused harmony export WORLD_SHADOW_ALPHA */\n\nconst LIGHT_ALPHA = 0.2;\n/* unused harmony export LIGHT_ALPHA */\n\nconst FLICKERING_POWER = 0.04;\n/* harmony export (immutable) */ __webpack_exports__["a"] = FLICKERING_POWER;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants/FlashlightConstants.js\n// module id = 43\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/constants/FlashlightConstants.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Entity__ = __webpack_require__(10);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__ZombieComponents_ZombiePathManager__ = __webpack_require__(12);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__ZombieComponents_ZombieRotationManager__ = __webpack_require__(53);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__ZombieComponents_SeekingPlayerManager__ = __webpack_require__(54);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__ZombieComponents_ChasingPlayerManager__ = __webpack_require__(56);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__EventsManager__ = __webpack_require__(3);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__utils_MapUtils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__constants_TileMapConstants__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__constants_ZombieConstants__ = __webpack_require__(1);\n\n\n\n\n\n\n\n\n\n\n/* eslint-disable no-inline-comments */\n\nconst STATES = {\n  NOT_READY: 0, // zombie is created but no system is initialized\n  NOT_WALKING: 1, // walking on path manager is initialized but paths are not calculated yet\n  WALKING_ON_PATH: 2, // zombie is walking on precalculated paths\n  CHASING_PLAYER: 3, // zombie is chasing player\n};\n\nclass Zombie extends __WEBPACK_IMPORTED_MODULE_0__Entity__["a" /* default */] {\n  constructor( game, key, id ) {\n    super( game, 0, 0, key );\n\n    this.id = id;\n\n    this.initCollider();\n    this.initAnimations();\n\n    this.isPathSystemInitialized = false;\n    this.walkingOnPathManager = null;\n    this.rotationManager = new __WEBPACK_IMPORTED_MODULE_2__ZombieComponents_ZombieRotationManager__["a" /* default */]( this );\n    this.chasingPlayerManager = null;\n\n    this.state = STATES.NOT_READY;\n\n    this.body.onBeginContact.add( this.onCollisionEnter, this );\n    this.body.onEndContact.add( this.onCollisionLeave, this );\n  }\n  initCollider() {\n    this.body.clearShapes();\n\n    this.body.addCircle( Math.max( __WEBPACK_IMPORTED_MODULE_7__constants_TileMapConstants__["c" /* TILE_WIDTH */], __WEBPACK_IMPORTED_MODULE_7__constants_TileMapConstants__["b" /* TILE_HEIGHT */] ) * 0.25 );\n  }\n  initAnimations() {\n    this.animations.add( \'walk\', [ 0, 1, 2, 3, 4, 5 ], 0 );\n    this.animations.add( \'attack\', [ 6, 7, 8, 9 ], 6 );\n    this.animations.play( \'walk\', __WEBPACK_IMPORTED_MODULE_8__constants_ZombieConstants__["n" /* ZOMBIE_WALK_ANIMATION_FRAMERATE */], true );\n  }\n  setTilePosition( tile ) {\n    const pixelPosition = Object(__WEBPACK_IMPORTED_MODULE_6__utils_MapUtils__["e" /* tileToPixels */])( tile );\n    Object.assign( this.body, pixelPosition );\n  }\n  initializePathSystem( targets, walls ) {\n    this.walkingOnPathManager = new __WEBPACK_IMPORTED_MODULE_1__ZombieComponents_ZombiePathManager__["b" /* default */]( this, targets, walls );\n\n    this.state = STATES.NOT_WALKING;\n  }\n  startPathSystem() {\n    this.walkingOnPathManager.start( () => this.state = STATES.WALKING_ON_PATH );\n  }\n  initializeChasingSystem( player, walls ) {\n    this.seekingPlayerManager = new __WEBPACK_IMPORTED_MODULE_3__ZombieComponents_SeekingPlayerManager__["a" /* default */]( this, player, walls );\n    __WEBPACK_IMPORTED_MODULE_5__EventsManager__["a" /* default */].on( `chasePlayer-${this.id}`, this.changeStateToChasing, this );\n\n    this.chasingPlayerManager = new __WEBPACK_IMPORTED_MODULE_4__ZombieComponents_ChasingPlayerManager__["a" /* default */]( this, player );\n    __WEBPACK_IMPORTED_MODULE_5__EventsManager__["a" /* default */].on( `stopChasingPlayer-${this.id}`, this.changeStateToWalking, this );\n  }\n  update() {\n    switch ( this.state ) {\n    case STATES.WALKING_ON_PATH:\n      this.handleWalkingOnPathState();\n      break;\n    case STATES.CHASING_PLAYER:\n      this.handleChasingPlayerState();\n    }\n  }\n  onCollisionEnter( ...args ) {\n    switch ( this.state ) {\n    case STATES.WALKING_ON_PATH:\n      this.walkingOnPathManager.onCollisionEnter( ...args );\n      this.seekingPlayerManager.onCollisionEnter( ...args );\n      break;\n    case STATES.CHASING_PLAYER:\n      this.chasingPlayerManager.onCollisionEnter( ...args );\n      break;\n    }\n  }\n  onCollisionLeave( ...args ) {\n    switch ( this.state ) {\n    case STATES.WALKING_ON_PATH:\n      this.seekingPlayerManager.onCollisionLeave( ...args );\n      break;\n    case STATES.CHASING_PLAYER:\n      this.chasingPlayerManager.onCollisionLeave( ...args );\n      break;\n    }\n  }\n  handleWalkingOnPathState() {\n    this.walkingOnPathManager.update();\n\n    const currentTileTarget = this.walkingOnPathManager.getCurrentTileTarget();\n    this.rotationManager.update( currentTileTarget );\n\n    this.seekingPlayerManager.update();\n  }\n  handleChasingPlayerState() {\n    const lastKnownPlayerPosition = this.seekingPlayerManager.getLastKnownPlayerPosition();\n    this.chasingPlayerManager.update( lastKnownPlayerPosition );\n  }\n  changeStateToChasing() {\n    this.state = STATES.CHASING_PLAYER;\n  }\n  startChasingByBeingNotified() {\n    this.seekingPlayerManager.isNotified = true;\n    this.changeStateToChasing();\n  }\n  changeStateToWalking() {\n    this.seekingPlayerManager.onStopChasing();\n    this.walkingOnPathManager.getBackOnPath();\n    this.state = STATES.WALKING_ON_PATH;\n  }\n  isChasing() {\n    return this.state === STATES.CHASING_PLAYER;\n  }\n  takeDamage( damage ) {\n    __WEBPACK_IMPORTED_MODULE_0__Entity__["a" /* default */].prototype.takeDamage.call( this, [ damage ] );\n    if ( this.health <= 0 ) {\n      this._mask = null;\n      this.destroy();\n    }\n  }\n  onPlayerDeath() {\n    this.seekingPlayerManager.stopLookingForThePlayer();\n\n    if ( this.isChasing() ) {\n      this.changeStateToWalking();\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = Zombie;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/Zombie.js\n// module id = 44\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/Zombie.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_easystarjs__ = __webpack_require__(46);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0_easystarjs___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0_easystarjs__);\n\n\nclass PathFinder {\n  constructor( ) {\n    this.easystar = new __WEBPACK_IMPORTED_MODULE_0_easystarjs___default.a.js();\n\n    this.easystar.setAcceptableTiles( [ 0 ] );\n  }\n  setGrid( grid ) {\n    this.easystar.setGrid( grid );\n  }\n  findPath( startX, startY, endX, endY, callback ) {\n    this.easystar.findPath( startX, startY, endX, endY, callback );\n    this.easystar.calculate();\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = PathFinder;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/ZombieComponents/PathFinder.js\n// module id = 45\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/ZombieComponents/PathFinder.js?')},function(module,exports,__webpack_require__){eval("/**\n*   EasyStar.js\n*   github.com/prettymuchbryce/EasyStarJS\n*   Licensed under the MIT license.\n*\n*   Implementation By Bryce Neal (@prettymuchbryce)\n**/\n\nvar EasyStar = {}\nvar Instance = __webpack_require__(47);\nvar Node = __webpack_require__(48);\nvar Heap = __webpack_require__(49);\n\nconst CLOSED_LIST = 0;\nconst OPEN_LIST = 1;\n\nmodule.exports = EasyStar;\n\nEasyStar.js = function() {\n    var STRAIGHT_COST = 1.0;\n    var DIAGONAL_COST = 1.4;\n    var syncEnabled = false;\n    var pointsToAvoid = {};\n    var collisionGrid;\n    var costMap = {};\n    var pointsToCost = {};\n    var directionalConditions = {};\n    var allowCornerCutting = true;\n    var iterationsSoFar;\n    var instances = [];\n    var iterationsPerCalculation = Number.MAX_VALUE;\n    var acceptableTiles;\n    var diagonalsEnabled = false;\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array|Number} tiles An array of numbers that represent\n    * which tiles in your grid should be considered\n    * acceptable, or \"walkable\".\n    **/\n    this.setAcceptableTiles = function(tiles) {\n        if (tiles instanceof Array) {\n            // Array\n            acceptableTiles = tiles;\n        } else if (!isNaN(parseFloat(tiles)) && isFinite(tiles)) {\n            // Number\n            acceptableTiles = [tiles];\n        }\n    };\n\n    /**\n    * Enables sync mode for this EasyStar instance..\n    * if you're into that sort of thing.\n    **/\n    this.enableSync = function() {\n        syncEnabled = true;\n    };\n\n    /**\n    * Disables sync mode for this EasyStar instance.\n    **/\n    this.disableSync = function() {\n        syncEnabled = false;\n    };\n\n    /**\n     * Enable diagonal pathfinding.\n     */\n    this.enableDiagonals = function() {\n        diagonalsEnabled = true;\n    }\n\n    /**\n     * Disable diagonal pathfinding.\n     */\n    this.disableDiagonals = function() {\n        diagonalsEnabled = false;\n    }\n\n    /**\n    * Sets the collision grid that EasyStar uses.\n    *\n    * @param {Array} grid The collision grid that this EasyStar instance will read from.\n    * This should be a 2D Array of Numbers.\n    **/\n    this.setGrid = function(grid) {\n        collisionGrid = grid;\n\n        //Setup cost map\n        for (var y = 0; y < collisionGrid.length; y++) {\n            for (var x = 0; x < collisionGrid[0].length; x++) {\n                if (!costMap[collisionGrid[y][x]]) {\n                    costMap[collisionGrid[y][x]] = 1\n                }\n            }\n        }\n    };\n\n    /**\n    * Sets the tile cost for a particular tile type.\n    *\n    * @param {Number} The tile type to set the cost for.\n    * @param {Number} The multiplicative cost associated with the given tile.\n    **/\n    this.setTileCost = function(tileType, cost) {\n        costMap[tileType] = cost;\n    };\n\n    /**\n    * Sets the an additional cost for a particular point.\n    * Overrides the cost from setTileCost.\n    *\n    * @param {Number} x The x value of the point to cost.\n    * @param {Number} y The y value of the point to cost.\n    * @param {Number} The multiplicative cost associated with the given point.\n    **/\n    this.setAdditionalPointCost = function(x, y, cost) {\n        pointsToCost[x + '_' + y] = cost;\n    };\n\n    /**\n    * Remove the additional cost for a particular point.\n    *\n    * @param {Number} x The x value of the point to stop costing.\n    * @param {Number} y The y value of the point to stop costing.\n    **/\n    this.removeAdditionalPointCost = function(x, y) {\n        delete pointsToCost[x + '_' + y];\n    }\n\n    /**\n    * Remove all additional point costs.\n    **/\n    this.removeAllAdditionalPointCosts = function() {\n        pointsToCost = {};\n    }\n\n    /**\n    * Sets a directional condition on a tile\n    *\n    * @param {Number} x The x value of the point.\n    * @param {Number} y The y value of the point.\n    * @param {Array.<String>} allowedDirections A list of all the allowed directions that can access\n    * the tile.\n    **/\n    this.setDirectionalCondition = function(x, y, allowedDirections) {\n        directionalConditions[x + '_' + y] = allowedDirections;\n    };\n\n    /**\n    * Remove all directional conditions\n    **/\n    this.removeAllDirectionalConditions = function() {\n        directionalConditions = {};\n    };\n\n    /**\n    * Sets the number of search iterations per calculation.\n    * A lower number provides a slower result, but more practical if you\n    * have a large tile-map and don't want to block your thread while\n    * finding a path.\n    *\n    * @param {Number} iterations The number of searches to prefrom per calculate() call.\n    **/\n    this.setIterationsPerCalculation = function(iterations) {\n        iterationsPerCalculation = iterations;\n    };\n\n    /**\n    * Avoid a particular point on the grid,\n    * regardless of whether or not it is an acceptable tile.\n    *\n    * @param {Number} x The x value of the point to avoid.\n    * @param {Number} y The y value of the point to avoid.\n    **/\n    this.avoidAdditionalPoint = function(x, y) {\n        pointsToAvoid[x + \"_\" + y] = 1;\n    };\n\n    /**\n    * Stop avoiding a particular point on the grid.\n    *\n    * @param {Number} x The x value of the point to stop avoiding.\n    * @param {Number} y The y value of the point to stop avoiding.\n    **/\n    this.stopAvoidingAdditionalPoint = function(x, y) {\n        delete pointsToAvoid[x + \"_\" + y];\n    };\n\n    /**\n    * Enables corner cutting in diagonal movement.\n    **/\n    this.enableCornerCutting = function() {\n        allowCornerCutting = true;\n    };\n\n    /**\n    * Disables corner cutting in diagonal movement.\n    **/\n    this.disableCornerCutting = function() {\n        allowCornerCutting = false;\n    };\n\n    /**\n    * Stop avoiding all additional points on the grid.\n    **/\n    this.stopAvoidingAllAdditionalPoints = function() {\n        pointsToAvoid = {};\n    };\n\n    /**\n    * Find a path.\n    *\n    * @param {Number} startX The X position of the starting point.\n    * @param {Number} startY The Y position of the starting point.\n    * @param {Number} endX The X position of the ending point.\n    * @param {Number} endY The Y position of the ending point.\n    * @param {Function} callback A function that is called when your path\n    * is found, or no path is found.\n    *\n    **/\n    this.findPath = function(startX, startY, endX, endY, callback) {\n        // Wraps the callback for sync vs async logic\n        var callbackWrapper = function(result) {\n            if (syncEnabled) {\n                callback(result);\n            } else {\n                setTimeout(function() {\n                    callback(result);\n                });\n            }\n        }\n\n        // No acceptable tiles were set\n        if (acceptableTiles === undefined) {\n            throw new Error(\"You can't set a path without first calling setAcceptableTiles() on EasyStar.\");\n        }\n        // No grid was set\n        if (collisionGrid === undefined) {\n            throw new Error(\"You can't set a path without first calling setGrid() on EasyStar.\");\n        }\n\n        // Start or endpoint outside of scope.\n        if (startX < 0 || startY < 0 || endX < 0 || endY < 0 ||\n        startX > collisionGrid[0].length-1 || startY > collisionGrid.length-1 ||\n        endX > collisionGrid[0].length-1 || endY > collisionGrid.length-1) {\n            throw new Error(\"Your start or end point is outside the scope of your grid.\");\n        }\n\n        // Start and end are the same tile.\n        if (startX===endX && startY===endY) {\n            callbackWrapper([]);\n            return;\n        }\n\n        // End point is not an acceptable tile.\n        var endTile = collisionGrid[endY][endX];\n        var isAcceptable = false;\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (endTile === acceptableTiles[i]) {\n                isAcceptable = true;\n                break;\n            }\n        }\n\n        if (isAcceptable === false) {\n            callbackWrapper(null);\n            return;\n        }\n\n        // Create the instance\n        var instance = new Instance();\n        instance.openList = new Heap(function(nodeA, nodeB) {\n            return nodeA.bestGuessDistance() - nodeB.bestGuessDistance();\n        });\n        instance.isDoneCalculating = false;\n        instance.nodeHash = {};\n        instance.startX = startX;\n        instance.startY = startY;\n        instance.endX = endX;\n        instance.endY = endY;\n        instance.callback = callbackWrapper;\n\n        instance.openList.push(coordinateToNode(instance, instance.startX,\n            instance.startY, null, STRAIGHT_COST));\n\n        instances.push(instance);\n    };\n\n    /**\n    * This method steps through the A* Algorithm in an attempt to\n    * find your path(s). It will search 4-8 tiles (depending on diagonals) for every calculation.\n    * You can change the number of calculations done in a call by using\n    * easystar.setIteratonsPerCalculation().\n    **/\n    this.calculate = function() {\n        if (instances.length === 0 || collisionGrid === undefined || acceptableTiles === undefined) {\n            return;\n        }\n        for (iterationsSoFar = 0; iterationsSoFar < iterationsPerCalculation; iterationsSoFar++) {\n            if (instances.length === 0) {\n                return;\n            }\n\n            if (syncEnabled) {\n                // If this is a sync instance, we want to make sure that it calculates synchronously.\n                iterationsSoFar = 0;\n            }\n\n            // Couldn't find a path.\n            if (instances[0].openList.size() === 0) {\n                var ic = instances[0];\n                ic.callback(null);\n                instances.shift();\n                continue;\n            }\n\n            var searchNode = instances[0].openList.pop();\n\n            // Handles the case where we have found the destination\n            if (instances[0].endX === searchNode.x && instances[0].endY === searchNode.y) {\n                instances[0].isDoneCalculating = true;\n                var path = [];\n                path.push({x: searchNode.x, y: searchNode.y});\n                var parent = searchNode.parent;\n                while (parent!=null) {\n                    path.push({x: parent.x, y:parent.y});\n                    parent = parent.parent;\n                }\n                path.reverse();\n                var ic = instances[0];\n                var ip = path;\n                ic.callback(ip);\n                return\n            }\n\n            var tilesToSearch = [];\n            searchNode.list = CLOSED_LIST;\n\n            if (searchNode.y > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: -1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y-1)});\n            }\n            if (searchNode.x < collisionGrid[0].length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x+1, searchNode.y)});\n            }\n            if (searchNode.y < collisionGrid.length-1) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: 0, y: 1, cost: STRAIGHT_COST * getTileCost(searchNode.x, searchNode.y+1)});\n            }\n            if (searchNode.x > 0) {\n                tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                    x: -1, y: 0, cost: STRAIGHT_COST * getTileCost(searchNode.x-1, searchNode.y)});\n            }\n            if (diagonalsEnabled) {\n                if (searchNode.x > 0 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y+1)});\n                    }\n                }\n                if (searchNode.x < collisionGrid[0].length-1 && searchNode.y > 0) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y-1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x+1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: 1, y: -1, cost: DIAGONAL_COST * getTileCost(searchNode.x+1, searchNode.y-1)});\n                    }\n                }\n                if (searchNode.x > 0 && searchNode.y < collisionGrid.length-1) {\n\n                    if (allowCornerCutting ||\n                        (isTileWalkable(collisionGrid, acceptableTiles, searchNode.x, searchNode.y+1) &&\n                        isTileWalkable(collisionGrid, acceptableTiles, searchNode.x-1, searchNode.y))) {\n\n\n                        tilesToSearch.push({ instance: instances[0], searchNode: searchNode,\n                            x: -1, y: 1, cost: DIAGONAL_COST * getTileCost(searchNode.x-1, searchNode.y+1)});\n                    }\n                }\n            }\n\n            var isDoneCalculating = false;\n\n            // Search all of the surrounding nodes\n            for (var i = 0; i < tilesToSearch.length; i++) {\n                checkAdjacentNode(tilesToSearch[i].instance, tilesToSearch[i].searchNode,\n                    tilesToSearch[i].x, tilesToSearch[i].y, tilesToSearch[i].cost);\n                if (tilesToSearch[i].instance.isDoneCalculating === true) {\n                    isDoneCalculating = true;\n                    break;\n                }\n            }\n\n            if (isDoneCalculating) {\n                instances.shift();\n                continue;\n            }\n\n        }\n    };\n\n    // Private methods follow\n    var checkAdjacentNode = function(instance, searchNode, x, y, cost) {\n        var adjacentCoordinateX = searchNode.x+x;\n        var adjacentCoordinateY = searchNode.y+y;\n\n        if (pointsToAvoid[adjacentCoordinateX + \"_\" + adjacentCoordinateY] === undefined &&\n            isTileWalkable(collisionGrid, acceptableTiles, adjacentCoordinateX, adjacentCoordinateY, searchNode)) {\n            var node = coordinateToNode(instance, adjacentCoordinateX,\n                adjacentCoordinateY, searchNode, cost);\n\n            if (node.list === undefined) {\n                node.list = OPEN_LIST;\n                instance.openList.push(node);\n            } else if (searchNode.costSoFar + cost < node.costSoFar) {\n                node.costSoFar = searchNode.costSoFar + cost;\n                node.parent = searchNode;\n                instance.openList.updateItem(node);\n            }\n        }\n    };\n\n    // Helpers\n    var isTileWalkable = function(collisionGrid, acceptableTiles, x, y, sourceNode) {\n        if (directionalConditions[x + \"_\" + y]) {\n            var direction = calculateDirection(sourceNode.x - x, sourceNode.y - y)\n            var directionIncluded = function () {\n                for (var i = 0; i < directionalConditions[x + \"_\" + y].length; i++) {\n                    if (directionalConditions[x + \"_\" + y][i] === direction) return true\n                }\n                return false\n            }\n            if (!directionIncluded()) return false\n        }\n        for (var i = 0; i < acceptableTiles.length; i++) {\n            if (collisionGrid[y][x] === acceptableTiles[i]) {\n                return true;\n            }\n        }\n\n        return false;\n    };\n\n    /**\n     * -1, -1 | 0, -1  | 1, -1\n     * -1,  0 | SOURCE | 1,  0\n     * -1,  1 | 0,  1  | 1,  1\n     */\n    var calculateDirection = function (diffX, diffY) {\n        if (diffX === 0, diffY === -1) return EasyStar.BOTTOM\n        else if (diffX === 1, diffY === -1) return EasyStar.BOTTOM_LEFT\n        else if (diffX === 1, diffY === 0) return EasyStar.LEFT\n        else if (diffX === 1, diffY === 1) return EasyStar.TOP_LEFT\n        else if (diffX === 0, diffY === 1) return EasyStar.TOP\n        else if (diffX === -1, diffY === 1) return EasyStar.TOP_RIGHT\n        else if (diffX === -1, diffY === 0) return EasyStar.RIGHT\n        else if (diffX === -1, diffY === -1) return EasyStar.BOTTOM_RIGHT\n        throw new Error('These differences are not valid: ' + diffX + ', ' + diffY)\n    };\n\n    var getTileCost = function(x, y) {\n        return pointsToCost[x + '_' + y] || costMap[collisionGrid[y][x]]\n    };\n\n    var coordinateToNode = function(instance, x, y, parent, cost) {\n        if (instance.nodeHash[x + \"_\" + y]!==undefined) {\n            return instance.nodeHash[x + \"_\" + y];\n        }\n        var simpleDistanceToTarget = getDistance(x, y, instance.endX, instance.endY);\n        if (parent!==null) {\n            var costSoFar = parent.costSoFar + cost;\n        } else {\n            costSoFar = 0;\n        }\n        var node = new Node(parent,x,y,costSoFar,simpleDistanceToTarget);\n        instance.nodeHash[x + \"_\" + y] = node;\n        return node;\n    };\n\n    var getDistance = function(x1,y1,x2,y2) {\n        if (diagonalsEnabled) {\n            // Octile distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            if (dx < dy) {\n                return DIAGONAL_COST * dx + dy;\n            } else {\n                return DIAGONAL_COST * dy + dx;\n            }\n        } else {\n            // Manhattan distance\n            var dx = Math.abs(x1 - x2);\n            var dy = Math.abs(y1 - y2);\n            return (dx + dy);\n        }\n    };\n}\n\nEasyStar.TOP = 'TOP'\nEasyStar.TOP_RIGHT = 'TOP_RIGHT'\nEasyStar.RIGHT = 'RIGHT'\nEasyStar.BOTTOM_RIGHT = 'BOTTOM_RIGHT'\nEasyStar.BOTTOM = 'BOTTOM'\nEasyStar.BOTTOM_LEFT = 'BOTTOM_LEFT'\nEasyStar.LEFT = 'LEFT'\nEasyStar.TOP_LEFT = 'TOP_LEFT'\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/easystarjs/src/easystar.js\n// module id = 46\n// module chunks = 0\n\n//# sourceURL=webpack:///./node_modules/easystarjs/src/easystar.js?")},function(module,exports){eval("/**\n * Represents a single instance of EasyStar.\n * A path that is in the queue to eventually be found.\n */\nmodule.exports = function() {\n    this.isDoneCalculating = true;\n    this.pointsToAvoid = {};\n    this.startX;\n    this.callback;\n    this.startY;\n    this.endX;\n    this.endY;\n    this.nodeHash = {};\n    this.openList;\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/easystarjs/src/instance.js\n// module id = 47\n// module chunks = 0\n\n//# sourceURL=webpack:///./node_modules/easystarjs/src/instance.js?")},function(module,exports){eval("/**\n* A simple Node that represents a single tile on the grid.\n* @param {Object} parent The parent node.\n* @param {Number} x The x position on the grid.\n* @param {Number} y The y position on the grid.\n* @param {Number} costSoFar How far this node is in moves*cost from the start.\n* @param {Number} simpleDistanceToTarget Manhatten distance to the end point.\n**/\nmodule.exports = function(parent, x, y, costSoFar, simpleDistanceToTarget) {\n    this.parent = parent;\n    this.x = x;\n    this.y = y;\n    this.costSoFar = costSoFar;\n    this.simpleDistanceToTarget = simpleDistanceToTarget;\n\n    /**\n    * @return {Number} Best guess distance of a cost using this node.\n    **/\n    this.bestGuessDistance = function() {\n        return this.costSoFar + this.simpleDistanceToTarget;\n    }\n};\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/easystarjs/src/node.js\n// module id = 48\n// module chunks = 0\n\n//# sourceURL=webpack:///./node_modules/easystarjs/src/node.js?")},function(module,exports,__webpack_require__){eval("module.exports = __webpack_require__(50);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/heap/index.js\n// module id = 49\n// module chunks = 0\n\n//# sourceURL=webpack:///./node_modules/heap/index.js?")},function(module,exports,__webpack_require__){eval("var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;// Generated by CoffeeScript 1.8.0\n(function() {\n  var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;\n\n  floor = Math.floor, min = Math.min;\n\n\n  /*\n  Default comparison function to be used\n   */\n\n  defaultCmp = function(x, y) {\n    if (x < y) {\n      return -1;\n    }\n    if (x > y) {\n      return 1;\n    }\n    return 0;\n  };\n\n\n  /*\n  Insert item x in list a, and keep it sorted assuming a is sorted.\n  \n  If x is already in a, insert it to the right of the rightmost x.\n  \n  Optional args lo (default 0) and hi (default a.length) bound the slice\n  of a to be searched.\n   */\n\n  insort = function(a, x, lo, hi, cmp) {\n    var mid;\n    if (lo == null) {\n      lo = 0;\n    }\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (lo < 0) {\n      throw new Error('lo must be non-negative');\n    }\n    if (hi == null) {\n      hi = a.length;\n    }\n    while (lo < hi) {\n      mid = floor((lo + hi) / 2);\n      if (cmp(x, a[mid]) < 0) {\n        hi = mid;\n      } else {\n        lo = mid + 1;\n      }\n    }\n    return ([].splice.apply(a, [lo, lo - lo].concat(x)), x);\n  };\n\n\n  /*\n  Push item onto heap, maintaining the heap invariant.\n   */\n\n  heappush = function(array, item, cmp) {\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    array.push(item);\n    return _siftdown(array, 0, array.length - 1, cmp);\n  };\n\n\n  /*\n  Pop the smallest item off the heap, maintaining the heap invariant.\n   */\n\n  heappop = function(array, cmp) {\n    var lastelt, returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    lastelt = array.pop();\n    if (array.length) {\n      returnitem = array[0];\n      array[0] = lastelt;\n      _siftup(array, 0, cmp);\n    } else {\n      returnitem = lastelt;\n    }\n    return returnitem;\n  };\n\n\n  /*\n  Pop and return the current smallest value, and add the new item.\n  \n  This is more efficient than heappop() followed by heappush(), and can be\n  more appropriate when using a fixed size heap. Note that the value\n  returned may be larger than item! That constrains reasonable use of\n  this routine unless written as part of a conditional replacement:\n      if item > array[0]\n        item = heapreplace(array, item)\n   */\n\n  heapreplace = function(array, item, cmp) {\n    var returnitem;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    returnitem = array[0];\n    array[0] = item;\n    _siftup(array, 0, cmp);\n    return returnitem;\n  };\n\n\n  /*\n  Fast version of a heappush followed by a heappop.\n   */\n\n  heappushpop = function(array, item, cmp) {\n    var _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (array.length && cmp(array[0], item) < 0) {\n      _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];\n      _siftup(array, 0, cmp);\n    }\n    return item;\n  };\n\n\n  /*\n  Transform list into a heap, in-place, in O(array.length) time.\n   */\n\n  heapify = function(array, cmp) {\n    var i, _i, _j, _len, _ref, _ref1, _results, _results1;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    _ref1 = (function() {\n      _results1 = [];\n      for (var _j = 0, _ref = floor(array.length / 2); 0 <= _ref ? _j < _ref : _j > _ref; 0 <= _ref ? _j++ : _j--){ _results1.push(_j); }\n      return _results1;\n    }).apply(this).reverse();\n    _results = [];\n    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n      i = _ref1[_i];\n      _results.push(_siftup(array, i, cmp));\n    }\n    return _results;\n  };\n\n\n  /*\n  Update the position of the given item in the heap.\n  This function should be called every time the item is being modified.\n   */\n\n  updateItem = function(array, item, cmp) {\n    var pos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    pos = array.indexOf(item);\n    if (pos === -1) {\n      return;\n    }\n    _siftdown(array, 0, pos, cmp);\n    return _siftup(array, pos, cmp);\n  };\n\n\n  /*\n  Find the n largest elements in a dataset.\n   */\n\n  nlargest = function(array, n, cmp) {\n    var elem, result, _i, _len, _ref;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    result = array.slice(0, n);\n    if (!result.length) {\n      return result;\n    }\n    heapify(result, cmp);\n    _ref = array.slice(n);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      elem = _ref[_i];\n      heappushpop(result, elem, cmp);\n    }\n    return result.sort(cmp).reverse();\n  };\n\n\n  /*\n  Find the n smallest elements in a dataset.\n   */\n\n  nsmallest = function(array, n, cmp) {\n    var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    if (n * 10 <= array.length) {\n      result = array.slice(0, n).sort(cmp);\n      if (!result.length) {\n        return result;\n      }\n      los = result[result.length - 1];\n      _ref = array.slice(n);\n      for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n        elem = _ref[_i];\n        if (cmp(elem, los) < 0) {\n          insort(result, elem, 0, null, cmp);\n          result.pop();\n          los = result[result.length - 1];\n        }\n      }\n      return result;\n    }\n    heapify(array, cmp);\n    _results = [];\n    for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {\n      _results.push(heappop(array, cmp));\n    }\n    return _results;\n  };\n\n  _siftdown = function(array, startpos, pos, cmp) {\n    var newitem, parent, parentpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    newitem = array[pos];\n    while (pos > startpos) {\n      parentpos = (pos - 1) >> 1;\n      parent = array[parentpos];\n      if (cmp(newitem, parent) < 0) {\n        array[pos] = parent;\n        pos = parentpos;\n        continue;\n      }\n      break;\n    }\n    return array[pos] = newitem;\n  };\n\n  _siftup = function(array, pos, cmp) {\n    var childpos, endpos, newitem, rightpos, startpos;\n    if (cmp == null) {\n      cmp = defaultCmp;\n    }\n    endpos = array.length;\n    startpos = pos;\n    newitem = array[pos];\n    childpos = 2 * pos + 1;\n    while (childpos < endpos) {\n      rightpos = childpos + 1;\n      if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {\n        childpos = rightpos;\n      }\n      array[pos] = array[childpos];\n      pos = childpos;\n      childpos = 2 * pos + 1;\n    }\n    array[pos] = newitem;\n    return _siftdown(array, startpos, pos, cmp);\n  };\n\n  Heap = (function() {\n    Heap.push = heappush;\n\n    Heap.pop = heappop;\n\n    Heap.replace = heapreplace;\n\n    Heap.pushpop = heappushpop;\n\n    Heap.heapify = heapify;\n\n    Heap.updateItem = updateItem;\n\n    Heap.nlargest = nlargest;\n\n    Heap.nsmallest = nsmallest;\n\n    function Heap(cmp) {\n      this.cmp = cmp != null ? cmp : defaultCmp;\n      this.nodes = [];\n    }\n\n    Heap.prototype.push = function(x) {\n      return heappush(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pop = function() {\n      return heappop(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.peek = function() {\n      return this.nodes[0];\n    };\n\n    Heap.prototype.contains = function(x) {\n      return this.nodes.indexOf(x) !== -1;\n    };\n\n    Heap.prototype.replace = function(x) {\n      return heapreplace(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.pushpop = function(x) {\n      return heappushpop(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.heapify = function() {\n      return heapify(this.nodes, this.cmp);\n    };\n\n    Heap.prototype.updateItem = function(x) {\n      return updateItem(this.nodes, x, this.cmp);\n    };\n\n    Heap.prototype.clear = function() {\n      return this.nodes = [];\n    };\n\n    Heap.prototype.empty = function() {\n      return this.nodes.length === 0;\n    };\n\n    Heap.prototype.size = function() {\n      return this.nodes.length;\n    };\n\n    Heap.prototype.clone = function() {\n      var heap;\n      heap = new Heap();\n      heap.nodes = this.nodes.slice(0);\n      return heap;\n    };\n\n    Heap.prototype.toArray = function() {\n      return this.nodes.slice(0);\n    };\n\n    Heap.prototype.insert = Heap.prototype.push;\n\n    Heap.prototype.top = Heap.prototype.peek;\n\n    Heap.prototype.front = Heap.prototype.peek;\n\n    Heap.prototype.has = Heap.prototype.contains;\n\n    Heap.prototype.copy = Heap.prototype.clone;\n\n    return Heap;\n\n  })();\n\n  (function(root, factory) {\n    if (true) {\n      return !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else if (typeof exports === 'object') {\n      return module.exports = factory();\n    } else {\n      return root.Heap = factory();\n    }\n  })(this, function() {\n    return Heap;\n  });\n\n}).call(this);\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./node_modules/heap/lib/heap.js\n// module id = 50\n// module chunks = 0\n\n//# sourceURL=webpack:///./node_modules/heap/lib/heap.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (immutable) */ __webpack_exports__["a"] = willZombiesPathsInterfere;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MapUtils__ = __webpack_require__(0);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__objects_ZombieComponents_ZombiePathManager__ = __webpack_require__(12);\n\n\n\nfunction willZombiesPathsInterfere( zombie1, zombie2 ) {\n  if ( !isZombieInMovement( zombie1 ) || !isZombieInMovement( zombie2 ) ) {\n    return false;\n  }\n\n  const zombie1NextTile = getZombieNextStepTarget( zombie1 );\n  const zombie2NextTile = getZombieNextStepTarget( zombie2 );\n  const zombie1CurrentTile = getZombieCurrentStepTarget( zombie1 );\n  const zombie2CurrentTile = getZombieCurrentStepTarget( zombie2 );\n\n  return Object(__WEBPACK_IMPORTED_MODULE_0__MapUtils__["a" /* areTilesTheSame */])( zombie1NextTile, zombie2NextTile )\n   || Object(__WEBPACK_IMPORTED_MODULE_0__MapUtils__["a" /* areTilesTheSame */])( zombie1NextTile, zombie2CurrentTile )\n   || Object(__WEBPACK_IMPORTED_MODULE_0__MapUtils__["a" /* areTilesTheSame */])( zombie1CurrentTile, zombie2CurrentTile )\n   || Object(__WEBPACK_IMPORTED_MODULE_0__MapUtils__["a" /* areTilesTheSame */])( zombie2CurrentTile, zombie2CurrentTile );\n}\n\nfunction getZombieNextStepTarget( zombie ) {\n  let nextStepTarget;\n  switch ( zombie.state ) {\n  case __WEBPACK_IMPORTED_MODULE_1__objects_ZombieComponents_ZombiePathManager__["a" /* STATES */].ON_STANDARD_PATH:\n    nextStepTarget = getZombieNextStandardStepTarget( zombie );\n    break;\n  case __WEBPACK_IMPORTED_MODULE_1__objects_ZombieComponents_ZombiePathManager__["a" /* STATES */].ON_TEMPORARY_PATH:\n    nextStepTarget = getZombieNextTemporaryStepTarget( zombie );\n  }\n  return nextStepTarget;\n}\n\nfunction getZombieNextStandardStepTarget( zombie ) {\n  let nextStepTargetIndex = zombie.currentStepIndex + 1;\n  let nextStepTargetPathIndex = zombie.currentPathIndex;\n\n  if ( nextStepTargetIndex === zombie.pathsBetweenTargets[ zombie.currentPathIndex ].path.length ) {\n    nextStepTargetIndex = 0;\n    nextStepTargetPathIndex++;\n\n    if ( nextStepTargetPathIndex === zombie.pathsBetweenTargets.length ) {\n      nextStepTargetPathIndex = 0;\n    }\n  }\n\n  return zombie.pathsBetweenTargets[ nextStepTargetPathIndex ].path[ nextStepTargetIndex ];\n}\n\nfunction getZombieNextTemporaryStepTarget( zombie ) {\n  let nextTemporaryStepTargetIndex = zombie.temporaryStepIndex + 1;\n\n  if ( nextTemporaryStepTargetIndex === zombie.temporaryPath.length ) {\n    let nextPathIndex = zombie.currentPathIndex + 1;\n\n    if ( nextPathIndex === zombie.pathsBetweenTargets.length ) {\n      return zombie.pathsBetweenTargets[ 0 ].path[ 1 ];\n    }\n    return zombie.pathsBetweenTargets[ nextPathIndex ].path[ 1 ];\n  }\n  return zombie.temporaryPath[ nextTemporaryStepTargetIndex ];\n}\n\nfunction getZombieCurrentStepTarget( zombie ) {\n  switch ( zombie.state ) {\n  case __WEBPACK_IMPORTED_MODULE_1__objects_ZombieComponents_ZombiePathManager__["a" /* STATES */].ON_STANDARD_PATH:\n    return zombie.getCurrentStepTarget();\n  case __WEBPACK_IMPORTED_MODULE_1__objects_ZombieComponents_ZombiePathManager__["a" /* STATES */].ON_TEMPORARY_PATH:\n    return zombie.getTemporaryStepTarget();\n  }\n}\n\nfunction isZombieInMovement( zombie ) {\n  return zombie.state !== __WEBPACK_IMPORTED_MODULE_1__objects_ZombieComponents_ZombiePathManager__["a" /* STATES */].CALCULATING_PATH && zombie.state !== __WEBPACK_IMPORTED_MODULE_1__objects_ZombieComponents_ZombiePathManager__["a" /* STATES */].NOT_STARTED;\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/DeterminePathCollisionUtils.js\n// module id = 51\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/utils/DeterminePathCollisionUtils.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony export (immutable) */ __webpack_exports__[\"a\"] = getFreeTileAroundZombieExcludingOtherZombie;\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__MapUtils__ = __webpack_require__(0);\n\n\nfunction getFreeTileAroundZombieExcludingOtherZombie( zombie, zombieToExclude, mapGrid ) {\n  const zombieTile = Object(__WEBPACK_IMPORTED_MODULE_0__MapUtils__[\"d\" /* pixelsToTile */])( zombie );\n\n  let collisionSide = getBodyCollisionSide( zombie, zombieToExclude );\n\n  const tileToExclude = getTileToExcludeBaseOnCollisionSide( zombieTile, collisionSide );\n\n  return getFreeTileAroundTileExcludingOtherTile( zombieTile, tileToExclude, mapGrid );\n}\n\nfunction getBodyCollisionSide( zombie1, zombie2 ) {\n  const zombieOffsetX = zombie1.position.x - zombie2.position.x;\n  const zombieOffsetY = zombie1.position.y - zombie2.position.y;\n\n  const directionX = ( zombieOffsetX > 0 ) ? 'LEFT' : 'RIGHT';\n  const directionY = ( zombieOffsetY > 0 ) ? 'UP' : 'DOWN';\n\n  return ( Math.abs( zombieOffsetX ) < Math.abs( zombieOffsetY ) ) ? directionX : directionY;\n}\n\nfunction getTileToExcludeBaseOnCollisionSide( tile, collisionSide ) {\n  const tileCandidates = getTileCandidates( tile );\n\n  switch ( collisionSide ) {\n  case 'UP':\n    return tileCandidates[ 0 ];\n  case 'DOWN':\n    return tileCandidates[ 1 ];\n  case 'LEFT':\n    return tileCandidates[ 2 ];\n  case 'RIGHT':\n    return tileCandidates[ 3 ];\n  }\n}\n\nfunction getFreeTileAroundTileExcludingOtherTile( tile, tileToExclude, mapGrid ) {\n  const tileCandidates = getTileCandidates( tile );\n\n  for ( const tileCandidate of tileCandidates ) {\n    if ( !Object(__WEBPACK_IMPORTED_MODULE_0__MapUtils__[\"a\" /* areTilesTheSame */])( tileCandidate, tileToExclude )\n     && !isWall( tileCandidate, mapGrid ) ) {\n      return tileCandidate;\n    }\n  }\n\n  throw new Error( 'Couldn\\'t find tile' );\n}\n\nfunction isWall( tile, mapGrid ) {\n  return mapGrid[ tile.x ][ tile.y ] === 1;\n}\n\nfunction getTileCandidates( tile ) {\n  return [\n    { x: tile.x, y: tile.y - 1 },\n    { x: tile.x, y: tile.y + 1 },\n    { x: tile.x - 1, y: tile.y },\n    { x: tile.x + 1, y: tile.y },\n  ];\n\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/HandlePathCollisionUtils.js\n// module id = 52\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/utils/HandlePathCollisionUtils.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_MapUtils__ = __webpack_require__(0);\n\n\n\nclass ZombieRotationManager {\n  constructor( zombie ) {\n    this.zombie = zombie;\n  }\n  update( tileTarget ) {\n    const lookTarget = this.getLookTarget( tileTarget );\n    const targetPoint = new Phaser.Point( lookTarget.x, lookTarget.y );\n    const entityCenter = new Phaser.Point( this.zombie.body.x + this.zombie.width / 2, this.zombie.body.y + this.zombie.height / 2 );\n\n    let deltaTargetRad = this.zombie.rotation - Phaser.Math.angleBetweenPoints( targetPoint, entityCenter ) - 1.5 * Math.PI;\n\n    deltaTargetRad = deltaTargetRad % ( Math.PI * 2 );\n\n    if ( deltaTargetRad != deltaTargetRad % ( Math.PI ) ) {\n      deltaTargetRad = deltaTargetRad + Math.PI * ( ( deltaTargetRad < 0 ) ? 2 : -2 );\n    }\n\n    this.zombie.body.rotateLeft( __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["i" /* ZOMBIE_ROTATING_SPEED */] * deltaTargetRad );\n  }\n  getLookTarget( tile ) {\n    const velocity = this.zombie.body.velocity;\n    const tileCoords = Object(__WEBPACK_IMPORTED_MODULE_1__utils_MapUtils__["e" /* tileToPixels */])( tile );\n    const veryFarAway = 1000;\n\n    if ( Math.abs( velocity.x ) > Math.abs( velocity.y ) ) {\n      if ( velocity.x > 0 ) {\n        tileCoords.x += veryFarAway;\n      } else {\n        tileCoords.x -= veryFarAway;\n      }\n    } else if ( Math.abs( velocity.x ) < Math.abs( velocity.y ) ) {\n      if ( velocity.y > 0 ) {\n        tileCoords.y += veryFarAway;\n      } else {\n        tileCoords.y -= veryFarAway;\n      }\n    }\n\n    return tileCoords;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = ZombieRotationManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/ZombieComponents/ZombieRotationManager.js\n// module id = 53\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/ZombieComponents/ZombieRotationManager.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_MathUtils__ = __webpack_require__(55);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__EventsManager__ = __webpack_require__(3);\n\n\n\n\nclass SeekingPlayerManager {\n  constructor( zombie, player, walls ) {\n    this.zombie = zombie;\n    this.player = player;\n    this.walls = walls;\n\n    this.state = 'searching';\n\n    this.isPlayerInViewRange = false;\n    this.isPlayerInHearingRange = false;\n\n    const body = zombie.body;\n\n    const viewSensor = body.addCircle( __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__[\"k\" /* ZOMBIE_SIGHT_RANGE */] );\n    viewSensor.sensor = true;\n    viewSensor.sensorType = 'view';\n\n    const hearSensor = body.addCircle( __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__[\"f\" /* ZOMBIE_HEARING_RANGE */] );\n    hearSensor.sensor = true;\n    hearSensor.sensorType = 'hear';\n\n    __WEBPACK_IMPORTED_MODULE_2__EventsManager__[\"a\" /* default */].create( `chasePlayer-${ zombie.id }` );\n\n    this.shouldLookForThePlayer = true;\n\n    this.isNotified = false;\n  }\n  update() {\n\n    if ( this.shouldLookForThePlayer && this.canDetectPlayer() ) {\n      this.changeStateToChasing();\n    }\n  }\n\n  canDetectPlayer() {\n    if ( this.isPlayerDead || this.isPlayerSeparatedFromZombie( this.player.position ) ) {\n      return false;\n    }\n\n    if ( this.isNotified === true ) {\n      return true;\n    }\n\n    return this.canSeePlayer() || this.canHearPlayer();\n  }\n  isPlayerSeparatedFromZombie( playerPosition ) {\n       /** Draw line between player and zombie and check if it can see him. If yes, chase him. */\n    const playerSeekingRay = new Phaser.Line();\n    playerSeekingRay.start.set( this.zombie.x, this.zombie.y );\n    playerSeekingRay.end.set( playerPosition.x, playerPosition.y );\n\n    const tileHits = this.walls.getRayCastTiles( playerSeekingRay, 0, false, false );\n\n    for ( let i = 0; i < tileHits.length; i++ ) {\n      if ( tileHits[ i ].index >= 0 ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n  canSeePlayer() {\n    return ( this.isPlayerInViewRange && Object(__WEBPACK_IMPORTED_MODULE_1__utils_MathUtils__[\"a\" /* isInDegreeRange */])( this.zombie, this.player, __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__[\"j\" /* ZOMBIE_SIGHT_ANGLE */] ) );\n  }\n  canHearPlayer() {\n    return ( this.isPlayerInHearingRange && !this.player.isSneaking && this.player.isMoving() );\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA ) {\n    if ( this.isItSensorArea( bodyA, shapeA ) ) {\n      if ( shapeA.sensorType === 'view' && bodyA.sprite.key === 'player' ) {\n        this.isPlayerInViewRange = true;\n      } else if ( shapeA.sensorType === 'hear' && bodyA.sprite.key === 'player' ) {\n        this.isPlayerInHearingRange = true;\n      }\n    }\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA ) {\n    if ( this.isItSensorArea( bodyA, shapeA ) ) {\n      if ( shapeA.sensorType === 'view' && bodyA.sprite.key === 'player' ) {\n        this.isPlayerInViewRange = false;\n      } else if ( shapeA.sensorType === 'hear' && bodyA.sprite.key === 'player' ) {\n        this.isPlayerInHearingRange = false;\n      }\n    }\n  }\n  isItSensorArea( body, shape ) {\n    if ( body == null || body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n\n    return shape.sensor;\n  }\n  changeStateToChasing() {\n    this.lastKnownPlayerPosition = Object.assign( {}, this.player.position );\n    __WEBPACK_IMPORTED_MODULE_2__EventsManager__[\"a\" /* default */].dispatch( `chasePlayer-${this.zombie.id}` );\n  }\n  getLastKnownPlayerPosition() {\n    if ( this.canDetectPlayer() ) {\n      this.lastKnownPlayerPosition = Object.assign( {}, this.player.position );\n    }\n    return this.lastKnownPlayerPosition;\n  }\n  stopLookingForThePlayer() {\n    this.shouldLookForThePlayer = false;\n  }\n  onStopChasing() {\n    this.isNotified = false;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = SeekingPlayerManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/ZombieComponents/SeekingPlayerManager.js\n// module id = 54\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/ZombieComponents/SeekingPlayerManager.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony export (immutable) */ __webpack_exports__["a"] = isInDegreeRange;\nfunction isInDegreeRange( entity, target, sightAngle ) {\n  const angleDelta = Math.abs( Phaser.Math.radToDeg( Phaser.Math.angleBetween( entity.x, entity.y, target.x, target.y ) ) + 90 - entity.angle );\n\n  return angleDelta <= sightAngle || angleDelta >= ( 360 - sightAngle );\n}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/MathUtils.js\n// module id = 55\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/utils/MathUtils.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__ = __webpack_require__(1);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__NotificationsManager__ = __webpack_require__(57);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__EventsManager__ = __webpack_require__(3);\n\n\n\n\nclass ChasingPlayerManager {\n  constructor( zombie, player ) {\n    this.zombie = zombie;\n    this.player = player;\n\n    __WEBPACK_IMPORTED_MODULE_2__EventsManager__["a" /* default */].create( `stopChasingPlayer-${ zombie.id }` );\n\n    // attack system init\n    this.canDealDamage = true;\n    this.isInAttackRange = false;\n\n    const attackSensor = this.zombie.body.addCircle( __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["b" /* ZOMBIE_ATTACK_RANGE */] );\n    attackSensor.sensor = true;\n    attackSensor.sensorType = \'attack\';\n\n    this.notificationsManager = new __WEBPACK_IMPORTED_MODULE_1__NotificationsManager__["a" /* default */]( this.zombie );\n\n    this.lastKnownPlayerPosition = Object.assign( {}, this.player.position );\n  }\n  update( lastKnownPlayerPosition ) {\n    this.lastKnownPlayerPosition = lastKnownPlayerPosition;\n    this.zombie.game.physics.arcade.moveToObject( this.zombie, lastKnownPlayerPosition, __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["l" /* ZOMBIE_SPEED */] * __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["m" /* ZOMBIE_SPEED_CHASING_MULTIPLIER */] );\n    this.zombie.lookAt( lastKnownPlayerPosition.x, lastKnownPlayerPosition.y );\n\n    this.notificationsManager.update();\n\n    if ( this.shouldZombieStopChasingPlayer( lastKnownPlayerPosition ) ) {\n      this.stopChasingPlayer();\n    }\n\n    if ( this.shouldAttack() ) {\n      this.handleAttack();\n    }\n  }\n  shouldZombieStopChasingPlayer( lastKnownPlayerPosition ) {\n    const distanceToTarget = this.zombie.game.physics.arcade.distanceBetween( this.zombie, lastKnownPlayerPosition );\n    return ( this.player.x !== lastKnownPlayerPosition.x || this.player.y !== lastKnownPlayerPosition.y )\n     && distanceToTarget <= __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["a" /* MIN_DISTANCE_TO_TARGET */];\n  }\n  stopChasingPlayer() {\n    __WEBPACK_IMPORTED_MODULE_2__EventsManager__["a" /* default */].dispatch( `stopChasingPlayer-${this.zombie.id}` );\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA ) {\n    if ( bodyA == null || bodyA.sprite == null ) {\n      return;\n    }\n    if ( shapeA.sensorType === \'attack\' && bodyA.sprite.key === \'player\' ) {\n      this.isInAttackRange = true;\n    }\n    this.notificationsManager.onCollisionEnter( bodyA, bodyB, shapeA );\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA ) {\n    if ( bodyA == null || bodyA.sprite == null ) {\n      return;\n    }\n    if ( shapeA.sensorType === \'attack\' && bodyA.sprite.key === \'player\' ) {\n      this.isInAttackRange = false;\n    }\n\n    this.notificationsManager.onCollisionLeave( bodyA, bodyB, shapeA );\n  }\n  shouldAttack() {\n    return this.zombie.alive && this.canDealDamage && this.isInAttackRange;\n  }\n  handleAttack() {\n    this.zombie.animations.play( \'attack\', __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["e" /* ZOMBIE_FIGHT_ANIMATION_FRAMERATE */], false );\n    this.player.takeDamage( __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["d" /* ZOMBIE_DAMAGE_VALUE */] );\n    this.canDealDamage = false;\n    this.zombie.game.time.events.add( Phaser.Timer.SECOND * __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["c" /* ZOMBIE_DAMAGE_COOLDOWN */], this.endCooldown, this );\n    this.zombie.game.camera.shake( 0.005, 100, false );\n  }\n  endCooldown() {\n    this.canDealDamage = true;\n    this.zombie.animations.play( \'walk\', __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__["n" /* ZOMBIE_WALK_ANIMATION_FRAMERATE */], true );\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = ChasingPlayerManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/ZombieComponents/ChasingPlayerManager.js\n// module id = 56\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/ZombieComponents/ChasingPlayerManager.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__ = __webpack_require__(1);\n\n\nclass NotificationsManager {\n  constructor( zombie ) {\n    this.zombie = zombie;\n\n    const notifySensor = zombie.body.addCircle( __WEBPACK_IMPORTED_MODULE_0__constants_ZombieConstants__[\"h\" /* ZOMBIE_NOTIFY_RANGE */] );\n    notifySensor.sensor = true;\n    notifySensor.sensorType = 'notify';\n\n    this.zombiesToNotify = new Set();\n  }\n  isItNotifySensor( shape, body ) {\n    if ( !body || !body.sprite ) {\n      return false;\n    }\n    return shape.sensorType === 'notify' && body.sprite.key === 'zombie';\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA ) {\n    if ( this.isItNotifySensor( shapeA, bodyA ) ) {\n      this.zombiesToNotify.add( bodyA.sprite );\n    }\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA ) {\n    if ( this.isItNotifySensor( shapeA, bodyA ) ) {\n      this.zombiesToNotify.delete( bodyA.sprite );\n    }\n  }\n  update() {\n    for ( const zombieToNotify of this.zombiesToNotify ) {\n      this.handleNotificationTry( zombieToNotify );\n    }\n  }\n  handleNotificationTry( zombieToNotify ) {\n    if ( zombieToNotify.isChasing() === false ) {\n      this.notify( zombieToNotify );\n    }\n  }\n  notify( zombieToNotify ) {\n    console.log( 'try' );\n    if ( !zombieToNotify.seekingPlayerManager.isPlayerSeparatedFromZombie( this.zombie.chasingPlayerManager.lastKnownPlayerPosition ) ) {\n      console.log( 'chase', this.zombie.chasingPlayerManager.lastKnownPlayerPosition );\n      zombieToNotify.startChasingByBeingNotified( this.zombie.chasingPlayerManager.lastKnownPlayerPosition );\n    }\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = NotificationsManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/ZombieComponents/NotificationsManager.js\n// module id = 57\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/ZombieComponents/NotificationsManager.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__utils_MapUtils_js__ = __webpack_require__(0);\n\n\nclass TileMap extends Phaser.Tilemap {\n  constructor( game, key, tileWidth, tileHeight ) {\n    super( game, key, tileWidth, tileHeight );\n\n    this.addTilesetImage( 'tilemap_floor' );\n    this.addTilesetImage( 'tilemap_walls' );\n\n    this.ground = this.createLayer( 'background' );\n    this.walls = this.createLayer( 'walls' );\n\n    this.paths = [];\n    this.journals = [];\n\n    this.setCollisionByExclusion( [], true, this.walls );\n\n    this.ground.resizeWorld();\n\n    this.wallsBodiesArray = game.physics.p2.convertTilemap( this, this.walls );\n\n    this.wallsCollisionGroup = this.game.physics.p2.createCollisionGroup();\n\n    for ( const body of this.wallsBodiesArray ) {\n      body.setCollisionGroup( this.wallsCollisionGroup );\n    }\n\n    this.createPathPoints();\n  }\n  collides( collisionGroup, callback ) {\n    for ( const body of this.wallsBodiesArray ) {\n      body.collides( collisionGroup, callback );\n    }\n  }\n  createPathPoints() {\n    this.objects[ 'ZombiePaths' ].forEach( ( v ) => {\n      const props = v.properties;\n      if ( !this.paths[ props.PathId ] ) {\n        this.paths[ props.PathId ] = [];\n      }\n\n      this.paths[ props.PathId ][ props.PathIndex ] = Object(__WEBPACK_IMPORTED_MODULE_0__utils_MapUtils_js__[\"d\" /* pixelsToTile */])( { x: v.x, y: v.y } );\n    } );\n\n    this.normalizePaths();\n  }\n  getJournals() {\n    const allJournals = this.objects[ 'Journals' ];\n    const journals = [];\n    allJournals.forEach( ( v ) => {\n      const props = v.properties;\n      journals.push(\n        {\n          x: v.x,\n          y: v.y,\n          cornerX: props.cornerX,\n          cornerY: props.cornerY,\n          name: v.name,\n          content: props.content,\n        }\n      );\n    } );\n\n    return journals;\n  }\n  getPlayerInitialPosition() {\n    const player = this.objects[ 'PlayerPos' ][ 0 ];\n    const posObj = {\n      x: player.x,\n      y: player.y,\n    };\n    return posObj;\n  }\n  normalizePaths() {\n    this.paths.forEach( ( pathArr ) => {\n      const tempArr = [];\n      pathArr.forEach( ( v ) => {\n        tempArr.push( v );\n      } );\n\n      pathArr = tempArr;\n    } );\n  }\n  getPath( i ) {\n    return this.paths[ i ];\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = TileMap;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/TileMap.js\n// module id = 58\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/TileMap.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_UserInterfaceUtils__ = __webpack_require__(13);\n\n\n\nclass JournalsManager extends Phaser.Group {\n  constructor( game, player ) {\n    super( game );\n\n    const style = { font: \'24px Arial\', fill: \'#fff\' };\n\n    this.messageText = this.game.add.text( 0, 0, \'\', style );\n    this.messageText.x = 24;\n    this.messageText.y = this.game.height - 24 - 32;\n    this.messageText.fixedToCamera = true;\n\n    this.player = player;\n\n    this.activateKey = this.game.input.keyboard.addKey( Phaser.Keyboard.E );\n    this.activateKey.onDown.add( this.tryToShowJournal, this );\n    this.game.input.keyboard.removeKeyCapture( Phaser.Keyboard.E );\n\n    this.activateKey = this.game.input.keyboard.addKey( Phaser.Keyboard.ESC );\n    this.activateKey.onDown.add( this.tryToHideJournal, this );\n    this.game.input.keyboard.removeKeyCapture( Phaser.Keyboard.ESC );\n\n    this.isJournalOpened = false;\n  }\n  tryToShowJournal() {\n    if ( this.isJournalOpened ) {\n      return;\n    }\n    const approachedJournals = this.children.filter( journal => journal.hasPlayerApproached );\n    if ( approachedJournals.length > 0 ) {\n      this.isJournalOpened = true;\n      this.game.paused = true;\n      this.messageText.setText( \'Press \\\'ESC\\\' to close personal journal.\' );\n\n      const nearestJournal = this.getJournalNearestToPlayer( approachedJournals );\n      this.showJournal( nearestJournal );\n    }\n  }\n  getJournalNearestToPlayer( journals ) {\n    let nearestJournal = journals[ 0 ];\n\n    journals.forEach( ( journal ) => {\n      if ( Phaser.Math.distance( this.player.x, this.player.y, journal.x, journal.y )\n      < Phaser.Math.distance( this.player.x, this.player.y, nearestJournal.x, nearestJournal.y ) ) {\n        nearestJournal = journal;\n      }\n    } );\n\n    return nearestJournal;\n  }\n  showJournal( journalToShow ) {\n    const screenCenter = Object(__WEBPACK_IMPORTED_MODULE_1__utils_UserInterfaceUtils__["a" /* getScreenCenter */])( this.game );\n\n    this.backgroundLayer = Object(__WEBPACK_IMPORTED_MODULE_1__utils_UserInterfaceUtils__["b" /* showBackgroundLayer */])( this.game );\n\n    this.ui = this.game.add.sprite( screenCenter.x, screenCenter.y + __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["i" /* MAGIC_OFFSET_FIXING_VALUE */], \'journal-ui\' );\n    this.ui.anchor.setTo( 0.5 );\n\n    const textStyle = {\n      align: \'left\',\n      fill: \'#10aede\',\n      font: `bold ${__WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["g" /* JOURNAL_TEXT_FONT_SIZE */]}px Arial`,\n      padding: \'0\',\n      margin: \'0\',\n    };\n\n    this.uiText = this.game.add.text( screenCenter.x - __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["f" /* JOURNAL_TEXT_FIELD_WIDTH */] / 2, screenCenter.y - __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["e" /* JOURNAL_TEXT_FIELD_HEIGHT */] / 2, journalToShow.content, textStyle );\n    this.uiText.wordWrap = true;\n    this.uiText.wordWrapWidth = __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["f" /* JOURNAL_TEXT_FIELD_WIDTH */];\n\n    this.maskGraphics = this.game.add.graphics( 0, 0 );\n    this.maskGraphics.beginFill( 0xffffff );\n    this.maskGraphics.drawRect( screenCenter.x - __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["f" /* JOURNAL_TEXT_FIELD_WIDTH */] / 2, this.uiText.y, __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["f" /* JOURNAL_TEXT_FIELD_WIDTH */], __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["e" /* JOURNAL_TEXT_FIELD_HEIGHT */] );\n\n    this.uiText.mask = this.maskGraphics;\n\n    this.scrollBar = this.game.add.graphics( screenCenter.x + __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["f" /* JOURNAL_TEXT_FIELD_WIDTH */] / 2, this.uiText.y );\n    this.scrollBar.alpha = 0.5;\n    this.scrollBarHeight = ( this.uiText.height > __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["e" /* JOURNAL_TEXT_FIELD_HEIGHT */] ) ? Math.pow( __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["e" /* JOURNAL_TEXT_FIELD_HEIGHT */], 2 ) / this.uiText.height : __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["e" /* JOURNAL_TEXT_FIELD_HEIGHT */];\n    this.scrollBarOffset = 0;\n    this.scrollBarStep = ( __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["h" /* JOURNAL_TEXT_SCROLL_STEP */] / this.uiText.height ) * __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["e" /* JOURNAL_TEXT_FIELD_HEIGHT */];\n\n    this.drawScrollBar();\n  }\n  tryToHideJournal() {\n    if ( this.isJournalOpened && this.game.paused ) {\n      this.isJournalOpened = false;\n      this.game.paused = false;\n      this.messageText.setText( \'Press \\\'E\\\' to open personal journal.\' );\n      this.backgroundLayer.destroy();\n      this.ui.destroy();\n      this.uiText.destroy();\n      this.maskGraphics.destroy();\n      this.scrollBar.destroy();\n    }\n  }\n  onCollisionEnter( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.messageText.setText( \'Press \\\'E\\\' to open personal journal.\' );\n      bodyA.sprite.hasPlayerApproached = true;\n    }\n  }\n  onCollisionLeave( bodyA, bodyB, shapeA, shapeB ) {\n    if ( this.isItSensorArea( bodyA, shapeB ) ) {\n      this.messageText.setText( \'\' );\n      bodyA.sprite.hasPlayerApproached = false;\n    }\n  }\n  isItSensorArea( body, shape ) {\n    if ( body.sprite == null || shape.sensor == null ) {\n      return false;\n    }\n    // for now this line assume that there is only one type of computer\'s textures\n    // TODO enable different sprite key\'s handling\n    return body.sprite.key === \'computer\' && shape.sensor;\n  }\n  onMouseWheel( ) {\n    if ( this.isJournalOpened === false ) {\n      return;\n    }\n    const directionY = this.game.input.mouse.wheelDelta;\n\n    if ( directionY === 1 && this.uiText.y < this.game.camera.y + this.game.camera.height / 2 - __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["e" /* JOURNAL_TEXT_FIELD_HEIGHT */] / 2 ) {\n      this.uiText.y += __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["h" /* JOURNAL_TEXT_SCROLL_STEP */];\n      this.drawScrollBar( -this.scrollBarStep );\n    } else if ( directionY === -1 && this.uiText.y > this.game.camera.y + this.game.camera.height / 2 + __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["e" /* JOURNAL_TEXT_FIELD_HEIGHT */] / 2 - this.uiText.height ) {\n      this.uiText.y -= __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["h" /* JOURNAL_TEXT_SCROLL_STEP */];\n      this.drawScrollBar( this.scrollBarStep );\n    }\n  }\n  drawScrollBar( y = 0 ) {\n    this.scrollBarOffset += y;\n    this.scrollBar.clear();\n    this.scrollBar.beginFill( 0xffffff );\n    this.scrollBar.drawRect( 0, this.scrollBarOffset, __WEBPACK_IMPORTED_MODULE_0__constants_ItemConstants__["d" /* JOURNAL_SCROLL_BAR_WIDTH */], this.scrollBarHeight );\n    this.scrollBar.endFill();\n  }\n  clearUI() {\n    this.tryToHideJournal();\n    this.messageText.destroy();\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = JournalsManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/JournalsManager.js\n// module id = 59\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/JournalsManager.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__ = __webpack_require__(7);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__LightsComponents_JournalLight__ = __webpack_require__(61);\n\n\n\n\nclass Journal extends Phaser.Sprite {\n  constructor( game, content, imageKey ) {\n\n    super( game, 0, 0, imageKey );\n\n    this.game.world.add( this );\n\n    this.hasPlayerApproached = false;\n\n    this.content = content;\n\n    this.light = null;\n  }\n  setCorner( cornerX, cornerY ) {\n    this.cornerX = cornerX;\n    this.cornerY = cornerY;\n  }\n  setPosition( tileX, tileY ) {\n    const cornerX = this.cornerX || \'WEST\';\n    const cornerY = this.cornerY || \'NORTH\';\n\n    const offsetX = ( cornerX === \'WEST\' ) ? ( __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["b" /* COMPUTER_WIDTH */] / 2 ) : __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */] - ( __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["b" /* COMPUTER_WIDTH */] / 2 );\n    const offsetY = ( cornerY === \'NORTH\' ) ? ( __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["a" /* COMPUTER_HEIGHT */] / 2 ) : __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */] - ( __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["a" /* COMPUTER_HEIGHT */] / 2 );\n\n    const x = tileX + offsetX;\n    const y = tileY + offsetY;\n\n    this.x = x;\n    this.y = y;\n  }\n  enableJournal() {\n    const cornerX = this.cornerX || \'WEST\';\n    const cornerY = this.cornerY || \'NORTH\';\n\n    this.game.physics.p2.enable( this );\n    this.body.static = true;\n\n    let sensorOffsetX = ( __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */] - __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["b" /* COMPUTER_WIDTH */] ) / ( ( cornerX === \'WEST\' ) ? 2 : -2 );\n    let sensorOffsetY = ( __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */] - __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["a" /* COMPUTER_HEIGHT */] ) / ( ( cornerY === \'NORTH\' ) ? 2 : -2 );\n\n    if ( cornerY === \'SOUTH\' ) {\n      this.body.angle = 180;\n      sensorOffsetX += ( __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */] - __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["b" /* COMPUTER_WIDTH */] ) * ( ( sensorOffsetX < 0 ) ? 1 : -1 );\n      sensorOffsetY += ( __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */] - __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["a" /* COMPUTER_HEIGHT */] ) * ( ( sensorOffsetY < 0 ) ? 1 : -1 );\n    }\n\n    const rectangleSensor = this.body.addRectangle( __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */], __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */], sensorOffsetX, sensorOffsetY );\n    rectangleSensor.sensor = true;\n\n    this.anchor.setTo( 0.5 );\n    this.light = new __WEBPACK_IMPORTED_MODULE_2__LightsComponents_JournalLight__["a" /* default */]( this );\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = Journal;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/Journal.js\n// module id = 60\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/Journal.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RoundLight__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__ = __webpack_require__(7);\n\n\nclass JournalLight extends __WEBPACK_IMPORTED_MODULE_0__RoundLight__["a" /* default */] {\n  constructor( position ) {\n    super( position, __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["j" /* RAY_LENGTH */] );\n  }\n  getFillStyle( ctx, offset ) {\n    const rayLength = __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["j" /* RAY_LENGTH */] * ( 1 + Math.random() * __WEBPACK_IMPORTED_MODULE_1__constants_ItemConstants__["c" /* FLICKERING_POWER */] );\n    const gradient = ctx.createRadialGradient(\n        this.x - offset.x, this.y - offset.y, rayLength * 0.4 * 2,\n        this.x - offset.x, this.y - offset.y, rayLength * 2 );\n    gradient.addColorStop( 0, \'rgba(208, 255, 175, 1)\' );\n    gradient.addColorStop( 1, \'rgba(208, 255, 175, 0.0)\' );\n\n    return gradient;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = JournalLight;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/LightsComponents/JournalLight.js\n// module id = 61\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/LightsComponents/JournalLight.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__ = __webpack_require__(2);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_MapUtils_js__ = __webpack_require__(0);\n\n\n\nclass ZombiesBoidsManager extends Phaser.Group {\n  constructor( game, mapGrid, boidsDistance = Math.max( __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["c" /* TILE_WIDTH */], __WEBPACK_IMPORTED_MODULE_0__constants_TileMapConstants__["b" /* TILE_HEIGHT */] ), distanceBetweenBoidsAndWalls = boidsDistance ) {\n    super( game );\n    this.entities = this.children;\n    this.mapGrid = mapGrid;\n    this.boidsDistance = boidsDistance;\n    this.distanceBetweenBoidsAndWalls = distanceBetweenBoidsAndWalls;\n    this.game = game;\n  }\n  update() {\n    Phaser.Group.prototype.update.call( this );\n\n    for ( const boid of this.entities ) {\n      if ( boid.isChasing() === false ) {\n        continue;\n      }\n      const velocity1 = this.flyTowardsMassCenterRule( boid );\n      const velocity2 = this.keepSmallDistanceFromObstaclesRule( boid );\n      const velocity3 = this.tryMatchingOtherEnitiesVelocityRule( boid );\n\n      boid.body.velocity.x += velocity1.x + velocity2.x + velocity3.x;\n      boid.body.velocity.y += velocity1.y + velocity2.y + velocity3.y;\n    }\n  }\n  flyTowardsMassCenterRule( boid ) {\n    const velocity = { x: 0, y: 0 };\n\n    for ( const entity of this.entities ) {\n      if ( entity === boid ) {\n        continue;\n      }\n      velocity.x += entity.body.x;\n      velocity.y += entity.body.y;\n    }\n\n    velocity.x = ( velocity.x / ( this.entities.length - 1 ) ) / 100;\n    velocity.y = ( velocity.y / ( this.entities.length - 1 ) ) / 100;\n\n    return velocity;\n  }\n  keepSmallDistanceFromObstaclesRule( boid ) {\n    const velocity = { x: 0, y: 0 };\n\n    for ( const otherBoid of this.entities ) {\n      if ( otherBoid === boid ) {\n        continue;\n      }\n      if ( this.game.physics.arcade.distanceBetween( otherBoid, boid ) <= this.boidsDistance ) {\n        velocity.x -= otherBoid.body.x - boid.body.x;\n        velocity.y -= otherBoid.body.y - boid.body.y;\n      }\n    }\n\n    const wallBodies = this.getAdjoiningWallBodies( boid );\n    for ( const wallBody of wallBodies ) {\n      if ( this.game.physics.arcade.distanceBetween( wallBody, boid ) <= this.distanceBetweenBoidsAndWalls ) {\n        velocity.x -= wallBody.x - boid.body.x;\n        velocity.y -= wallBody.y - boid.body.y;\n      }\n    }\n\n    return velocity;\n  }\n  getAdjoiningWallBodies( entity ) {\n    const entityTile = Object(__WEBPACK_IMPORTED_MODULE_1__utils_MapUtils_js__["d" /* pixelsToTile */])( entity );\n    const adjoiningTiles = [\n      { x: entityTile.x - 1, y: entityTile.y - 1 },\n      { x: entityTile.x - 1, y: entityTile.y },\n      { x: entityTile.x - 1, y: entityTile.y + 1 },\n      { x: entityTile.x, y: entityTile.y - 1 },\n      { x: entityTile.x, y: entityTile.y + 1 },\n      { x: entityTile.x + 1, y: entityTile.y - 1 },\n      { x: entityTile.x + 1, y: entityTile.y },\n      { x: entityTile.x + 1, y: entityTile.y + 1 },\n    ];\n\n    const adjoiningWallTiles = adjoiningTiles.filter( ( tile ) => this.mapGrid[ tile.y ][ tile.x ] === 1 );\n    return adjoiningWallTiles.map( __WEBPACK_IMPORTED_MODULE_1__utils_MapUtils_js__["e" /* tileToPixels */] );\n  }\n  tryMatchingOtherEnitiesVelocityRule() {\n    return { x: 0, y: 0 };\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = ZombiesBoidsManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/BoidsManager.js\n// module id = 62\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/BoidsManager.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__constants_UserInterfaceConstants__ = __webpack_require__(64);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__utils_UserInterfaceUtils__ = __webpack_require__(13);\n\n\n\n\nclass GameOverUI {\n  constructor( game, mainMenuCallback, restartCallback ) {\n    this.game = game;\n    this.mainMenuCallback = mainMenuCallback;\n    this.restartCallback = restartCallback;\n  }\n  start() {\n    const screenCenter = Object(__WEBPACK_IMPORTED_MODULE_1__utils_UserInterfaceUtils__[\"a\" /* getScreenCenter */])( this.game );\n\n    this.backgroundLayer = Object(__WEBPACK_IMPORTED_MODULE_1__utils_UserInterfaceUtils__[\"b\" /* showBackgroundLayer */])( this.game );\n    this.backgroundLayer.alpha = 0;\n    this.game.add.tween( this.backgroundLayer ).to( { alpha: 0.5 }, __WEBPACK_IMPORTED_MODULE_0__constants_UserInterfaceConstants__[\"a\" /* END_SCREEN_FADE_IN_DURATION */], 'Linear', true );\n\n    const textStyle = {\n      align: 'center',\n      fill: 'white',\n      font: 'bold 80px Arial',\n    };\n\n    const mainText = this.game.add.text( screenCenter.x, screenCenter.y, 'YOU DIED!', textStyle );\n    mainText.anchor.setTo( 0.5 );\n    mainText.alpha = 0;\n    const fadingInTween = this.game.add.tween( mainText ).to( { alpha: 1 }, __WEBPACK_IMPORTED_MODULE_0__constants_UserInterfaceConstants__[\"a\" /* END_SCREEN_FADE_IN_DURATION */], 'Linear', true );\n    fadingInTween.onComplete.add( () => this.showEndScreenButtons() );\n  }\n  showEndScreenButtons() {\n    const mainMenuButton = this.game.add.button( this.game.camera.x + 100, this.game.camera.y + this.game.camera.height - 100, 'main-menu-btn' );\n    mainMenuButton.anchor.setTo( 0, 1 );\n    mainMenuButton.onInputUp.add( () => this.mainMenuCallback() );\n\n    const restartLevelButton = this.game.add.button( this.game.camera.x + this.game.camera.width - 100, this.game.camera.y + this.game.camera.height - 100, 'restart-btn' );\n    restartLevelButton.anchor.setTo( 1, 1 );\n    restartLevelButton.onInputUp.add( () => this.restartCallback() );\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = GameOverUI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/UI/GameOverUI.js\n// module id = 63\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/UI/GameOverUI.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const END_SCREEN_FADE_IN_DURATION = 2500;\n/* harmony export (immutable) */ __webpack_exports__["a"] = END_SCREEN_FADE_IN_DURATION;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants/UserInterfaceConstants.js\n// module id = 64\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/constants/UserInterfaceConstants.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval("class PlayerUI {\n  constructor( game ) {\n    this.game = game;\n    this.healthbar = this.game.add.graphics( 0, 0 );\n    this.healthbar.anchor.x = 1;\n    this.healthbar.anchor.y = 1;\n    this.healthbar.fixedToCamera = true;\n\n    const style = { font: '16px Arial', fill: '#fff' };\n\n    this.sneakText = this.game.add.text( 0, 0, 'Sneaking: off', style );\n    this.sneakText.x = this.game.width - ( this.sneakText.width + 24 );\n    this.sneakText.y = this.game.height - ( this.sneakText.height + 24 + 32 );\n    this.sneakText.fixedToCamera = true;\n    this.sneakText.stroke = '#000';\n    this.sneakText.strokeThickness = 3;\n\n    this.sprintText = this.game.add.text( 0, 0, 'Sprinting: off', style );\n    this.sprintText.x = this.game.width - ( this.sprintText.width + 24 );\n    this.sprintText.y = this.game.height - ( this.sprintText.height + 24 + 32 + this.sneakText.height );\n    this.sprintText.fixedToCamera = true;\n    this.sprintText.stroke = '#000';\n    this.sprintText.strokeThickness = 3;\n  }\n  setPlayerHealth( health ) {\n    this.health = health;\n  }\n  setPlayerMovementInfo( isSneaking, isSprinting ) {\n    Object.assign( this, { isSneaking, isSprinting } );\n  }\n  render() {\n    this.drawPlayerMovementInfo();\n    this.drawHealthBar();\n  }\n  drawPlayerMovementInfo() {\n    this.sneakText.setText( 'Sneaking: ' + ( ( this.isSneaking ) ? 'on' : 'off' ) );\n    this.sprintText.setText( 'Sprinting: ' + ( ( this.isSprinting ) ? 'on' : 'off' ) );\n  }\n  drawHealthBar() {\n    const width = 300;\n    const height = 32;\n\n    this.healthbar.clear();\n    this.healthbar.beginFill( 0xFF0000, 0.85 );\n\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width * Math.max( this.health, 0 ), height );\n    this.healthbar.endFill();\n    if ( this.godMode ) {\n      this.healthbar.lineStyle( 2, 0xCEAD00, 1 );\n    } else {\n      this.healthbar.lineStyle( 2, 0x880000, 1 );\n    }\n    this.healthbar.drawRect( this.game.width - ( width + 24 ), this.game.height - ( height + 24 ), width, height );\n    this.healthbar.lineStyle( 0 );\n  }\n  destroy() {\n    this.healthbar.destroy();\n    this.sneakText.destroy();\n    this.sprintText.destroy();\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__[\"a\"] = PlayerUI;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/UI/PlayerUI.js\n// module id = 65\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/UI/PlayerUI.js?")},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__Lightable__ = __webpack_require__(6);\n\n\nclass LightManager {\n  constructor( game, walls ) {\n    this.game = game;\n    this.walls = walls;\n\n    this.cachedLights = [];\n    this.dynamicallyRenderedLightables = [];\n\n    this.shadowTexture = this.game.add.bitmapData( this.game.camera.width + 200, this.game.camera.height + 200 );\n\n    this.lightImage = this.game.add.image( 0, 0, this.shadowTexture );\n    this.lightImage.blendMode = Phaser.blendModes.MULTIPLY;\n  }\n  add( lightable ) {\n    if ( !( lightable instanceof __WEBPACK_IMPORTED_MODULE_0__Lightable__["a" /* default */] ) ) {\n      return;\n    }\n\n    if ( lightable.isStatic ) {\n      const lightShape = lightable.getLightShapePoints( this.walls );\n      const getFillStyle = lightable.getFillStyle.bind( lightable );\n      this.cachedLights.push( { lightShape, getFillStyle } );\n    } else {\n      this.dynamicallyRenderedLightables.push( lightable );\n    }\n  }\n  update() {\n    this.updateImagePosition();\n    this.render();\n  }\n  updateImagePosition() {\n    this.lightImage.x = this.game.camera.x - 100;\n    this.lightImage.y = this.game.camera.y - 100;\n  }\n  render() {\n    this.shadowTexture.dirty = true;\n    this.shadowTexture.clear();\n\n    const ctx = this.shadowTexture.ctx;\n    ctx.fillStyle = \'#050505\';\n    ctx.fillRect( 0, 0, this.game.camera.width + 200, this.game.camera.height + 200 );\n\n    this.dynamicallyRenderedLightables.forEach( lightable => {\n      ctx.beginPath();\n      ctx.fillStyle = lightable.getFillStyle( ctx, this.lightImage.position );\n      const shapePointsNotOffseted = lightable.getLightShapePoints( this.walls );\n      const shapePoints = shapePointsNotOffseted.map( point => (\n        { x: point.x - this.lightImage.x, y: point.y - this.lightImage.y }\n      ) );\n\n\n      ctx.moveTo( shapePoints[ 0 ].x, shapePoints[ 0 ].y );\n\n      for ( let i = 1; i < shapePoints.length; i++ ) {\n        ctx.lineTo( shapePoints[ i ].x, shapePoints[ i ].y );\n      }\n\n      ctx.lineTo( shapePoints[ 0 ].x, shapePoints[ 0 ].y );\n      ctx.fill();\n    } );\n\n    this.cachedLights.forEach( light => {\n      ctx.beginPath();\n      ctx.fillStyle = light.getFillStyle( ctx, this.lightImage.position );\n      const shapePoints = light.lightShape.map( point => (\n        { x: point.x - this.lightImage.x, y: point.y - this.lightImage.y }\n      ) );\n\n      ctx.moveTo( shapePoints[ 0 ].x, shapePoints[ 0 ].y );\n\n      for ( let i = 1; i < shapePoints.length; i++ ) {\n        ctx.lineTo( shapePoints[ i ].x, shapePoints[ i ].y );\n      }\n\n      ctx.lineTo( shapePoints[ 0 ].x, shapePoints[ 0 ].y );\n      ctx.fill();\n    } );\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = LightManager;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/LightsComponents/LightsManager.js\n// module id = 66\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/LightsComponents/LightsManager.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__RoundLight__ = __webpack_require__(14);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__constants_TorchConstants__ = __webpack_require__(68);\n\n\nclass TorchlLight extends __WEBPACK_IMPORTED_MODULE_0__RoundLight__["a" /* default */] {\n  constructor( position ) {\n    super( position, __WEBPACK_IMPORTED_MODULE_1__constants_TorchConstants__["b" /* RAY_LENGTH */] );\n  }\n  getFillStyle( ctx, offset ) {\n    const rayLength = __WEBPACK_IMPORTED_MODULE_1__constants_TorchConstants__["b" /* RAY_LENGTH */] * ( 1 + Math.random() * __WEBPACK_IMPORTED_MODULE_1__constants_TorchConstants__["a" /* FLICKERING_POWER */] );\n    const gradient = ctx.createRadialGradient(\n        this.x - offset.x, this.y - offset.y, __WEBPACK_IMPORTED_MODULE_1__constants_TorchConstants__["b" /* RAY_LENGTH */] * 0.4 * 2,\n        this.x - offset.x, this.y - offset.y, rayLength * 2 );\n    gradient.addColorStop( 0, \'rgba(243,20,49, 1)\' );\n    gradient.addColorStop( 1, \'rgba(243,20,49, 0.0)\' );\n\n    return gradient;\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = TorchlLight;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/objects/LightsComponents/TorchLight.js\n// module id = 67\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/objects/LightsComponents/TorchLight.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const RAY_LENGTH = 120;\n/* harmony export (immutable) */ __webpack_exports__["b"] = RAY_LENGTH;\n\nconst FLICKERING_POWER = 0.04;\n/* harmony export (immutable) */ __webpack_exports__["a"] = FLICKERING_POWER;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/constants/TorchConstants.js\n// module id = 68\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/constants/TorchConstants.js?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('const IdCreator = () => {\n  let id = 0;\n\n  return () => {\n    return id++;\n  };\n};\n/* harmony export (immutable) */ __webpack_exports__["a"] = IdCreator;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/utils/IdCreator.js\n// module id = 69\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/utils/IdCreator.js?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/34b7f24cca662bb42c902c7cb7daa76d.json";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/levels/level1/map.json\n// module id = 70\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/levels/level1/map.json?')},function(module,__webpack_exports__,__webpack_require__){"use strict";eval('/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__states_Game_js__ = __webpack_require__(9);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assets_levels_level2_map2_json__ = __webpack_require__(72);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1_assets_levels_level2_map2_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1_assets_levels_level2_map2_json__);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assets_levels_level1_journals_json__ = __webpack_require__(15);\n/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2_assets_levels_level1_journals_json___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2_assets_levels_level1_journals_json__);\n\n\n\n\n\nclass Level1 extends __WEBPACK_IMPORTED_MODULE_0__states_Game_js__["a" /* default */] {\n  preload() {\n    __WEBPACK_IMPORTED_MODULE_0__states_Game_js__["a" /* default */].prototype.preload.call( this );\n\n    this.load.tilemap( \'map\', __WEBPACK_IMPORTED_MODULE_1_assets_levels_level2_map2_json___default.a, null, Phaser.Tilemap.TILED_JSON );\n    this.load.json( \'journals\', __WEBPACK_IMPORTED_MODULE_2_assets_levels_level1_journals_json___default.a );\n  }\n  create() {\n    __WEBPACK_IMPORTED_MODULE_0__states_Game_js__["a" /* default */].prototype.create.call( this );\n    console.log( \'level2 loaded\' );\n  }\n}\n/* harmony export (immutable) */ __webpack_exports__["a"] = Level1;\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./src/levels/Level2.js\n// module id = 71\n// module chunks = 0\n\n//# sourceURL=webpack:///./src/levels/Level2.js?')},function(module,exports,__webpack_require__){eval('module.exports = __webpack_require__.p + "static/6181c49dd08be125695589f24acf2b73.json";\n\n//////////////////\n// WEBPACK FOOTER\n// ./static/assets/levels/level2/map2.json\n// module id = 72\n// module chunks = 0\n\n//# sourceURL=webpack:///./static/assets/levels/level2/map2.json?')}],[16]);